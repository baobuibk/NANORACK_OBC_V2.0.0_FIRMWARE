
04_obc_v111_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08100000  08100000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d720  08100298  08100298  00001298  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000009c  0810d9b8  0810d9b8  0000e9b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0810da54  0810da54  0000ea54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .fini_array   00000004  0810da58  0810da58  0000ea58  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         0000012c  10032000  0810da5c  0000f000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00002118  1003212c  0810db88  0000f12c  2**2
                  ALLOC
  7 ._user_heap_stack 00000a04  10034244  0810db88  0000f244  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  0000f12c  2**0
                  CONTENTS, READONLY
  9 .debug_info   00024573  00000000  00000000  0000f15c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 000050fc  00000000  00000000  000336cf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00002080  00000000  00000000  000387d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 000018c3  00000000  00000000  0003a850  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00044c2f  00000000  00000000  0003c113  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00028c64  00000000  00000000  00080d42  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    001a6be1  00000000  00000000  000a99a6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .comment      00000043  00000000  00000000  00250587  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00008994  00000000  00000000  002505cc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line_str 00000068  00000000  00000000  00258f60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08100298 <__do_global_dtors_aux>:
 8100298:	b510      	push	{r4, lr}
 810029a:	4c05      	ldr	r4, [pc, #20]	@ (81002b0 <__do_global_dtors_aux+0x18>)
 810029c:	7823      	ldrb	r3, [r4, #0]
 810029e:	b933      	cbnz	r3, 81002ae <__do_global_dtors_aux+0x16>
 81002a0:	4b04      	ldr	r3, [pc, #16]	@ (81002b4 <__do_global_dtors_aux+0x1c>)
 81002a2:	b113      	cbz	r3, 81002aa <__do_global_dtors_aux+0x12>
 81002a4:	4804      	ldr	r0, [pc, #16]	@ (81002b8 <__do_global_dtors_aux+0x20>)
 81002a6:	f3af 8000 	nop.w
 81002aa:	2301      	movs	r3, #1
 81002ac:	7023      	strb	r3, [r4, #0]
 81002ae:	bd10      	pop	{r4, pc}
 81002b0:	1003212c 	.word	0x1003212c
 81002b4:	00000000 	.word	0x00000000
 81002b8:	0810d9a0 	.word	0x0810d9a0

081002bc <frame_dummy>:
 81002bc:	b508      	push	{r3, lr}
 81002be:	4b03      	ldr	r3, [pc, #12]	@ (81002cc <frame_dummy+0x10>)
 81002c0:	b11b      	cbz	r3, 81002ca <frame_dummy+0xe>
 81002c2:	4903      	ldr	r1, [pc, #12]	@ (81002d0 <frame_dummy+0x14>)
 81002c4:	4803      	ldr	r0, [pc, #12]	@ (81002d4 <frame_dummy+0x18>)
 81002c6:	f3af 8000 	nop.w
 81002ca:	bd08      	pop	{r3, pc}
 81002cc:	00000000 	.word	0x00000000
 81002d0:	10032130 	.word	0x10032130
 81002d4:	0810d9a0 	.word	0x0810d9a0

081002d8 <SCH_Initialize>:
 * @brief  Function initializes scheduler
 * @param  None
 * @retval None
 *****************************************************************************/
void SCH_Initialize(void)
{
 81002d8:	b580      	push	{r7, lr}
 81002da:	af00      	add	r7, sp, #0
    s_SystemTick = RESET;
 81002dc:	4b17      	ldr	r3, [pc, #92]	@ (810033c <SCH_Initialize+0x64>)
 81002de:	2200      	movs	r2, #0
 81002e0:	601a      	str	r2, [r3, #0]
    s_NumOfTaskScheduled = RESET;
 81002e2:	4b17      	ldr	r3, [pc, #92]	@ (8100340 <SCH_Initialize+0x68>)
 81002e4:	2200      	movs	r2, #0
 81002e6:	701a      	strb	r2, [r3, #0]
    s_NumOfTimers = RESET;
 81002e8:	4b16      	ldr	r3, [pc, #88]	@ (8100344 <SCH_Initialize+0x6c>)
 81002ea:	2200      	movs	r2, #0
 81002ec:	701a      	strb	r2, [r3, #0]
    
#ifdef USE_SCH_SEMAPHORE
    s_NumOfSemaphores = RESET;
 81002ee:	4b16      	ldr	r3, [pc, #88]	@ (8100348 <SCH_Initialize+0x70>)
 81002f0:	2200      	movs	r2, #0
 81002f2:	701a      	strb	r2, [r3, #0]
#endif

    s_SchedulerRunning = FALSE;
 81002f4:	4b15      	ldr	r3, [pc, #84]	@ (810034c <SCH_Initialize+0x74>)
 81002f6:	2200      	movs	r2, #0
 81002f8:	701a      	strb	r2, [r3, #0]

    // Initial Scheduler Context
    memset((uint8_t *)&s_TaskContext[0], RESET, (sizeof(SCH_TaskContextTypedef) * MAX_TASK));
 81002fa:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 81002fe:	2100      	movs	r1, #0
 8100300:	4813      	ldr	r0, [pc, #76]	@ (8100350 <SCH_Initialize+0x78>)
 8100302:	f00d fb13 	bl	810d92c <memset>
    memset((uint8_t *)&s_TimerContext[0], RESET, (sizeof(SCH_TimerContextTypedef) * MAX_TIMERS));
 8100306:	22a0      	movs	r2, #160	@ 0xa0
 8100308:	2100      	movs	r1, #0
 810030a:	4812      	ldr	r0, [pc, #72]	@ (8100354 <SCH_Initialize+0x7c>)
 810030c:	f00d fb0e 	bl	810d92c <memset>
    memset((uint8_t *)&s_SoftTimers[0], RESET, (sizeof(uint32_t) * SCH_TIM_LAST));
 8100310:	2208      	movs	r2, #8
 8100312:	2100      	movs	r1, #0
 8100314:	4810      	ldr	r0, [pc, #64]	@ (8100358 <SCH_Initialize+0x80>)
 8100316:	f00d fb09 	bl	810d92c <memset>
    memset((uint8_t *)&s_TaskPending[0], RESET, (sizeof(uint32_t) * NUM_TASK_PENDING_ARRAYS));
 810031a:	2204      	movs	r2, #4
 810031c:	2100      	movs	r1, #0
 810031e:	480f      	ldr	r0, [pc, #60]	@ (810035c <SCH_Initialize+0x84>)
 8100320:	f00d fb04 	bl	810d92c <memset>
    memset((uint8_t *)&s_TimerPending[0], RESET, (sizeof(uint32_t) * NUM_TIMER_PENDING_ARRAYS));
 8100324:	2204      	movs	r2, #4
 8100326:	2100      	movs	r1, #0
 8100328:	480d      	ldr	r0, [pc, #52]	@ (8100360 <SCH_Initialize+0x88>)
 810032a:	f00d faff 	bl	810d92c <memset>
#ifdef USE_SCH_SEMAPHORE
    memset((uint8_t *)&s_SemaphoreContext[0], RESET, (sizeof(SCH_SemaphoreTypedef) * MAX_SEMAPHORES));
 810032e:	2204      	movs	r2, #4
 8100330:	2100      	movs	r1, #0
 8100332:	480c      	ldr	r0, [pc, #48]	@ (8100364 <SCH_Initialize+0x8c>)
 8100334:	f00d fafa 	bl	810d92c <memset>
#endif
}
 8100338:	bf00      	nop
 810033a:	bd80      	pop	{r7, pc}
 810033c:	10032384 	.word	0x10032384
 8100340:	100322cc 	.word	0x100322cc
 8100344:	10032370 	.word	0x10032370
 8100348:	10032378 	.word	0x10032378
 810034c:	10032148 	.word	0x10032148
 8100350:	1003214c 	.word	0x1003214c
 8100354:	100322d0 	.word	0x100322d0
 8100358:	10032388 	.word	0x10032388
 810035c:	1003237c 	.word	0x1003237c
 8100360:	10032380 	.word	0x10032380
 8100364:	10032374 	.word	0x10032374

08100368 <SCH_TASK_CreateTask>:
 * @param  SCH_TASK_HANDLE* pHandle - pointer to task handle
 *         SCH_TaskPropertyTypedef TaskProperty
 * @retval status
 *****************************************************************************/
SCH_Status SCH_TASK_CreateTask(SCH_TASK_HANDLE *pHandle, SCH_TaskPropertyTypedef *pTaskProperty)
{
 8100368:	b580      	push	{r7, lr}
 810036a:	b084      	sub	sp, #16
 810036c:	af00      	add	r7, sp, #0
 810036e:	6078      	str	r0, [r7, #4]
 8100370:	6039      	str	r1, [r7, #0]
    SCH_Status status = SCH_ERROR;
 8100372:	2301      	movs	r3, #1
 8100374:	73fb      	strb	r3, [r7, #15]
    if (pHandle && pTaskProperty)
 8100376:	687b      	ldr	r3, [r7, #4]
 8100378:	2b00      	cmp	r3, #0
 810037a:	d030      	beq.n	81003de <SCH_TASK_CreateTask+0x76>
 810037c:	683b      	ldr	r3, [r7, #0]
 810037e:	2b00      	cmp	r3, #0
 8100380:	d02d      	beq.n	81003de <SCH_TASK_CreateTask+0x76>
    {
        if (s_NumOfTaskScheduled < MAX_TASK)
 8100382:	4b19      	ldr	r3, [pc, #100]	@ (81003e8 <SCH_TASK_CreateTask+0x80>)
 8100384:	781b      	ldrb	r3, [r3, #0]
 8100386:	2b0f      	cmp	r3, #15
 8100388:	d829      	bhi.n	81003de <SCH_TASK_CreateTask+0x76>
        {
            SCH_TaskContextTypedef *pTaskContext = &s_TaskContext[s_NumOfTaskScheduled];
 810038a:	4b17      	ldr	r3, [pc, #92]	@ (81003e8 <SCH_TASK_CreateTask+0x80>)
 810038c:	781b      	ldrb	r3, [r3, #0]
 810038e:	461a      	mov	r2, r3
 8100390:	4613      	mov	r3, r2
 8100392:	005b      	lsls	r3, r3, #1
 8100394:	4413      	add	r3, r2
 8100396:	00db      	lsls	r3, r3, #3
 8100398:	4a14      	ldr	r2, [pc, #80]	@ (81003ec <SCH_TASK_CreateTask+0x84>)
 810039a:	4413      	add	r3, r2
 810039c:	60bb      	str	r3, [r7, #8]
            memcpy(&pTaskContext->taskProperty, pTaskProperty, sizeof(SCH_TaskPropertyTypedef));
 810039e:	68bb      	ldr	r3, [r7, #8]
 81003a0:	3308      	adds	r3, #8
 81003a2:	2210      	movs	r2, #16
 81003a4:	6839      	ldr	r1, [r7, #0]
 81003a6:	4618      	mov	r0, r3
 81003a8:	f00d faec 	bl	810d984 <memcpy>
            pTaskContext->currentTick = 0;
 81003ac:	68bb      	ldr	r3, [r7, #8]
 81003ae:	2200      	movs	r2, #0
 81003b0:	605a      	str	r2, [r3, #4]
            pTaskContext->taskState = (pTaskProperty->taskType == SCH_TASK_ASYNC) 
 81003b2:	683b      	ldr	r3, [r7, #0]
 81003b4:	781b      	ldrb	r3, [r3, #0]
                                                        ? TASK_StateHold : TASK_StateReady;
 81003b6:	2b02      	cmp	r3, #2
 81003b8:	bf14      	ite	ne
 81003ba:	2301      	movne	r3, #1
 81003bc:	2300      	moveq	r3, #0
 81003be:	b2db      	uxtb	r3, r3
 81003c0:	461a      	mov	r2, r3
            pTaskContext->taskState = (pTaskProperty->taskType == SCH_TASK_ASYNC) 
 81003c2:	68bb      	ldr	r3, [r7, #8]
 81003c4:	701a      	strb	r2, [r3, #0]

            *pHandle = s_NumOfTaskScheduled;
 81003c6:	4b08      	ldr	r3, [pc, #32]	@ (81003e8 <SCH_TASK_CreateTask+0x80>)
 81003c8:	781a      	ldrb	r2, [r3, #0]
 81003ca:	687b      	ldr	r3, [r7, #4]
 81003cc:	701a      	strb	r2, [r3, #0]
            s_NumOfTaskScheduled++;
 81003ce:	4b06      	ldr	r3, [pc, #24]	@ (81003e8 <SCH_TASK_CreateTask+0x80>)
 81003d0:	781b      	ldrb	r3, [r3, #0]
 81003d2:	3301      	adds	r3, #1
 81003d4:	b2da      	uxtb	r2, r3
 81003d6:	4b04      	ldr	r3, [pc, #16]	@ (81003e8 <SCH_TASK_CreateTask+0x80>)
 81003d8:	701a      	strb	r2, [r3, #0]
            status = SCH_DONE;
 81003da:	2300      	movs	r3, #0
 81003dc:	73fb      	strb	r3, [r7, #15]
        }
    }
    return status;
 81003de:	7bfb      	ldrb	r3, [r7, #15]
}
 81003e0:	4618      	mov	r0, r3
 81003e2:	3710      	adds	r7, #16
 81003e4:	46bd      	mov	sp, r7
 81003e6:	bd80      	pop	{r7, pc}
 81003e8:	100322cc 	.word	0x100322cc
 81003ec:	1003214c 	.word	0x1003214c

081003f0 <SCH_RunSystemTickTimer>:
 * @brief  Function handles system tick timer
 * @param  None
 * @retval None
 *****************************************************************************/
void SCH_RunSystemTickTimer(void)
{
 81003f0:	b480      	push	{r7}
 81003f2:	b087      	sub	sp, #28
 81003f4:	af00      	add	r7, sp, #0
    if (s_SchedulerRunning)
 81003f6:	4b54      	ldr	r3, [pc, #336]	@ (8100548 <SCH_RunSystemTickTimer+0x158>)
 81003f8:	781b      	ldrb	r3, [r3, #0]
 81003fa:	2b00      	cmp	r3, #0
 81003fc:	f000 809e 	beq.w	810053c <SCH_RunSystemTickTimer+0x14c>
    {
        uint8_t taskIndex;
        SCH_TaskContextTypedef *pTaskContext;
        uint8_t timerIndex;
        SCH_TimerContextTypedef *pTimerContext;
        s_SystemTick++;
 8100400:	4b52      	ldr	r3, [pc, #328]	@ (810054c <SCH_RunSystemTickTimer+0x15c>)
 8100402:	681b      	ldr	r3, [r3, #0]
 8100404:	3301      	adds	r3, #1
 8100406:	4a51      	ldr	r2, [pc, #324]	@ (810054c <SCH_RunSystemTickTimer+0x15c>)
 8100408:	6013      	str	r3, [r2, #0]
        // Task
        for (taskIndex = 0; taskIndex < s_NumOfTaskScheduled; taskIndex++)
 810040a:	2300      	movs	r3, #0
 810040c:	75fb      	strb	r3, [r7, #23]
 810040e:	e035      	b.n	810047c <SCH_RunSystemTickTimer+0x8c>
        {
            pTaskContext = &s_TaskContext[taskIndex];
 8100410:	7dfa      	ldrb	r2, [r7, #23]
 8100412:	4613      	mov	r3, r2
 8100414:	005b      	lsls	r3, r3, #1
 8100416:	4413      	add	r3, r2
 8100418:	00db      	lsls	r3, r3, #3
 810041a:	4a4d      	ldr	r2, [pc, #308]	@ (8100550 <SCH_RunSystemTickTimer+0x160>)
 810041c:	4413      	add	r3, r2
 810041e:	60bb      	str	r3, [r7, #8]
            if (pTaskContext->taskProperty.taskType == SCH_TASK_SYNC && 
 8100420:	68bb      	ldr	r3, [r7, #8]
 8100422:	7a1b      	ldrb	r3, [r3, #8]
 8100424:	2b01      	cmp	r3, #1
 8100426:	d126      	bne.n	8100476 <SCH_RunSystemTickTimer+0x86>
                pTaskContext->taskState == TASK_StateReady)
 8100428:	68bb      	ldr	r3, [r7, #8]
 810042a:	781b      	ldrb	r3, [r3, #0]
            if (pTaskContext->taskProperty.taskType == SCH_TASK_SYNC && 
 810042c:	2b01      	cmp	r3, #1
 810042e:	d122      	bne.n	8100476 <SCH_RunSystemTickTimer+0x86>
            {
                pTaskContext->currentTick += 1;
 8100430:	68bb      	ldr	r3, [r7, #8]
 8100432:	685b      	ldr	r3, [r3, #4]
 8100434:	1c5a      	adds	r2, r3, #1
 8100436:	68bb      	ldr	r3, [r7, #8]
 8100438:	605a      	str	r2, [r3, #4]
                if (pTaskContext->currentTick >= pTaskContext->taskProperty.taskPeriodInMS)
 810043a:	68bb      	ldr	r3, [r7, #8]
 810043c:	685a      	ldr	r2, [r3, #4]
 810043e:	68bb      	ldr	r3, [r7, #8]
 8100440:	68db      	ldr	r3, [r3, #12]
 8100442:	429a      	cmp	r2, r3
 8100444:	d317      	bcc.n	8100476 <SCH_RunSystemTickTimer+0x86>
                {
                    pTaskContext->currentTick = 0;
 8100446:	68bb      	ldr	r3, [r7, #8]
 8100448:	2200      	movs	r2, #0
 810044a:	605a      	str	r2, [r3, #4]
                    uint8_t index = taskIndex / 32;
 810044c:	7dfb      	ldrb	r3, [r7, #23]
 810044e:	095b      	lsrs	r3, r3, #5
 8100450:	71fb      	strb	r3, [r7, #7]
                    uint8_t bit = taskIndex % 32;
 8100452:	7dfb      	ldrb	r3, [r7, #23]
 8100454:	f003 031f 	and.w	r3, r3, #31
 8100458:	71bb      	strb	r3, [r7, #6]
                    s_TaskPending[index] |= (1 << bit);  // Set bit for task
 810045a:	79fb      	ldrb	r3, [r7, #7]
 810045c:	4a3d      	ldr	r2, [pc, #244]	@ (8100554 <SCH_RunSystemTickTimer+0x164>)
 810045e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8100462:	79bb      	ldrb	r3, [r7, #6]
 8100464:	2101      	movs	r1, #1
 8100466:	fa01 f303 	lsl.w	r3, r1, r3
 810046a:	4619      	mov	r1, r3
 810046c:	79fb      	ldrb	r3, [r7, #7]
 810046e:	430a      	orrs	r2, r1
 8100470:	4938      	ldr	r1, [pc, #224]	@ (8100554 <SCH_RunSystemTickTimer+0x164>)
 8100472:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        for (taskIndex = 0; taskIndex < s_NumOfTaskScheduled; taskIndex++)
 8100476:	7dfb      	ldrb	r3, [r7, #23]
 8100478:	3301      	adds	r3, #1
 810047a:	75fb      	strb	r3, [r7, #23]
 810047c:	4b36      	ldr	r3, [pc, #216]	@ (8100558 <SCH_RunSystemTickTimer+0x168>)
 810047e:	781b      	ldrb	r3, [r3, #0]
 8100480:	7dfa      	ldrb	r2, [r7, #23]
 8100482:	429a      	cmp	r2, r3
 8100484:	d3c4      	bcc.n	8100410 <SCH_RunSystemTickTimer+0x20>
                }
            }
        }

        // Timer
        for (timerIndex = 0; timerIndex < s_NumOfTimers; timerIndex++)
 8100486:	2300      	movs	r3, #0
 8100488:	75bb      	strb	r3, [r7, #22]
 810048a:	e03b      	b.n	8100504 <SCH_RunSystemTickTimer+0x114>
        {
            pTimerContext = &s_TimerContext[timerIndex];
 810048c:	7dba      	ldrb	r2, [r7, #22]
 810048e:	4613      	mov	r3, r2
 8100490:	009b      	lsls	r3, r3, #2
 8100492:	4413      	add	r3, r2
 8100494:	009b      	lsls	r3, r3, #2
 8100496:	4a31      	ldr	r2, [pc, #196]	@ (810055c <SCH_RunSystemTickTimer+0x16c>)
 8100498:	4413      	add	r3, r2
 810049a:	613b      	str	r3, [r7, #16]
            if (TIM_StateRun == pTimerContext->timerState)
 810049c:	693b      	ldr	r3, [r7, #16]
 810049e:	781b      	ldrb	r3, [r3, #0]
 81004a0:	2b01      	cmp	r3, #1
 81004a2:	d12c      	bne.n	81004fe <SCH_RunSystemTickTimer+0x10e>
            {
                pTimerContext->currentTick += 1;
 81004a4:	693b      	ldr	r3, [r7, #16]
 81004a6:	685b      	ldr	r3, [r3, #4]
 81004a8:	1c5a      	adds	r2, r3, #1
 81004aa:	693b      	ldr	r3, [r7, #16]
 81004ac:	605a      	str	r2, [r3, #4]
                if (pTimerContext->currentTick >= pTimerContext->timerProperty.timerPeriodInMS)
 81004ae:	693b      	ldr	r3, [r7, #16]
 81004b0:	685a      	ldr	r2, [r3, #4]
 81004b2:	693b      	ldr	r3, [r7, #16]
 81004b4:	68db      	ldr	r3, [r3, #12]
 81004b6:	429a      	cmp	r2, r3
 81004b8:	d321      	bcc.n	81004fe <SCH_RunSystemTickTimer+0x10e>
                {
                    uint8_t index = timerIndex / 32;
 81004ba:	7dbb      	ldrb	r3, [r7, #22]
 81004bc:	095b      	lsrs	r3, r3, #5
 81004be:	73fb      	strb	r3, [r7, #15]
                    uint8_t bit = timerIndex % 32;
 81004c0:	7dbb      	ldrb	r3, [r7, #22]
 81004c2:	f003 031f 	and.w	r3, r3, #31
 81004c6:	73bb      	strb	r3, [r7, #14]
                    s_TimerPending[index] |= (1 << bit);  // Set bit for timer
 81004c8:	7bfb      	ldrb	r3, [r7, #15]
 81004ca:	4a25      	ldr	r2, [pc, #148]	@ (8100560 <SCH_RunSystemTickTimer+0x170>)
 81004cc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 81004d0:	7bbb      	ldrb	r3, [r7, #14]
 81004d2:	2101      	movs	r1, #1
 81004d4:	fa01 f303 	lsl.w	r3, r1, r3
 81004d8:	4619      	mov	r1, r3
 81004da:	7bfb      	ldrb	r3, [r7, #15]
 81004dc:	430a      	orrs	r2, r1
 81004de:	4920      	ldr	r1, [pc, #128]	@ (8100560 <SCH_RunSystemTickTimer+0x170>)
 81004e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    pTimerContext->currentTick = 0;
 81004e4:	693b      	ldr	r3, [r7, #16]
 81004e6:	2200      	movs	r2, #0
 81004e8:	605a      	str	r2, [r3, #4]
                    pTimerContext->timerState = (SCH_TIMER_PERIODIC == pTimerContext->timerProperty.timerType) ? TIM_StateRun : TIM_StateStop;
 81004ea:	693b      	ldr	r3, [r7, #16]
 81004ec:	7a1b      	ldrb	r3, [r3, #8]
 81004ee:	2b02      	cmp	r3, #2
 81004f0:	bf0c      	ite	eq
 81004f2:	2301      	moveq	r3, #1
 81004f4:	2300      	movne	r3, #0
 81004f6:	b2db      	uxtb	r3, r3
 81004f8:	461a      	mov	r2, r3
 81004fa:	693b      	ldr	r3, [r7, #16]
 81004fc:	701a      	strb	r2, [r3, #0]
        for (timerIndex = 0; timerIndex < s_NumOfTimers; timerIndex++)
 81004fe:	7dbb      	ldrb	r3, [r7, #22]
 8100500:	3301      	adds	r3, #1
 8100502:	75bb      	strb	r3, [r7, #22]
 8100504:	4b17      	ldr	r3, [pc, #92]	@ (8100564 <SCH_RunSystemTickTimer+0x174>)
 8100506:	781b      	ldrb	r3, [r3, #0]
 8100508:	7dba      	ldrb	r2, [r7, #22]
 810050a:	429a      	cmp	r2, r3
 810050c:	d3be      	bcc.n	810048c <SCH_RunSystemTickTimer+0x9c>
                }
            }
        }

        // Soft timer
        for (timerIndex = 0; timerIndex < SCH_TIM_LAST; timerIndex++)
 810050e:	2300      	movs	r3, #0
 8100510:	75bb      	strb	r3, [r7, #22]
 8100512:	e010      	b.n	8100536 <SCH_RunSystemTickTimer+0x146>
        {
            if (s_SoftTimers[timerIndex] > 0)
 8100514:	7dbb      	ldrb	r3, [r7, #22]
 8100516:	4a14      	ldr	r2, [pc, #80]	@ (8100568 <SCH_RunSystemTickTimer+0x178>)
 8100518:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810051c:	2b00      	cmp	r3, #0
 810051e:	d007      	beq.n	8100530 <SCH_RunSystemTickTimer+0x140>
                s_SoftTimers[timerIndex]--;
 8100520:	7dbb      	ldrb	r3, [r7, #22]
 8100522:	4a11      	ldr	r2, [pc, #68]	@ (8100568 <SCH_RunSystemTickTimer+0x178>)
 8100524:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8100528:	3a01      	subs	r2, #1
 810052a:	490f      	ldr	r1, [pc, #60]	@ (8100568 <SCH_RunSystemTickTimer+0x178>)
 810052c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        for (timerIndex = 0; timerIndex < SCH_TIM_LAST; timerIndex++)
 8100530:	7dbb      	ldrb	r3, [r7, #22]
 8100532:	3301      	adds	r3, #1
 8100534:	75bb      	strb	r3, [r7, #22]
 8100536:	7dbb      	ldrb	r3, [r7, #22]
 8100538:	2b01      	cmp	r3, #1
 810053a:	d9eb      	bls.n	8100514 <SCH_RunSystemTickTimer+0x124>
        }
    }
}
 810053c:	bf00      	nop
 810053e:	371c      	adds	r7, #28
 8100540:	46bd      	mov	sp, r7
 8100542:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100546:	4770      	bx	lr
 8100548:	10032148 	.word	0x10032148
 810054c:	10032384 	.word	0x10032384
 8100550:	1003214c 	.word	0x1003214c
 8100554:	1003237c 	.word	0x1003237c
 8100558:	100322cc 	.word	0x100322cc
 810055c:	100322d0 	.word	0x100322d0
 8100560:	10032380 	.word	0x10032380
 8100564:	10032370 	.word	0x10032370
 8100568:	10032388 	.word	0x10032388

0810056c <SCH_StartScheduler>:
 * @brief  Start scheduler
 * @param  None
 * @retval None
 *****************************************************************************/
void SCH_StartScheduler(void)
{
 810056c:	b480      	push	{r7}
 810056e:	af00      	add	r7, sp, #0
    s_SchedulerRunning = TRUE;
 8100570:	4b03      	ldr	r3, [pc, #12]	@ (8100580 <SCH_StartScheduler+0x14>)
 8100572:	2201      	movs	r2, #1
 8100574:	701a      	strb	r2, [r3, #0]
}
 8100576:	bf00      	nop
 8100578:	46bd      	mov	sp, r7
 810057a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810057e:	4770      	bx	lr
 8100580:	10032148 	.word	0x10032148

08100584 <SCH_HandleScheduledTask>:
 * @brief  Function handles scheduled task and timer events
 * @param  None
 * @retval None
 *****************************************************************************/
void SCH_HandleScheduledTask(void)
{
 8100584:	b580      	push	{r7, lr}
 8100586:	b088      	sub	sp, #32
 8100588:	af00      	add	r7, sp, #0
    if (s_SchedulerRunning)
 810058a:	4b5b      	ldr	r3, [pc, #364]	@ (81006f8 <SCH_HandleScheduledTask+0x174>)
 810058c:	781b      	ldrb	r3, [r3, #0]
 810058e:	2b00      	cmp	r3, #0
 8100590:	f000 80ad 	beq.w	81006ee <SCH_HandleScheduledTask+0x16a>
    {
        // Task - Process by priority from highest (SCH_TASK_PRIO_3) to lowest (SCH_TASK_PRIO_0)
        for (int8_t priority = SCH_TASK_PRIO_3; priority >= SCH_TASK_PRIO_0; priority--)
 8100594:	2303      	movs	r3, #3
 8100596:	77fb      	strb	r3, [r7, #31]
 8100598:	e05c      	b.n	8100654 <SCH_HandleScheduledTask+0xd0>
        {
            for (uint8_t index = 0; index < NUM_TASK_PENDING_ARRAYS; index++)
 810059a:	2300      	movs	r3, #0
 810059c:	77bb      	strb	r3, [r7, #30]
 810059e:	e050      	b.n	8100642 <SCH_HandleScheduledTask+0xbe>
            {
                uint32_t pending = s_TaskPending[index];
 81005a0:	7fbb      	ldrb	r3, [r7, #30]
 81005a2:	4a56      	ldr	r2, [pc, #344]	@ (81006fc <SCH_HandleScheduledTask+0x178>)
 81005a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81005a8:	60bb      	str	r3, [r7, #8]
                for (uint8_t bit = 0; bit < 32; bit++)
 81005aa:	2300      	movs	r3, #0
 81005ac:	777b      	strb	r3, [r7, #29]
 81005ae:	e042      	b.n	8100636 <SCH_HandleScheduledTask+0xb2>
                {
                    if (pending & (1 << bit))
 81005b0:	7f7b      	ldrb	r3, [r7, #29]
 81005b2:	2201      	movs	r2, #1
 81005b4:	fa02 f303 	lsl.w	r3, r2, r3
 81005b8:	461a      	mov	r2, r3
 81005ba:	68bb      	ldr	r3, [r7, #8]
 81005bc:	4013      	ands	r3, r2
 81005be:	2b00      	cmp	r3, #0
 81005c0:	d036      	beq.n	8100630 <SCH_HandleScheduledTask+0xac>
                    {
                        uint8_t taskIndex = index * 32 + bit;
 81005c2:	7fbb      	ldrb	r3, [r7, #30]
 81005c4:	015b      	lsls	r3, r3, #5
 81005c6:	b2da      	uxtb	r2, r3
 81005c8:	7f7b      	ldrb	r3, [r7, #29]
 81005ca:	4413      	add	r3, r2
 81005cc:	71fb      	strb	r3, [r7, #7]
                        if (taskIndex < s_NumOfTaskScheduled)
 81005ce:	4b4c      	ldr	r3, [pc, #304]	@ (8100700 <SCH_HandleScheduledTask+0x17c>)
 81005d0:	781b      	ldrb	r3, [r3, #0]
 81005d2:	79fa      	ldrb	r2, [r7, #7]
 81005d4:	429a      	cmp	r2, r3
 81005d6:	d22b      	bcs.n	8100630 <SCH_HandleScheduledTask+0xac>
                        {
                            SCH_TaskContextTypedef *pTaskContext = &s_TaskContext[taskIndex];
 81005d8:	79fa      	ldrb	r2, [r7, #7]
 81005da:	4613      	mov	r3, r2
 81005dc:	005b      	lsls	r3, r3, #1
 81005de:	4413      	add	r3, r2
 81005e0:	00db      	lsls	r3, r3, #3
 81005e2:	4a48      	ldr	r2, [pc, #288]	@ (8100704 <SCH_HandleScheduledTask+0x180>)
 81005e4:	4413      	add	r3, r2
 81005e6:	603b      	str	r3, [r7, #0]
                            if (pTaskContext->taskProperty.taskPriority == priority &&
 81005e8:	683b      	ldr	r3, [r7, #0]
 81005ea:	7a5b      	ldrb	r3, [r3, #9]
 81005ec:	461a      	mov	r2, r3
 81005ee:	f997 301f 	ldrsb.w	r3, [r7, #31]
 81005f2:	429a      	cmp	r2, r3
 81005f4:	d11c      	bne.n	8100630 <SCH_HandleScheduledTask+0xac>
                                pTaskContext->taskState == TASK_StateReady)
 81005f6:	683b      	ldr	r3, [r7, #0]
 81005f8:	781b      	ldrb	r3, [r3, #0]
                            if (pTaskContext->taskProperty.taskPriority == priority &&
 81005fa:	2b01      	cmp	r3, #1
 81005fc:	d118      	bne.n	8100630 <SCH_HandleScheduledTask+0xac>
                            {
                                s_TaskPending[index] &= ~(1 << bit);  // Clear bit
 81005fe:	7fbb      	ldrb	r3, [r7, #30]
 8100600:	4a3e      	ldr	r2, [pc, #248]	@ (81006fc <SCH_HandleScheduledTask+0x178>)
 8100602:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8100606:	7f7b      	ldrb	r3, [r7, #29]
 8100608:	2101      	movs	r1, #1
 810060a:	fa01 f303 	lsl.w	r3, r1, r3
 810060e:	43db      	mvns	r3, r3
 8100610:	4619      	mov	r1, r3
 8100612:	7fbb      	ldrb	r3, [r7, #30]
 8100614:	400a      	ands	r2, r1
 8100616:	4939      	ldr	r1, [pc, #228]	@ (81006fc <SCH_HandleScheduledTask+0x178>)
 8100618:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                                pTaskContext->taskProperty.taskFunction();
 810061c:	683b      	ldr	r3, [r7, #0]
 810061e:	691b      	ldr	r3, [r3, #16]
 8100620:	4798      	blx	r3
                                // Async tasks, set state to Hold after execution
                                if (pTaskContext->taskProperty.taskType == SCH_TASK_ASYNC)
 8100622:	683b      	ldr	r3, [r7, #0]
 8100624:	7a1b      	ldrb	r3, [r3, #8]
 8100626:	2b02      	cmp	r3, #2
 8100628:	d102      	bne.n	8100630 <SCH_HandleScheduledTask+0xac>
                                {
                                    pTaskContext->taskState = TASK_StateHold;
 810062a:	683b      	ldr	r3, [r7, #0]
 810062c:	2200      	movs	r2, #0
 810062e:	701a      	strb	r2, [r3, #0]
                for (uint8_t bit = 0; bit < 32; bit++)
 8100630:	7f7b      	ldrb	r3, [r7, #29]
 8100632:	3301      	adds	r3, #1
 8100634:	777b      	strb	r3, [r7, #29]
 8100636:	7f7b      	ldrb	r3, [r7, #29]
 8100638:	2b1f      	cmp	r3, #31
 810063a:	d9b9      	bls.n	81005b0 <SCH_HandleScheduledTask+0x2c>
            for (uint8_t index = 0; index < NUM_TASK_PENDING_ARRAYS; index++)
 810063c:	7fbb      	ldrb	r3, [r7, #30]
 810063e:	3301      	adds	r3, #1
 8100640:	77bb      	strb	r3, [r7, #30]
 8100642:	7fbb      	ldrb	r3, [r7, #30]
 8100644:	2b00      	cmp	r3, #0
 8100646:	d0ab      	beq.n	81005a0 <SCH_HandleScheduledTask+0x1c>
        for (int8_t priority = SCH_TASK_PRIO_3; priority >= SCH_TASK_PRIO_0; priority--)
 8100648:	f997 301f 	ldrsb.w	r3, [r7, #31]
 810064c:	b2db      	uxtb	r3, r3
 810064e:	3b01      	subs	r3, #1
 8100650:	b2db      	uxtb	r3, r3
 8100652:	77fb      	strb	r3, [r7, #31]
 8100654:	f997 301f 	ldrsb.w	r3, [r7, #31]
 8100658:	2b00      	cmp	r3, #0
 810065a:	da9e      	bge.n	810059a <SCH_HandleScheduledTask+0x16>
                }
            }
        }

        // Timer
        for (uint8_t index = 0; index < NUM_TIMER_PENDING_ARRAYS; index++)
 810065c:	2300      	movs	r3, #0
 810065e:	773b      	strb	r3, [r7, #28]
 8100660:	e042      	b.n	81006e8 <SCH_HandleScheduledTask+0x164>
        {
            uint32_t pending = s_TimerPending[index];
 8100662:	7f3b      	ldrb	r3, [r7, #28]
 8100664:	4a28      	ldr	r2, [pc, #160]	@ (8100708 <SCH_HandleScheduledTask+0x184>)
 8100666:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810066a:	617b      	str	r3, [r7, #20]
            for (uint8_t bit = 0; bit < 32; bit++)
 810066c:	2300      	movs	r3, #0
 810066e:	76fb      	strb	r3, [r7, #27]
 8100670:	e034      	b.n	81006dc <SCH_HandleScheduledTask+0x158>
            {
                if (pending & (1 << bit))
 8100672:	7efb      	ldrb	r3, [r7, #27]
 8100674:	2201      	movs	r2, #1
 8100676:	fa02 f303 	lsl.w	r3, r2, r3
 810067a:	461a      	mov	r2, r3
 810067c:	697b      	ldr	r3, [r7, #20]
 810067e:	4013      	ands	r3, r2
 8100680:	2b00      	cmp	r3, #0
 8100682:	d028      	beq.n	81006d6 <SCH_HandleScheduledTask+0x152>
                {
                    uint8_t timerIndex = index * 32 + bit;
 8100684:	7f3b      	ldrb	r3, [r7, #28]
 8100686:	015b      	lsls	r3, r3, #5
 8100688:	b2da      	uxtb	r2, r3
 810068a:	7efb      	ldrb	r3, [r7, #27]
 810068c:	4413      	add	r3, r2
 810068e:	74fb      	strb	r3, [r7, #19]
                    if (timerIndex < s_NumOfTimers)
 8100690:	4b1e      	ldr	r3, [pc, #120]	@ (810070c <SCH_HandleScheduledTask+0x188>)
 8100692:	781b      	ldrb	r3, [r3, #0]
 8100694:	7cfa      	ldrb	r2, [r7, #19]
 8100696:	429a      	cmp	r2, r3
 8100698:	d21d      	bcs.n	81006d6 <SCH_HandleScheduledTask+0x152>
                    {
                        s_TimerPending[index] &= ~(1 << bit);  // Clear bit
 810069a:	7f3b      	ldrb	r3, [r7, #28]
 810069c:	4a1a      	ldr	r2, [pc, #104]	@ (8100708 <SCH_HandleScheduledTask+0x184>)
 810069e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 81006a2:	7efb      	ldrb	r3, [r7, #27]
 81006a4:	2101      	movs	r1, #1
 81006a6:	fa01 f303 	lsl.w	r3, r1, r3
 81006aa:	43db      	mvns	r3, r3
 81006ac:	4619      	mov	r1, r3
 81006ae:	7f3b      	ldrb	r3, [r7, #28]
 81006b0:	400a      	ands	r2, r1
 81006b2:	4915      	ldr	r1, [pc, #84]	@ (8100708 <SCH_HandleScheduledTask+0x184>)
 81006b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                        SCH_TimerContextTypedef *pTimerContext = &s_TimerContext[timerIndex];
 81006b8:	7cfa      	ldrb	r2, [r7, #19]
 81006ba:	4613      	mov	r3, r2
 81006bc:	009b      	lsls	r3, r3, #2
 81006be:	4413      	add	r3, r2
 81006c0:	009b      	lsls	r3, r3, #2
 81006c2:	4a13      	ldr	r2, [pc, #76]	@ (8100710 <SCH_HandleScheduledTask+0x18c>)
 81006c4:	4413      	add	r3, r2
 81006c6:	60fb      	str	r3, [r7, #12]
                        if (pTimerContext->timerProperty.timerCallbackFunction)
 81006c8:	68fb      	ldr	r3, [r7, #12]
 81006ca:	691b      	ldr	r3, [r3, #16]
 81006cc:	2b00      	cmp	r3, #0
 81006ce:	d002      	beq.n	81006d6 <SCH_HandleScheduledTask+0x152>
                        {
                            pTimerContext->timerProperty.timerCallbackFunction();
 81006d0:	68fb      	ldr	r3, [r7, #12]
 81006d2:	691b      	ldr	r3, [r3, #16]
 81006d4:	4798      	blx	r3
            for (uint8_t bit = 0; bit < 32; bit++)
 81006d6:	7efb      	ldrb	r3, [r7, #27]
 81006d8:	3301      	adds	r3, #1
 81006da:	76fb      	strb	r3, [r7, #27]
 81006dc:	7efb      	ldrb	r3, [r7, #27]
 81006de:	2b1f      	cmp	r3, #31
 81006e0:	d9c7      	bls.n	8100672 <SCH_HandleScheduledTask+0xee>
        for (uint8_t index = 0; index < NUM_TIMER_PENDING_ARRAYS; index++)
 81006e2:	7f3b      	ldrb	r3, [r7, #28]
 81006e4:	3301      	adds	r3, #1
 81006e6:	773b      	strb	r3, [r7, #28]
 81006e8:	7f3b      	ldrb	r3, [r7, #28]
 81006ea:	2b00      	cmp	r3, #0
 81006ec:	d0b9      	beq.n	8100662 <SCH_HandleScheduledTask+0xde>
                    }
                }
            }
        }
    }
}
 81006ee:	bf00      	nop
 81006f0:	3720      	adds	r7, #32
 81006f2:	46bd      	mov	sp, r7
 81006f4:	bd80      	pop	{r7, pc}
 81006f6:	bf00      	nop
 81006f8:	10032148 	.word	0x10032148
 81006fc:	1003237c 	.word	0x1003237c
 8100700:	100322cc 	.word	0x100322cc
 8100704:	1003214c 	.word	0x1003214c
 8100708:	10032380 	.word	0x10032380
 810070c:	10032370 	.word	0x10032370
 8100710:	100322d0 	.word	0x100322d0

08100714 <LL_GPIO_SetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 8100714:	b480      	push	{r7}
 8100716:	b083      	sub	sp, #12
 8100718:	af00      	add	r7, sp, #0
 810071a:	6078      	str	r0, [r7, #4]
 810071c:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, PinMask);
 810071e:	687b      	ldr	r3, [r7, #4]
 8100720:	683a      	ldr	r2, [r7, #0]
 8100722:	619a      	str	r2, [r3, #24]
}
 8100724:	bf00      	nop
 8100726:	370c      	adds	r7, #12
 8100728:	46bd      	mov	sp, r7
 810072a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810072e:	4770      	bx	lr

08100730 <LL_GPIO_ResetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 8100730:	b480      	push	{r7}
 8100732:	b083      	sub	sp, #12
 8100734:	af00      	add	r7, sp, #0
 8100736:	6078      	str	r0, [r7, #4]
 8100738:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, PinMask << 16U);
 810073a:	683b      	ldr	r3, [r7, #0]
 810073c:	041a      	lsls	r2, r3, #16
 810073e:	687b      	ldr	r3, [r7, #4]
 8100740:	619a      	str	r2, [r3, #24]
}
 8100742:	bf00      	nop
 8100744:	370c      	adds	r7, #12
 8100746:	46bd      	mov	sp, r7
 8100748:	f85d 7b04 	ldr.w	r7, [sp], #4
 810074c:	4770      	bx	lr
	...

08100750 <BlinkLed1_Task>:

/*************************************************
 *                    Task List                  *
 *************************************************/
static void BlinkLed1_Task(void)
{
 8100750:	b580      	push	{r7, lr}
 8100752:	af00      	add	r7, sp, #0
    static uint8_t ledState = 0;
    if (ledState == 0)
 8100754:	4b0b      	ldr	r3, [pc, #44]	@ (8100784 <BlinkLed1_Task+0x34>)
 8100756:	781b      	ldrb	r3, [r3, #0]
 8100758:	2b00      	cmp	r3, #0
 810075a:	d108      	bne.n	810076e <BlinkLed1_Task+0x1e>
    {
        ledState = 1;
 810075c:	4b09      	ldr	r3, [pc, #36]	@ (8100784 <BlinkLed1_Task+0x34>)
 810075e:	2201      	movs	r2, #1
 8100760:	701a      	strb	r2, [r3, #0]
        LL_GPIO_SetOutputPin(MCU_IO_DEBUG_LED2_GPIO_Port, MCU_IO_DEBUG_LED2_Pin);
 8100762:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 8100766:	4808      	ldr	r0, [pc, #32]	@ (8100788 <BlinkLed1_Task+0x38>)
 8100768:	f7ff ffd4 	bl	8100714 <LL_GPIO_SetOutputPin>
    else
    {
        LL_GPIO_ResetOutputPin(MCU_IO_DEBUG_LED2_GPIO_Port, MCU_IO_DEBUG_LED2_Pin);
        ledState = 0;
    }
}
 810076c:	e007      	b.n	810077e <BlinkLed1_Task+0x2e>
        LL_GPIO_ResetOutputPin(MCU_IO_DEBUG_LED2_GPIO_Port, MCU_IO_DEBUG_LED2_Pin);
 810076e:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 8100772:	4805      	ldr	r0, [pc, #20]	@ (8100788 <BlinkLed1_Task+0x38>)
 8100774:	f7ff ffdc 	bl	8100730 <LL_GPIO_ResetOutputPin>
        ledState = 0;
 8100778:	4b02      	ldr	r3, [pc, #8]	@ (8100784 <BlinkLed1_Task+0x34>)
 810077a:	2200      	movs	r2, #0
 810077c:	701a      	strb	r2, [r3, #0]
}
 810077e:	bf00      	nop
 8100780:	bd80      	pop	{r7, pc}
 8100782:	bf00      	nop
 8100784:	10032391 	.word	0x10032391
 8100788:	58020c00 	.word	0x58020c00

0810078c <BlinkLed2_Task>:

static void BlinkLed2_Task(void)
{
 810078c:	b580      	push	{r7, lr}
 810078e:	af00      	add	r7, sp, #0
    static uint8_t ledState = 0;
    if (ledState == 0)
 8100790:	4b0b      	ldr	r3, [pc, #44]	@ (81007c0 <BlinkLed2_Task+0x34>)
 8100792:	781b      	ldrb	r3, [r3, #0]
 8100794:	2b00      	cmp	r3, #0
 8100796:	d108      	bne.n	81007aa <BlinkLed2_Task+0x1e>
    {
        ledState = 1;
 8100798:	4b09      	ldr	r3, [pc, #36]	@ (81007c0 <BlinkLed2_Task+0x34>)
 810079a:	2201      	movs	r2, #1
 810079c:	701a      	strb	r2, [r3, #0]
        LL_GPIO_ResetOutputPin(MCU_IO_DEBUG_LED3_GPIO_Port, MCU_IO_DEBUG_LED3_Pin);
 810079e:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 81007a2:	4808      	ldr	r0, [pc, #32]	@ (81007c4 <BlinkLed2_Task+0x38>)
 81007a4:	f7ff ffc4 	bl	8100730 <LL_GPIO_ResetOutputPin>
    else
    {
        LL_GPIO_SetOutputPin(MCU_IO_DEBUG_LED3_GPIO_Port, MCU_IO_DEBUG_LED3_Pin);
        ledState = 0;
    }
}
 81007a8:	e007      	b.n	81007ba <BlinkLed2_Task+0x2e>
        LL_GPIO_SetOutputPin(MCU_IO_DEBUG_LED3_GPIO_Port, MCU_IO_DEBUG_LED3_Pin);
 81007aa:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 81007ae:	4805      	ldr	r0, [pc, #20]	@ (81007c4 <BlinkLed2_Task+0x38>)
 81007b0:	f7ff ffb0 	bl	8100714 <LL_GPIO_SetOutputPin>
        ledState = 0;
 81007b4:	4b02      	ldr	r3, [pc, #8]	@ (81007c0 <BlinkLed2_Task+0x34>)
 81007b6:	2200      	movs	r2, #0
 81007b8:	701a      	strb	r2, [r3, #0]
}
 81007ba:	bf00      	nop
 81007bc:	bd80      	pop	{r7, pc}
 81007be:	bf00      	nop
 81007c0:	10032392 	.word	0x10032392
 81007c4:	58020c00 	.word	0x58020c00

081007c8 <SchedulerTasks_Create>:
 *************************************************/

#define NUM_SCHEDULER_TASKS (sizeof(schedulerTasks) / sizeof(schedulerTasks[0]))

void SchedulerTasks_Create(void)
{
 81007c8:	b580      	push	{r7, lr}
 81007ca:	b082      	sub	sp, #8
 81007cc:	af00      	add	r7, sp, #0
    for (uint8_t i = 0; i < NUM_SCHEDULER_TASKS; i++)
 81007ce:	2300      	movs	r3, #0
 81007d0:	71fb      	strb	r3, [r7, #7]
 81007d2:	e029      	b.n	8100828 <SchedulerTasks_Create+0x60>
    {
        SCH_TASK_CreateTask(&schedulerTasks[i].taskHandle, &schedulerTasks[i].taskProperty);
 81007d4:	79fa      	ldrb	r2, [r7, #7]
 81007d6:	4613      	mov	r3, r2
 81007d8:	009b      	lsls	r3, r3, #2
 81007da:	4413      	add	r3, r2
 81007dc:	009b      	lsls	r3, r3, #2
 81007de:	4a16      	ldr	r2, [pc, #88]	@ (8100838 <SchedulerTasks_Create+0x70>)
 81007e0:	1898      	adds	r0, r3, r2
 81007e2:	79fa      	ldrb	r2, [r7, #7]
 81007e4:	4613      	mov	r3, r2
 81007e6:	009b      	lsls	r3, r3, #2
 81007e8:	4413      	add	r3, r2
 81007ea:	009b      	lsls	r3, r3, #2
 81007ec:	4a12      	ldr	r2, [pc, #72]	@ (8100838 <SchedulerTasks_Create+0x70>)
 81007ee:	4413      	add	r3, r2
 81007f0:	3304      	adds	r3, #4
 81007f2:	4619      	mov	r1, r3
 81007f4:	f7ff fdb8 	bl	8100368 <SCH_TASK_CreateTask>
        if (schedulerTasks[i].taskProperty.taskType == SCH_TASK_ASYNC)
 81007f8:	79fa      	ldrb	r2, [r7, #7]
 81007fa:	490f      	ldr	r1, [pc, #60]	@ (8100838 <SchedulerTasks_Create+0x70>)
 81007fc:	4613      	mov	r3, r2
 81007fe:	009b      	lsls	r3, r3, #2
 8100800:	4413      	add	r3, r2
 8100802:	009b      	lsls	r3, r3, #2
 8100804:	440b      	add	r3, r1
 8100806:	3304      	adds	r3, #4
 8100808:	781b      	ldrb	r3, [r3, #0]
 810080a:	2b02      	cmp	r3, #2
 810080c:	d109      	bne.n	8100822 <SchedulerTasks_Create+0x5a>
        {
            asyncTaskHandle = schedulerTasks[i].taskHandle;
 810080e:	79fa      	ldrb	r2, [r7, #7]
 8100810:	4909      	ldr	r1, [pc, #36]	@ (8100838 <SchedulerTasks_Create+0x70>)
 8100812:	4613      	mov	r3, r2
 8100814:	009b      	lsls	r3, r3, #2
 8100816:	4413      	add	r3, r2
 8100818:	009b      	lsls	r3, r3, #2
 810081a:	440b      	add	r3, r1
 810081c:	781a      	ldrb	r2, [r3, #0]
 810081e:	4b07      	ldr	r3, [pc, #28]	@ (810083c <SchedulerTasks_Create+0x74>)
 8100820:	701a      	strb	r2, [r3, #0]
    for (uint8_t i = 0; i < NUM_SCHEDULER_TASKS; i++)
 8100822:	79fb      	ldrb	r3, [r7, #7]
 8100824:	3301      	adds	r3, #1
 8100826:	71fb      	strb	r3, [r7, #7]
 8100828:	79fb      	ldrb	r3, [r7, #7]
 810082a:	2b01      	cmp	r3, #1
 810082c:	d9d2      	bls.n	81007d4 <SchedulerTasks_Create+0xc>
        }
    }
}
 810082e:	bf00      	nop
 8100830:	bf00      	nop
 8100832:	3708      	adds	r7, #8
 8100834:	46bd      	mov	sp, r7
 8100836:	bd80      	pop	{r7, pc}
 8100838:	10032000 	.word	0x10032000
 810083c:	10032390 	.word	0x10032390

08100840 <LL_TIM_ClearFlag_UPDATE>:
  * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
{
 8100840:	b480      	push	{r7}
 8100842:	b083      	sub	sp, #12
 8100844:	af00      	add	r7, sp, #0
 8100846:	6078      	str	r0, [r7, #4]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8100848:	687b      	ldr	r3, [r7, #4]
 810084a:	f06f 0201 	mvn.w	r2, #1
 810084e:	611a      	str	r2, [r3, #16]
}
 8100850:	bf00      	nop
 8100852:	370c      	adds	r7, #12
 8100854:	46bd      	mov	sp, r7
 8100856:	f85d 7b04 	ldr.w	r7, [sp], #4
 810085a:	4770      	bx	lr

0810085c <LL_TIM_IsActiveFlag_UPDATE>:
  * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(const TIM_TypeDef *TIMx)
{
 810085c:	b480      	push	{r7}
 810085e:	b083      	sub	sp, #12
 8100860:	af00      	add	r7, sp, #0
 8100862:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8100864:	687b      	ldr	r3, [r7, #4]
 8100866:	691b      	ldr	r3, [r3, #16]
 8100868:	f003 0301 	and.w	r3, r3, #1
 810086c:	2b01      	cmp	r3, #1
 810086e:	d101      	bne.n	8100874 <LL_TIM_IsActiveFlag_UPDATE+0x18>
 8100870:	2301      	movs	r3, #1
 8100872:	e000      	b.n	8100876 <LL_TIM_IsActiveFlag_UPDATE+0x1a>
 8100874:	2300      	movs	r3, #0
}
 8100876:	4618      	mov	r0, r3
 8100878:	370c      	adds	r7, #12
 810087a:	46bd      	mov	sp, r7
 810087c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100880:	4770      	bx	lr
	...

08100884 <TickTimer_IRQHandler>:
#include "stm32h7xx.h"
#include "stm32h7xx_ll_tim.h"

volatile uint32_t LL_Tick = 0;

void TickTimer_IRQHandler(void) {
 8100884:	b580      	push	{r7, lr}
 8100886:	af00      	add	r7, sp, #0
    if (LL_TIM_IsActiveFlag_UPDATE(TIM2)) {
 8100888:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 810088c:	f7ff ffe6 	bl	810085c <LL_TIM_IsActiveFlag_UPDATE>
 8100890:	4603      	mov	r3, r0
 8100892:	2b00      	cmp	r3, #0
 8100894:	d008      	beq.n	81008a8 <TickTimer_IRQHandler+0x24>
        LL_TIM_ClearFlag_UPDATE(TIM2);
 8100896:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 810089a:	f7ff ffd1 	bl	8100840 <LL_TIM_ClearFlag_UPDATE>
        LL_Tick++;
 810089e:	4b03      	ldr	r3, [pc, #12]	@ (81008ac <TickTimer_IRQHandler+0x28>)
 81008a0:	681b      	ldr	r3, [r3, #0]
 81008a2:	3301      	adds	r3, #1
 81008a4:	4a01      	ldr	r2, [pc, #4]	@ (81008ac <TickTimer_IRQHandler+0x28>)
 81008a6:	6013      	str	r3, [r2, #0]
    }
}
 81008a8:	bf00      	nop
 81008aa:	bd80      	pop	{r7, pc}
 81008ac:	10032394 	.word	0x10032394

081008b0 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 81008b0:	b480      	push	{r7}
 81008b2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 81008b4:	4b09      	ldr	r3, [pc, #36]	@ (81008dc <SystemInit+0x2c>)
 81008b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 81008ba:	4a08      	ldr	r2, [pc, #32]	@ (81008dc <SystemInit+0x2c>)
 81008bc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 81008c0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 81008c4:	4b05      	ldr	r3, [pc, #20]	@ (81008dc <SystemInit+0x2c>)
 81008c6:	691b      	ldr	r3, [r3, #16]
 81008c8:	4a04      	ldr	r2, [pc, #16]	@ (81008dc <SystemInit+0x2c>)
 81008ca:	f043 0310 	orr.w	r3, r3, #16
 81008ce:	6113      	str	r3, [r2, #16]
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 81008d0:	bf00      	nop
 81008d2:	46bd      	mov	sp, r7
 81008d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81008d8:	4770      	bx	lr
 81008da:	bf00      	nop
 81008dc:	e000ed00 	.word	0xe000ed00

081008e0 <ExitRun0Mode>:
  *
  * @param  None
  * @retval None
  */
void ExitRun0Mode(void)
{
 81008e0:	b480      	push	{r7}
 81008e2:	af00      	add	r7, sp, #0
#if defined(USE_PWR_LDO_SUPPLY)
  #if defined(SMPS)
    /* Exit Run* mode by disabling SMPS and enabling LDO */
    PWR->CR3 = (PWR->CR3 & ~PWR_CR3_SMPSEN) | PWR_CR3_LDOEN;
 81008e4:	4b0a      	ldr	r3, [pc, #40]	@ (8100910 <ExitRun0Mode+0x30>)
 81008e6:	68db      	ldr	r3, [r3, #12]
 81008e8:	f023 0306 	bic.w	r3, r3, #6
 81008ec:	4a08      	ldr	r2, [pc, #32]	@ (8100910 <ExitRun0Mode+0x30>)
 81008ee:	f043 0302 	orr.w	r3, r3, #2
 81008f2:	60d3      	str	r3, [r2, #12]
  #else
    /* Enable LDO mode */
    PWR->CR3 |= PWR_CR3_LDOEN;
  #endif /* SMPS */
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
 81008f4:	bf00      	nop
 81008f6:	4b06      	ldr	r3, [pc, #24]	@ (8100910 <ExitRun0Mode+0x30>)
 81008f8:	685b      	ldr	r3, [r3, #4]
 81008fa:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 81008fe:	2b00      	cmp	r3, #0
 8100900:	d0f9      	beq.n	81008f6 <ExitRun0Mode+0x16>
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#else
  /* No system power supply configuration is selected at exit Run* mode */
#endif /* USE_PWR_LDO_SUPPLY */
}
 8100902:	bf00      	nop
 8100904:	bf00      	nop
 8100906:	46bd      	mov	sp, r7
 8100908:	f85d 7b04 	ldr.w	r7, [sp], #4
 810090c:	4770      	bx	lr
 810090e:	bf00      	nop
 8100910:	58024800 	.word	0x58024800

08100914 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8100914:	b480      	push	{r7}
 8100916:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8100918:	4b04      	ldr	r3, [pc, #16]	@ (810092c <__NVIC_GetPriorityGrouping+0x18>)
 810091a:	68db      	ldr	r3, [r3, #12]
 810091c:	0a1b      	lsrs	r3, r3, #8
 810091e:	f003 0307 	and.w	r3, r3, #7
}
 8100922:	4618      	mov	r0, r3
 8100924:	46bd      	mov	sp, r7
 8100926:	f85d 7b04 	ldr.w	r7, [sp], #4
 810092a:	4770      	bx	lr
 810092c:	e000ed00 	.word	0xe000ed00

08100930 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8100930:	b480      	push	{r7}
 8100932:	b083      	sub	sp, #12
 8100934:	af00      	add	r7, sp, #0
 8100936:	4603      	mov	r3, r0
 8100938:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 810093a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810093e:	2b00      	cmp	r3, #0
 8100940:	db0b      	blt.n	810095a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8100942:	88fb      	ldrh	r3, [r7, #6]
 8100944:	f003 021f 	and.w	r2, r3, #31
 8100948:	4907      	ldr	r1, [pc, #28]	@ (8100968 <__NVIC_EnableIRQ+0x38>)
 810094a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810094e:	095b      	lsrs	r3, r3, #5
 8100950:	2001      	movs	r0, #1
 8100952:	fa00 f202 	lsl.w	r2, r0, r2
 8100956:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 810095a:	bf00      	nop
 810095c:	370c      	adds	r7, #12
 810095e:	46bd      	mov	sp, r7
 8100960:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100964:	4770      	bx	lr
 8100966:	bf00      	nop
 8100968:	e000e100 	.word	0xe000e100

0810096c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 810096c:	b480      	push	{r7}
 810096e:	b083      	sub	sp, #12
 8100970:	af00      	add	r7, sp, #0
 8100972:	4603      	mov	r3, r0
 8100974:	6039      	str	r1, [r7, #0]
 8100976:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8100978:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810097c:	2b00      	cmp	r3, #0
 810097e:	db0a      	blt.n	8100996 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8100980:	683b      	ldr	r3, [r7, #0]
 8100982:	b2da      	uxtb	r2, r3
 8100984:	490c      	ldr	r1, [pc, #48]	@ (81009b8 <__NVIC_SetPriority+0x4c>)
 8100986:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810098a:	0112      	lsls	r2, r2, #4
 810098c:	b2d2      	uxtb	r2, r2
 810098e:	440b      	add	r3, r1
 8100990:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8100994:	e00a      	b.n	81009ac <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8100996:	683b      	ldr	r3, [r7, #0]
 8100998:	b2da      	uxtb	r2, r3
 810099a:	4908      	ldr	r1, [pc, #32]	@ (81009bc <__NVIC_SetPriority+0x50>)
 810099c:	88fb      	ldrh	r3, [r7, #6]
 810099e:	f003 030f 	and.w	r3, r3, #15
 81009a2:	3b04      	subs	r3, #4
 81009a4:	0112      	lsls	r2, r2, #4
 81009a6:	b2d2      	uxtb	r2, r2
 81009a8:	440b      	add	r3, r1
 81009aa:	761a      	strb	r2, [r3, #24]
}
 81009ac:	bf00      	nop
 81009ae:	370c      	adds	r7, #12
 81009b0:	46bd      	mov	sp, r7
 81009b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81009b6:	4770      	bx	lr
 81009b8:	e000e100 	.word	0xe000e100
 81009bc:	e000ed00 	.word	0xe000ed00

081009c0 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 81009c0:	b480      	push	{r7}
 81009c2:	b089      	sub	sp, #36	@ 0x24
 81009c4:	af00      	add	r7, sp, #0
 81009c6:	60f8      	str	r0, [r7, #12]
 81009c8:	60b9      	str	r1, [r7, #8]
 81009ca:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 81009cc:	68fb      	ldr	r3, [r7, #12]
 81009ce:	f003 0307 	and.w	r3, r3, #7
 81009d2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 81009d4:	69fb      	ldr	r3, [r7, #28]
 81009d6:	f1c3 0307 	rsb	r3, r3, #7
 81009da:	2b04      	cmp	r3, #4
 81009dc:	bf28      	it	cs
 81009de:	2304      	movcs	r3, #4
 81009e0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 81009e2:	69fb      	ldr	r3, [r7, #28]
 81009e4:	3304      	adds	r3, #4
 81009e6:	2b06      	cmp	r3, #6
 81009e8:	d902      	bls.n	81009f0 <NVIC_EncodePriority+0x30>
 81009ea:	69fb      	ldr	r3, [r7, #28]
 81009ec:	3b03      	subs	r3, #3
 81009ee:	e000      	b.n	81009f2 <NVIC_EncodePriority+0x32>
 81009f0:	2300      	movs	r3, #0
 81009f2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 81009f4:	f04f 32ff 	mov.w	r2, #4294967295
 81009f8:	69bb      	ldr	r3, [r7, #24]
 81009fa:	fa02 f303 	lsl.w	r3, r2, r3
 81009fe:	43da      	mvns	r2, r3
 8100a00:	68bb      	ldr	r3, [r7, #8]
 8100a02:	401a      	ands	r2, r3
 8100a04:	697b      	ldr	r3, [r7, #20]
 8100a06:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8100a08:	f04f 31ff 	mov.w	r1, #4294967295
 8100a0c:	697b      	ldr	r3, [r7, #20]
 8100a0e:	fa01 f303 	lsl.w	r3, r1, r3
 8100a12:	43d9      	mvns	r1, r3
 8100a14:	687b      	ldr	r3, [r7, #4]
 8100a16:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8100a18:	4313      	orrs	r3, r2
         );
}
 8100a1a:	4618      	mov	r0, r3
 8100a1c:	3724      	adds	r7, #36	@ 0x24
 8100a1e:	46bd      	mov	sp, r7
 8100a20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a24:	4770      	bx	lr

08100a26 <LL_TIM_EnableCounter>:
{
 8100a26:	b480      	push	{r7}
 8100a28:	b083      	sub	sp, #12
 8100a2a:	af00      	add	r7, sp, #0
 8100a2c:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8100a2e:	687b      	ldr	r3, [r7, #4]
 8100a30:	681b      	ldr	r3, [r3, #0]
 8100a32:	f043 0201 	orr.w	r2, r3, #1
 8100a36:	687b      	ldr	r3, [r7, #4]
 8100a38:	601a      	str	r2, [r3, #0]
}
 8100a3a:	bf00      	nop
 8100a3c:	370c      	adds	r7, #12
 8100a3e:	46bd      	mov	sp, r7
 8100a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a44:	4770      	bx	lr

08100a46 <LL_TIM_EnableUpdateEvent>:
{
 8100a46:	b480      	push	{r7}
 8100a48:	b083      	sub	sp, #12
 8100a4a:	af00      	add	r7, sp, #0
 8100a4c:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_UDIS);
 8100a4e:	687b      	ldr	r3, [r7, #4]
 8100a50:	681b      	ldr	r3, [r3, #0]
 8100a52:	f023 0202 	bic.w	r2, r3, #2
 8100a56:	687b      	ldr	r3, [r7, #4]
 8100a58:	601a      	str	r2, [r3, #0]
}
 8100a5a:	bf00      	nop
 8100a5c:	370c      	adds	r7, #12
 8100a5e:	46bd      	mov	sp, r7
 8100a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a64:	4770      	bx	lr

08100a66 <LL_TIM_EnableARRPreload>:
{
 8100a66:	b480      	push	{r7}
 8100a68:	b083      	sub	sp, #12
 8100a6a:	af00      	add	r7, sp, #0
 8100a6c:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
 8100a6e:	687b      	ldr	r3, [r7, #4]
 8100a70:	681b      	ldr	r3, [r3, #0]
 8100a72:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8100a76:	687b      	ldr	r3, [r7, #4]
 8100a78:	601a      	str	r2, [r3, #0]
}
 8100a7a:	bf00      	nop
 8100a7c:	370c      	adds	r7, #12
 8100a7e:	46bd      	mov	sp, r7
 8100a80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a84:	4770      	bx	lr

08100a86 <LL_TIM_SetClockSource>:
{
 8100a86:	b480      	push	{r7}
 8100a88:	b083      	sub	sp, #12
 8100a8a:	af00      	add	r7, sp, #0
 8100a8c:	6078      	str	r0, [r7, #4]
 8100a8e:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
 8100a90:	687b      	ldr	r3, [r7, #4]
 8100a92:	689b      	ldr	r3, [r3, #8]
 8100a94:	f423 33a0 	bic.w	r3, r3, #81920	@ 0x14000
 8100a98:	f023 0307 	bic.w	r3, r3, #7
 8100a9c:	683a      	ldr	r2, [r7, #0]
 8100a9e:	431a      	orrs	r2, r3
 8100aa0:	687b      	ldr	r3, [r7, #4]
 8100aa2:	609a      	str	r2, [r3, #8]
}
 8100aa4:	bf00      	nop
 8100aa6:	370c      	adds	r7, #12
 8100aa8:	46bd      	mov	sp, r7
 8100aaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100aae:	4770      	bx	lr

08100ab0 <LL_TIM_SetTriggerOutput>:
{
 8100ab0:	b480      	push	{r7}
 8100ab2:	b083      	sub	sp, #12
 8100ab4:	af00      	add	r7, sp, #0
 8100ab6:	6078      	str	r0, [r7, #4]
 8100ab8:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8100aba:	687b      	ldr	r3, [r7, #4]
 8100abc:	685b      	ldr	r3, [r3, #4]
 8100abe:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8100ac2:	683b      	ldr	r3, [r7, #0]
 8100ac4:	431a      	orrs	r2, r3
 8100ac6:	687b      	ldr	r3, [r7, #4]
 8100ac8:	605a      	str	r2, [r3, #4]
}
 8100aca:	bf00      	nop
 8100acc:	370c      	adds	r7, #12
 8100ace:	46bd      	mov	sp, r7
 8100ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100ad4:	4770      	bx	lr

08100ad6 <LL_TIM_DisableMasterSlaveMode>:
{
 8100ad6:	b480      	push	{r7}
 8100ad8:	b083      	sub	sp, #12
 8100ada:	af00      	add	r7, sp, #0
 8100adc:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
 8100ade:	687b      	ldr	r3, [r7, #4]
 8100ae0:	689b      	ldr	r3, [r3, #8]
 8100ae2:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8100ae6:	687b      	ldr	r3, [r7, #4]
 8100ae8:	609a      	str	r2, [r3, #8]
}
 8100aea:	bf00      	nop
 8100aec:	370c      	adds	r7, #12
 8100aee:	46bd      	mov	sp, r7
 8100af0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100af4:	4770      	bx	lr

08100af6 <LL_TIM_EnableIT_UPDATE>:
  * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
{
 8100af6:	b480      	push	{r7}
 8100af8:	b083      	sub	sp, #12
 8100afa:	af00      	add	r7, sp, #0
 8100afc:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8100afe:	687b      	ldr	r3, [r7, #4]
 8100b00:	68db      	ldr	r3, [r3, #12]
 8100b02:	f043 0201 	orr.w	r2, r3, #1
 8100b06:	687b      	ldr	r3, [r7, #4]
 8100b08:	60da      	str	r2, [r3, #12]
}
 8100b0a:	bf00      	nop
 8100b0c:	370c      	adds	r7, #12
 8100b0e:	46bd      	mov	sp, r7
 8100b10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100b14:	4770      	bx	lr

08100b16 <LL_USART_Enable>:
  * @rmtoll CR1          UE            LL_USART_Enable
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_Enable(USART_TypeDef *USARTx)
{
 8100b16:	b480      	push	{r7}
 8100b18:	b083      	sub	sp, #12
 8100b1a:	af00      	add	r7, sp, #0
 8100b1c:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8100b1e:	687b      	ldr	r3, [r7, #4]
 8100b20:	681b      	ldr	r3, [r3, #0]
 8100b22:	f043 0201 	orr.w	r2, r3, #1
 8100b26:	687b      	ldr	r3, [r7, #4]
 8100b28:	601a      	str	r2, [r3, #0]
}
 8100b2a:	bf00      	nop
 8100b2c:	370c      	adds	r7, #12
 8100b2e:	46bd      	mov	sp, r7
 8100b30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100b34:	4770      	bx	lr

08100b36 <LL_USART_DisableFIFO>:
  * @rmtoll CR1          FIFOEN        LL_USART_DisableFIFO
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableFIFO(USART_TypeDef *USARTx)
{
 8100b36:	b480      	push	{r7}
 8100b38:	b083      	sub	sp, #12
 8100b3a:	af00      	add	r7, sp, #0
 8100b3c:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8100b3e:	687b      	ldr	r3, [r7, #4]
 8100b40:	681b      	ldr	r3, [r3, #0]
 8100b42:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
 8100b46:	687b      	ldr	r3, [r7, #4]
 8100b48:	601a      	str	r2, [r3, #0]
}
 8100b4a:	bf00      	nop
 8100b4c:	370c      	adds	r7, #12
 8100b4e:	46bd      	mov	sp, r7
 8100b50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100b54:	4770      	bx	lr

08100b56 <LL_USART_SetTXFIFOThreshold>:
  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetTXFIFOThreshold(USART_TypeDef *USARTx, uint32_t Threshold)
{
 8100b56:	b480      	push	{r7}
 8100b58:	b089      	sub	sp, #36	@ 0x24
 8100b5a:	af00      	add	r7, sp, #0
 8100b5c:	6078      	str	r0, [r7, #4]
 8100b5e:	6039      	str	r1, [r7, #0]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_TXFTCFG, Threshold << USART_CR3_TXFTCFG_Pos);
 8100b60:	687b      	ldr	r3, [r7, #4]
 8100b62:	3308      	adds	r3, #8
 8100b64:	60fb      	str	r3, [r7, #12]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8100b66:	68fb      	ldr	r3, [r7, #12]
 8100b68:	e853 3f00 	ldrex	r3, [r3]
 8100b6c:	60bb      	str	r3, [r7, #8]
   return(result);
 8100b6e:	68bb      	ldr	r3, [r7, #8]
 8100b70:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
 8100b74:	683b      	ldr	r3, [r7, #0]
 8100b76:	075b      	lsls	r3, r3, #29
 8100b78:	4313      	orrs	r3, r2
 8100b7a:	61fb      	str	r3, [r7, #28]
 8100b7c:	687b      	ldr	r3, [r7, #4]
 8100b7e:	3308      	adds	r3, #8
 8100b80:	69fa      	ldr	r2, [r7, #28]
 8100b82:	61ba      	str	r2, [r7, #24]
 8100b84:	617b      	str	r3, [r7, #20]
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8100b86:	6979      	ldr	r1, [r7, #20]
 8100b88:	69ba      	ldr	r2, [r7, #24]
 8100b8a:	e841 2300 	strex	r3, r2, [r1]
 8100b8e:	613b      	str	r3, [r7, #16]
   return(result);
 8100b90:	693b      	ldr	r3, [r7, #16]
 8100b92:	2b00      	cmp	r3, #0
 8100b94:	d1e4      	bne.n	8100b60 <LL_USART_SetTXFIFOThreshold+0xa>
}
 8100b96:	bf00      	nop
 8100b98:	bf00      	nop
 8100b9a:	3724      	adds	r7, #36	@ 0x24
 8100b9c:	46bd      	mov	sp, r7
 8100b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100ba2:	4770      	bx	lr

08100ba4 <LL_USART_SetRXFIFOThreshold>:
  *         @arg @ref LL_USART_FIFOTHRESHOLD_7_8
  *         @arg @ref LL_USART_FIFOTHRESHOLD_8_8
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetRXFIFOThreshold(USART_TypeDef *USARTx, uint32_t Threshold)
{
 8100ba4:	b480      	push	{r7}
 8100ba6:	b089      	sub	sp, #36	@ 0x24
 8100ba8:	af00      	add	r7, sp, #0
 8100baa:	6078      	str	r0, [r7, #4]
 8100bac:	6039      	str	r1, [r7, #0]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_RXFTCFG, Threshold << USART_CR3_RXFTCFG_Pos);
 8100bae:	687b      	ldr	r3, [r7, #4]
 8100bb0:	3308      	adds	r3, #8
 8100bb2:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8100bb4:	68fb      	ldr	r3, [r7, #12]
 8100bb6:	e853 3f00 	ldrex	r3, [r3]
 8100bba:	60bb      	str	r3, [r7, #8]
   return(result);
 8100bbc:	68bb      	ldr	r3, [r7, #8]
 8100bbe:	f023 6260 	bic.w	r2, r3, #234881024	@ 0xe000000
 8100bc2:	683b      	ldr	r3, [r7, #0]
 8100bc4:	065b      	lsls	r3, r3, #25
 8100bc6:	4313      	orrs	r3, r2
 8100bc8:	61fb      	str	r3, [r7, #28]
 8100bca:	687b      	ldr	r3, [r7, #4]
 8100bcc:	3308      	adds	r3, #8
 8100bce:	69fa      	ldr	r2, [r7, #28]
 8100bd0:	61ba      	str	r2, [r7, #24]
 8100bd2:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8100bd4:	6979      	ldr	r1, [r7, #20]
 8100bd6:	69ba      	ldr	r2, [r7, #24]
 8100bd8:	e841 2300 	strex	r3, r2, [r1]
 8100bdc:	613b      	str	r3, [r7, #16]
   return(result);
 8100bde:	693b      	ldr	r3, [r7, #16]
 8100be0:	2b00      	cmp	r3, #0
 8100be2:	d1e4      	bne.n	8100bae <LL_USART_SetRXFIFOThreshold+0xa>
}
 8100be4:	bf00      	nop
 8100be6:	bf00      	nop
 8100be8:	3724      	adds	r7, #36	@ 0x24
 8100bea:	46bd      	mov	sp, r7
 8100bec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100bf0:	4770      	bx	lr

08100bf2 <LL_USART_ConfigAsyncMode>:
  *         CR3          HDSEL         LL_USART_ConfigAsyncMode
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
{
 8100bf2:	b480      	push	{r7}
 8100bf4:	b083      	sub	sp, #12
 8100bf6:	af00      	add	r7, sp, #0
 8100bf8:	6078      	str	r0, [r7, #4]
  /* In Asynchronous mode, the following bits must be kept cleared:
  - LINEN, CLKEN bits in the USART_CR2 register,
  - SCEN, IREN and HDSEL bits in the USART_CR3 register.
  */
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8100bfa:	687b      	ldr	r3, [r7, #4]
 8100bfc:	685b      	ldr	r3, [r3, #4]
 8100bfe:	f423 4290 	bic.w	r2, r3, #18432	@ 0x4800
 8100c02:	687b      	ldr	r3, [r7, #4]
 8100c04:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 8100c06:	687b      	ldr	r3, [r7, #4]
 8100c08:	689b      	ldr	r3, [r3, #8]
 8100c0a:	f023 022a 	bic.w	r2, r3, #42	@ 0x2a
 8100c0e:	687b      	ldr	r3, [r7, #4]
 8100c10:	609a      	str	r2, [r3, #8]
}
 8100c12:	bf00      	nop
 8100c14:	370c      	adds	r7, #12
 8100c16:	46bd      	mov	sp, r7
 8100c18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100c1c:	4770      	bx	lr

08100c1e <LL_USART_IsActiveFlag_TEACK>:
  * @rmtoll ISR          TEACK         LL_USART_IsActiveFlag_TEACK
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TEACK(const USART_TypeDef *USARTx)
{
 8100c1e:	b480      	push	{r7}
 8100c20:	b083      	sub	sp, #12
 8100c22:	af00      	add	r7, sp, #0
 8100c24:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8100c26:	687b      	ldr	r3, [r7, #4]
 8100c28:	69db      	ldr	r3, [r3, #28]
 8100c2a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8100c2e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8100c32:	d101      	bne.n	8100c38 <LL_USART_IsActiveFlag_TEACK+0x1a>
 8100c34:	2301      	movs	r3, #1
 8100c36:	e000      	b.n	8100c3a <LL_USART_IsActiveFlag_TEACK+0x1c>
 8100c38:	2300      	movs	r3, #0
}
 8100c3a:	4618      	mov	r0, r3
 8100c3c:	370c      	adds	r7, #12
 8100c3e:	46bd      	mov	sp, r7
 8100c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100c44:	4770      	bx	lr

08100c46 <LL_USART_IsActiveFlag_REACK>:
  * @rmtoll ISR          REACK         LL_USART_IsActiveFlag_REACK
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_REACK(const USART_TypeDef *USARTx)
{
 8100c46:	b480      	push	{r7}
 8100c48:	b083      	sub	sp, #12
 8100c4a:	af00      	add	r7, sp, #0
 8100c4c:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK)) ? 1UL : 0UL);
 8100c4e:	687b      	ldr	r3, [r7, #4]
 8100c50:	69db      	ldr	r3, [r3, #28]
 8100c52:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8100c56:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8100c5a:	d101      	bne.n	8100c60 <LL_USART_IsActiveFlag_REACK+0x1a>
 8100c5c:	2301      	movs	r3, #1
 8100c5e:	e000      	b.n	8100c62 <LL_USART_IsActiveFlag_REACK+0x1c>
 8100c60:	2300      	movs	r3, #0
}
 8100c62:	4618      	mov	r0, r3
 8100c64:	370c      	adds	r7, #12
 8100c66:	46bd      	mov	sp, r7
 8100c68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100c6c:	4770      	bx	lr

08100c6e <LL_GPIO_ResetOutputPin>:
{
 8100c6e:	b480      	push	{r7}
 8100c70:	b083      	sub	sp, #12
 8100c72:	af00      	add	r7, sp, #0
 8100c74:	6078      	str	r0, [r7, #4]
 8100c76:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, PinMask << 16U);
 8100c78:	683b      	ldr	r3, [r7, #0]
 8100c7a:	041a      	lsls	r2, r3, #16
 8100c7c:	687b      	ldr	r3, [r7, #4]
 8100c7e:	619a      	str	r2, [r3, #24]
}
 8100c80:	bf00      	nop
 8100c82:	370c      	adds	r7, #12
 8100c84:	46bd      	mov	sp, r7
 8100c86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100c8a:	4770      	bx	lr

08100c8c <LL_AHB4_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
 8100c8c:	b480      	push	{r7}
 8100c8e:	b085      	sub	sp, #20
 8100c90:	af00      	add	r7, sp, #0
 8100c92:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB4ENR, Periphs);
 8100c94:	4b0a      	ldr	r3, [pc, #40]	@ (8100cc0 <LL_AHB4_GRP1_EnableClock+0x34>)
 8100c96:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8100c9a:	4909      	ldr	r1, [pc, #36]	@ (8100cc0 <LL_AHB4_GRP1_EnableClock+0x34>)
 8100c9c:	687b      	ldr	r3, [r7, #4]
 8100c9e:	4313      	orrs	r3, r2
 8100ca0:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8100ca4:	4b06      	ldr	r3, [pc, #24]	@ (8100cc0 <LL_AHB4_GRP1_EnableClock+0x34>)
 8100ca6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8100caa:	687b      	ldr	r3, [r7, #4]
 8100cac:	4013      	ands	r3, r2
 8100cae:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8100cb0:	68fb      	ldr	r3, [r7, #12]
}
 8100cb2:	bf00      	nop
 8100cb4:	3714      	adds	r7, #20
 8100cb6:	46bd      	mov	sp, r7
 8100cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cbc:	4770      	bx	lr
 8100cbe:	bf00      	nop
 8100cc0:	58024400 	.word	0x58024400

08100cc4 <LL_APB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 8100cc4:	b480      	push	{r7}
 8100cc6:	b085      	sub	sp, #20
 8100cc8:	af00      	add	r7, sp, #0
 8100cca:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1LENR, Periphs);
 8100ccc:	4b0a      	ldr	r3, [pc, #40]	@ (8100cf8 <LL_APB1_GRP1_EnableClock+0x34>)
 8100cce:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8100cd2:	4909      	ldr	r1, [pc, #36]	@ (8100cf8 <LL_APB1_GRP1_EnableClock+0x34>)
 8100cd4:	687b      	ldr	r3, [r7, #4]
 8100cd6:	4313      	orrs	r3, r2
 8100cd8:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1LENR, Periphs);
 8100cdc:	4b06      	ldr	r3, [pc, #24]	@ (8100cf8 <LL_APB1_GRP1_EnableClock+0x34>)
 8100cde:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8100ce2:	687b      	ldr	r3, [r7, #4]
 8100ce4:	4013      	ands	r3, r2
 8100ce6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8100ce8:	68fb      	ldr	r3, [r7, #12]
}
 8100cea:	bf00      	nop
 8100cec:	3714      	adds	r7, #20
 8100cee:	46bd      	mov	sp, r7
 8100cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cf4:	4770      	bx	lr
 8100cf6:	bf00      	nop
 8100cf8:	58024400 	.word	0x58024400

08100cfc <LL_APB2_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
 8100cfc:	b480      	push	{r7}
 8100cfe:	b085      	sub	sp, #20
 8100d00:	af00      	add	r7, sp, #0
 8100d02:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8100d04:	4b0a      	ldr	r3, [pc, #40]	@ (8100d30 <LL_APB2_GRP1_EnableClock+0x34>)
 8100d06:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8100d0a:	4909      	ldr	r1, [pc, #36]	@ (8100d30 <LL_APB2_GRP1_EnableClock+0x34>)
 8100d0c:	687b      	ldr	r3, [r7, #4]
 8100d0e:	4313      	orrs	r3, r2
 8100d10:	f8c1 30f0 	str.w	r3, [r1, #240]	@ 0xf0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8100d14:	4b06      	ldr	r3, [pc, #24]	@ (8100d30 <LL_APB2_GRP1_EnableClock+0x34>)
 8100d16:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8100d1a:	687b      	ldr	r3, [r7, #4]
 8100d1c:	4013      	ands	r3, r2
 8100d1e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8100d20:	68fb      	ldr	r3, [r7, #12]
}
 8100d22:	bf00      	nop
 8100d24:	3714      	adds	r7, #20
 8100d26:	46bd      	mov	sp, r7
 8100d28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d2c:	4770      	bx	lr
 8100d2e:	bf00      	nop
 8100d30:	58024400 	.word	0x58024400

08100d34 <LL_DMA_SetDataTransferDirection>:
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetDataTransferDirection(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t  Direction)
{
 8100d34:	b480      	push	{r7}
 8100d36:	b087      	sub	sp, #28
 8100d38:	af00      	add	r7, sp, #0
 8100d3a:	60f8      	str	r0, [r7, #12]
 8100d3c:	60b9      	str	r1, [r7, #8]
 8100d3e:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100d40:	68fb      	ldr	r3, [r7, #12]
 8100d42:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DIR, Direction);
 8100d44:	4a0d      	ldr	r2, [pc, #52]	@ (8100d7c <LL_DMA_SetDataTransferDirection+0x48>)
 8100d46:	68bb      	ldr	r3, [r7, #8]
 8100d48:	4413      	add	r3, r2
 8100d4a:	781b      	ldrb	r3, [r3, #0]
 8100d4c:	461a      	mov	r2, r3
 8100d4e:	697b      	ldr	r3, [r7, #20]
 8100d50:	4413      	add	r3, r2
 8100d52:	681b      	ldr	r3, [r3, #0]
 8100d54:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 8100d58:	4908      	ldr	r1, [pc, #32]	@ (8100d7c <LL_DMA_SetDataTransferDirection+0x48>)
 8100d5a:	68bb      	ldr	r3, [r7, #8]
 8100d5c:	440b      	add	r3, r1
 8100d5e:	781b      	ldrb	r3, [r3, #0]
 8100d60:	4619      	mov	r1, r3
 8100d62:	697b      	ldr	r3, [r7, #20]
 8100d64:	440b      	add	r3, r1
 8100d66:	4619      	mov	r1, r3
 8100d68:	687b      	ldr	r3, [r7, #4]
 8100d6a:	4313      	orrs	r3, r2
 8100d6c:	600b      	str	r3, [r1, #0]
}
 8100d6e:	bf00      	nop
 8100d70:	371c      	adds	r7, #28
 8100d72:	46bd      	mov	sp, r7
 8100d74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d78:	4770      	bx	lr
 8100d7a:	bf00      	nop
 8100d7c:	0810da0c 	.word	0x0810da0c

08100d80 <LL_DMA_SetMode>:
  *         @arg @ref LL_DMA_MODE_CIRCULAR
  *         @arg @ref LL_DMA_MODE_PFCTRL
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetMode(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t Mode)
{
 8100d80:	b480      	push	{r7}
 8100d82:	b087      	sub	sp, #28
 8100d84:	af00      	add	r7, sp, #0
 8100d86:	60f8      	str	r0, [r7, #12]
 8100d88:	60b9      	str	r1, [r7, #8]
 8100d8a:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100d8c:	68fb      	ldr	r3, [r7, #12]
 8100d8e:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_CIRC | DMA_SxCR_PFCTRL, Mode);
 8100d90:	4a0d      	ldr	r2, [pc, #52]	@ (8100dc8 <LL_DMA_SetMode+0x48>)
 8100d92:	68bb      	ldr	r3, [r7, #8]
 8100d94:	4413      	add	r3, r2
 8100d96:	781b      	ldrb	r3, [r3, #0]
 8100d98:	461a      	mov	r2, r3
 8100d9a:	697b      	ldr	r3, [r7, #20]
 8100d9c:	4413      	add	r3, r2
 8100d9e:	681b      	ldr	r3, [r3, #0]
 8100da0:	f423 7290 	bic.w	r2, r3, #288	@ 0x120
 8100da4:	4908      	ldr	r1, [pc, #32]	@ (8100dc8 <LL_DMA_SetMode+0x48>)
 8100da6:	68bb      	ldr	r3, [r7, #8]
 8100da8:	440b      	add	r3, r1
 8100daa:	781b      	ldrb	r3, [r3, #0]
 8100dac:	4619      	mov	r1, r3
 8100dae:	697b      	ldr	r3, [r7, #20]
 8100db0:	440b      	add	r3, r1
 8100db2:	4619      	mov	r1, r3
 8100db4:	687b      	ldr	r3, [r7, #4]
 8100db6:	4313      	orrs	r3, r2
 8100db8:	600b      	str	r3, [r1, #0]
}
 8100dba:	bf00      	nop
 8100dbc:	371c      	adds	r7, #28
 8100dbe:	46bd      	mov	sp, r7
 8100dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100dc4:	4770      	bx	lr
 8100dc6:	bf00      	nop
 8100dc8:	0810da0c 	.word	0x0810da0c

08100dcc <LL_DMA_SetPeriphIncMode>:
  *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
  *         @arg @ref LL_DMA_PERIPH_INCREMENT
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphIncMode(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t IncrementMode)
{
 8100dcc:	b480      	push	{r7}
 8100dce:	b087      	sub	sp, #28
 8100dd0:	af00      	add	r7, sp, #0
 8100dd2:	60f8      	str	r0, [r7, #12]
 8100dd4:	60b9      	str	r1, [r7, #8]
 8100dd6:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100dd8:	68fb      	ldr	r3, [r7, #12]
 8100dda:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PINC, IncrementMode);
 8100ddc:	4a0d      	ldr	r2, [pc, #52]	@ (8100e14 <LL_DMA_SetPeriphIncMode+0x48>)
 8100dde:	68bb      	ldr	r3, [r7, #8]
 8100de0:	4413      	add	r3, r2
 8100de2:	781b      	ldrb	r3, [r3, #0]
 8100de4:	461a      	mov	r2, r3
 8100de6:	697b      	ldr	r3, [r7, #20]
 8100de8:	4413      	add	r3, r2
 8100dea:	681b      	ldr	r3, [r3, #0]
 8100dec:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 8100df0:	4908      	ldr	r1, [pc, #32]	@ (8100e14 <LL_DMA_SetPeriphIncMode+0x48>)
 8100df2:	68bb      	ldr	r3, [r7, #8]
 8100df4:	440b      	add	r3, r1
 8100df6:	781b      	ldrb	r3, [r3, #0]
 8100df8:	4619      	mov	r1, r3
 8100dfa:	697b      	ldr	r3, [r7, #20]
 8100dfc:	440b      	add	r3, r1
 8100dfe:	4619      	mov	r1, r3
 8100e00:	687b      	ldr	r3, [r7, #4]
 8100e02:	4313      	orrs	r3, r2
 8100e04:	600b      	str	r3, [r1, #0]
}
 8100e06:	bf00      	nop
 8100e08:	371c      	adds	r7, #28
 8100e0a:	46bd      	mov	sp, r7
 8100e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e10:	4770      	bx	lr
 8100e12:	bf00      	nop
 8100e14:	0810da0c 	.word	0x0810da0c

08100e18 <LL_DMA_SetMemoryIncMode>:
  *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
  *         @arg @ref LL_DMA_MEMORY_INCREMENT
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetMemoryIncMode(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t IncrementMode)
{
 8100e18:	b480      	push	{r7}
 8100e1a:	b087      	sub	sp, #28
 8100e1c:	af00      	add	r7, sp, #0
 8100e1e:	60f8      	str	r0, [r7, #12]
 8100e20:	60b9      	str	r1, [r7, #8]
 8100e22:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100e24:	68fb      	ldr	r3, [r7, #12]
 8100e26:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MINC, IncrementMode);
 8100e28:	4a0d      	ldr	r2, [pc, #52]	@ (8100e60 <LL_DMA_SetMemoryIncMode+0x48>)
 8100e2a:	68bb      	ldr	r3, [r7, #8]
 8100e2c:	4413      	add	r3, r2
 8100e2e:	781b      	ldrb	r3, [r3, #0]
 8100e30:	461a      	mov	r2, r3
 8100e32:	697b      	ldr	r3, [r7, #20]
 8100e34:	4413      	add	r3, r2
 8100e36:	681b      	ldr	r3, [r3, #0]
 8100e38:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
 8100e3c:	4908      	ldr	r1, [pc, #32]	@ (8100e60 <LL_DMA_SetMemoryIncMode+0x48>)
 8100e3e:	68bb      	ldr	r3, [r7, #8]
 8100e40:	440b      	add	r3, r1
 8100e42:	781b      	ldrb	r3, [r3, #0]
 8100e44:	4619      	mov	r1, r3
 8100e46:	697b      	ldr	r3, [r7, #20]
 8100e48:	440b      	add	r3, r1
 8100e4a:	4619      	mov	r1, r3
 8100e4c:	687b      	ldr	r3, [r7, #4]
 8100e4e:	4313      	orrs	r3, r2
 8100e50:	600b      	str	r3, [r1, #0]
}
 8100e52:	bf00      	nop
 8100e54:	371c      	adds	r7, #28
 8100e56:	46bd      	mov	sp, r7
 8100e58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e5c:	4770      	bx	lr
 8100e5e:	bf00      	nop
 8100e60:	0810da0c 	.word	0x0810da0c

08100e64 <LL_DMA_SetPeriphSize>:
  *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
  *         @arg @ref LL_DMA_PDATAALIGN_WORD
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphSize(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t  Size)
{
 8100e64:	b480      	push	{r7}
 8100e66:	b087      	sub	sp, #28
 8100e68:	af00      	add	r7, sp, #0
 8100e6a:	60f8      	str	r0, [r7, #12]
 8100e6c:	60b9      	str	r1, [r7, #8]
 8100e6e:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100e70:	68fb      	ldr	r3, [r7, #12]
 8100e72:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PSIZE, Size);
 8100e74:	4a0d      	ldr	r2, [pc, #52]	@ (8100eac <LL_DMA_SetPeriphSize+0x48>)
 8100e76:	68bb      	ldr	r3, [r7, #8]
 8100e78:	4413      	add	r3, r2
 8100e7a:	781b      	ldrb	r3, [r3, #0]
 8100e7c:	461a      	mov	r2, r3
 8100e7e:	697b      	ldr	r3, [r7, #20]
 8100e80:	4413      	add	r3, r2
 8100e82:	681b      	ldr	r3, [r3, #0]
 8100e84:	f423 52c0 	bic.w	r2, r3, #6144	@ 0x1800
 8100e88:	4908      	ldr	r1, [pc, #32]	@ (8100eac <LL_DMA_SetPeriphSize+0x48>)
 8100e8a:	68bb      	ldr	r3, [r7, #8]
 8100e8c:	440b      	add	r3, r1
 8100e8e:	781b      	ldrb	r3, [r3, #0]
 8100e90:	4619      	mov	r1, r3
 8100e92:	697b      	ldr	r3, [r7, #20]
 8100e94:	440b      	add	r3, r1
 8100e96:	4619      	mov	r1, r3
 8100e98:	687b      	ldr	r3, [r7, #4]
 8100e9a:	4313      	orrs	r3, r2
 8100e9c:	600b      	str	r3, [r1, #0]
}
 8100e9e:	bf00      	nop
 8100ea0:	371c      	adds	r7, #28
 8100ea2:	46bd      	mov	sp, r7
 8100ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100ea8:	4770      	bx	lr
 8100eaa:	bf00      	nop
 8100eac:	0810da0c 	.word	0x0810da0c

08100eb0 <LL_DMA_SetMemorySize>:
  *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
  *         @arg @ref LL_DMA_MDATAALIGN_WORD
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetMemorySize(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t  Size)
{
 8100eb0:	b480      	push	{r7}
 8100eb2:	b087      	sub	sp, #28
 8100eb4:	af00      	add	r7, sp, #0
 8100eb6:	60f8      	str	r0, [r7, #12]
 8100eb8:	60b9      	str	r1, [r7, #8]
 8100eba:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100ebc:	68fb      	ldr	r3, [r7, #12]
 8100ebe:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MSIZE, Size);
 8100ec0:	4a0d      	ldr	r2, [pc, #52]	@ (8100ef8 <LL_DMA_SetMemorySize+0x48>)
 8100ec2:	68bb      	ldr	r3, [r7, #8]
 8100ec4:	4413      	add	r3, r2
 8100ec6:	781b      	ldrb	r3, [r3, #0]
 8100ec8:	461a      	mov	r2, r3
 8100eca:	697b      	ldr	r3, [r7, #20]
 8100ecc:	4413      	add	r3, r2
 8100ece:	681b      	ldr	r3, [r3, #0]
 8100ed0:	f423 42c0 	bic.w	r2, r3, #24576	@ 0x6000
 8100ed4:	4908      	ldr	r1, [pc, #32]	@ (8100ef8 <LL_DMA_SetMemorySize+0x48>)
 8100ed6:	68bb      	ldr	r3, [r7, #8]
 8100ed8:	440b      	add	r3, r1
 8100eda:	781b      	ldrb	r3, [r3, #0]
 8100edc:	4619      	mov	r1, r3
 8100ede:	697b      	ldr	r3, [r7, #20]
 8100ee0:	440b      	add	r3, r1
 8100ee2:	4619      	mov	r1, r3
 8100ee4:	687b      	ldr	r3, [r7, #4]
 8100ee6:	4313      	orrs	r3, r2
 8100ee8:	600b      	str	r3, [r1, #0]
}
 8100eea:	bf00      	nop
 8100eec:	371c      	adds	r7, #28
 8100eee:	46bd      	mov	sp, r7
 8100ef0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100ef4:	4770      	bx	lr
 8100ef6:	bf00      	nop
 8100ef8:	0810da0c 	.word	0x0810da0c

08100efc <LL_DMA_SetStreamPriorityLevel>:
  *         @arg @ref LL_DMA_PRIORITY_HIGH
  *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetStreamPriorityLevel(const DMA_TypeDef *DMAx, uint32_t Stream, uint32_t  Priority)
{
 8100efc:	b480      	push	{r7}
 8100efe:	b087      	sub	sp, #28
 8100f00:	af00      	add	r7, sp, #0
 8100f02:	60f8      	str	r0, [r7, #12]
 8100f04:	60b9      	str	r1, [r7, #8]
 8100f06:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100f08:	68fb      	ldr	r3, [r7, #12]
 8100f0a:	617b      	str	r3, [r7, #20]

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PL, Priority);
 8100f0c:	4a0d      	ldr	r2, [pc, #52]	@ (8100f44 <LL_DMA_SetStreamPriorityLevel+0x48>)
 8100f0e:	68bb      	ldr	r3, [r7, #8]
 8100f10:	4413      	add	r3, r2
 8100f12:	781b      	ldrb	r3, [r3, #0]
 8100f14:	461a      	mov	r2, r3
 8100f16:	697b      	ldr	r3, [r7, #20]
 8100f18:	4413      	add	r3, r2
 8100f1a:	681b      	ldr	r3, [r3, #0]
 8100f1c:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
 8100f20:	4908      	ldr	r1, [pc, #32]	@ (8100f44 <LL_DMA_SetStreamPriorityLevel+0x48>)
 8100f22:	68bb      	ldr	r3, [r7, #8]
 8100f24:	440b      	add	r3, r1
 8100f26:	781b      	ldrb	r3, [r3, #0]
 8100f28:	4619      	mov	r1, r3
 8100f2a:	697b      	ldr	r3, [r7, #20]
 8100f2c:	440b      	add	r3, r1
 8100f2e:	4619      	mov	r1, r3
 8100f30:	687b      	ldr	r3, [r7, #4]
 8100f32:	4313      	orrs	r3, r2
 8100f34:	600b      	str	r3, [r1, #0]
}
 8100f36:	bf00      	nop
 8100f38:	371c      	adds	r7, #28
 8100f3a:	46bd      	mov	sp, r7
 8100f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100f40:	4770      	bx	lr
 8100f42:	bf00      	nop
 8100f44:	0810da0c 	.word	0x0810da0c

08100f48 <LL_DMA_SetPeriphRequest>:
  *
  * @note   (*) Availability depends on devices.
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphRequest(DMA_TypeDef *DMAx, uint32_t Stream, uint32_t Request)
{
 8100f48:	b480      	push	{r7}
 8100f4a:	b085      	sub	sp, #20
 8100f4c:	af00      	add	r7, sp, #0
 8100f4e:	60f8      	str	r0, [r7, #12]
 8100f50:	60b9      	str	r1, [r7, #8]
 8100f52:	607a      	str	r2, [r7, #4]
  MODIFY_REG(((DMAMUX_Channel_TypeDef *)(uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE * (Stream)) + (uint32_t)(DMAMUX_CCR_SIZE * LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
 8100f54:	68bb      	ldr	r3, [r7, #8]
 8100f56:	f103 5380 	add.w	r3, r3, #268435456	@ 0x10000000
 8100f5a:	f503 4302 	add.w	r3, r3, #33280	@ 0x8200
 8100f5e:	009b      	lsls	r3, r3, #2
 8100f60:	68fa      	ldr	r2, [r7, #12]
 8100f62:	4911      	ldr	r1, [pc, #68]	@ (8100fa8 <LL_DMA_SetPeriphRequest+0x60>)
 8100f64:	428a      	cmp	r2, r1
 8100f66:	d101      	bne.n	8100f6c <LL_DMA_SetPeriphRequest+0x24>
 8100f68:	2200      	movs	r2, #0
 8100f6a:	e000      	b.n	8100f6e <LL_DMA_SetPeriphRequest+0x26>
 8100f6c:	2220      	movs	r2, #32
 8100f6e:	4413      	add	r3, r2
 8100f70:	681b      	ldr	r3, [r3, #0]
 8100f72:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 8100f76:	68bb      	ldr	r3, [r7, #8]
 8100f78:	f103 5380 	add.w	r3, r3, #268435456	@ 0x10000000
 8100f7c:	f503 4302 	add.w	r3, r3, #33280	@ 0x8200
 8100f80:	009b      	lsls	r3, r3, #2
 8100f82:	68f9      	ldr	r1, [r7, #12]
 8100f84:	4808      	ldr	r0, [pc, #32]	@ (8100fa8 <LL_DMA_SetPeriphRequest+0x60>)
 8100f86:	4281      	cmp	r1, r0
 8100f88:	d101      	bne.n	8100f8e <LL_DMA_SetPeriphRequest+0x46>
 8100f8a:	2100      	movs	r1, #0
 8100f8c:	e000      	b.n	8100f90 <LL_DMA_SetPeriphRequest+0x48>
 8100f8e:	2120      	movs	r1, #32
 8100f90:	440b      	add	r3, r1
 8100f92:	4619      	mov	r1, r3
 8100f94:	687b      	ldr	r3, [r7, #4]
 8100f96:	4313      	orrs	r3, r2
 8100f98:	600b      	str	r3, [r1, #0]
}
 8100f9a:	bf00      	nop
 8100f9c:	3714      	adds	r7, #20
 8100f9e:	46bd      	mov	sp, r7
 8100fa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100fa4:	4770      	bx	lr
 8100fa6:	bf00      	nop
 8100fa8:	40020000 	.word	0x40020000

08100fac <LL_DMA_DisableFifoMode>:
  *         @arg @ref LL_DMA_STREAM_6
  *         @arg @ref LL_DMA_STREAM_7
  * @retval None
  */
__STATIC_INLINE void LL_DMA_DisableFifoMode(const DMA_TypeDef *DMAx, uint32_t Stream)
{
 8100fac:	b480      	push	{r7}
 8100fae:	b085      	sub	sp, #20
 8100fb0:	af00      	add	r7, sp, #0
 8100fb2:	6078      	str	r0, [r7, #4]
 8100fb4:	6039      	str	r1, [r7, #0]
  uint32_t dma_base_addr = (uint32_t)DMAx;
 8100fb6:	687b      	ldr	r3, [r7, #4]
 8100fb8:	60fb      	str	r3, [r7, #12]

  CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_DMDIS);
 8100fba:	4a0c      	ldr	r2, [pc, #48]	@ (8100fec <LL_DMA_DisableFifoMode+0x40>)
 8100fbc:	683b      	ldr	r3, [r7, #0]
 8100fbe:	4413      	add	r3, r2
 8100fc0:	781b      	ldrb	r3, [r3, #0]
 8100fc2:	461a      	mov	r2, r3
 8100fc4:	68fb      	ldr	r3, [r7, #12]
 8100fc6:	4413      	add	r3, r2
 8100fc8:	695b      	ldr	r3, [r3, #20]
 8100fca:	4908      	ldr	r1, [pc, #32]	@ (8100fec <LL_DMA_DisableFifoMode+0x40>)
 8100fcc:	683a      	ldr	r2, [r7, #0]
 8100fce:	440a      	add	r2, r1
 8100fd0:	7812      	ldrb	r2, [r2, #0]
 8100fd2:	4611      	mov	r1, r2
 8100fd4:	68fa      	ldr	r2, [r7, #12]
 8100fd6:	440a      	add	r2, r1
 8100fd8:	f023 0304 	bic.w	r3, r3, #4
 8100fdc:	6153      	str	r3, [r2, #20]
}
 8100fde:	bf00      	nop
 8100fe0:	3714      	adds	r7, #20
 8100fe2:	46bd      	mov	sp, r7
 8100fe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100fe8:	4770      	bx	lr
 8100fea:	bf00      	nop
 8100fec:	0810da0c 	.word	0x0810da0c

08100ff0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8100ff0:	b580      	push	{r7, lr}
 8100ff2:	b082      	sub	sp, #8
 8100ff4:	af00      	add	r7, sp, #0

  /* USER CODE END 1 */

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /*HW semaphore Clock enable*/
  __HAL_RCC_HSEM_CLK_ENABLE();
 8100ff6:	4b25      	ldr	r3, [pc, #148]	@ (810108c <main+0x9c>)
 8100ff8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100ffc:	4a23      	ldr	r2, [pc, #140]	@ (810108c <main+0x9c>)
 8100ffe:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8101002:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8101006:	4b21      	ldr	r3, [pc, #132]	@ (810108c <main+0x9c>)
 8101008:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810100c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8101010:	607b      	str	r3, [r7, #4]
 8101012:	687b      	ldr	r3, [r7, #4]
  /* Activate HSEM notification for Cortex-M4*/
  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 8101014:	2001      	movs	r0, #1
 8101016:	f000 ff79 	bl	8101f0c <HAL_HSEM_ActivateNotification>
  /*
  Domain D2 goes to STOP mode (Cortex-M4 in deep-sleep) waiting for Cortex-M7 to
  perform system initialization (system clock config, external memory configuration.. )
  */
  HAL_PWREx_ClearPendingEvent();
 810101a:	f003 fc53 	bl	81048c4 <HAL_PWREx_ClearPendingEvent>
  HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
 810101e:	2201      	movs	r2, #1
 8101020:	2102      	movs	r1, #2
 8101022:	2000      	movs	r0, #0
 8101024:	f003 fbd4 	bl	81047d0 <HAL_PWREx_EnterSTOPMode>
  /* Clear HSEM flag */
  __HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 8101028:	4b19      	ldr	r3, [pc, #100]	@ (8101090 <main+0xa0>)
 810102a:	681b      	ldr	r3, [r3, #0]
 810102c:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8101030:	2b70      	cmp	r3, #112	@ 0x70
 8101032:	d108      	bne.n	8101046 <main+0x56>
 8101034:	4b17      	ldr	r3, [pc, #92]	@ (8101094 <main+0xa4>)
 8101036:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 810103a:	4a16      	ldr	r2, [pc, #88]	@ (8101094 <main+0xa4>)
 810103c:	f043 0301 	orr.w	r3, r3, #1
 8101040:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
 8101044:	e007      	b.n	8101056 <main+0x66>
 8101046:	4b13      	ldr	r3, [pc, #76]	@ (8101094 <main+0xa4>)
 8101048:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 810104c:	4a11      	ldr	r2, [pc, #68]	@ (8101094 <main+0xa4>)
 810104e:	f043 0301 	orr.w	r3, r3, #1
 8101052:	f8c2 3114 	str.w	r3, [r2, #276]	@ 0x114

/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8101056:	f000 fc15 	bl	8101884 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_MDMA_Init();
 810105a:	f000 f9b1 	bl	81013c0 <MX_MDMA_Init>
  MX_DMA_Init();
 810105e:	f000 f977 	bl	8101350 <MX_DMA_Init>
  MX_BDMA_Init();
 8101062:	f000 f95b 	bl	810131c <MX_BDMA_Init>
  MX_GPIO_Init();
 8101066:	f000 f9c5 	bl	81013f4 <MX_GPIO_Init>
  MX_SDMMC2_MMC_Init();
 810106a:	f000 f815 	bl	8101098 <MX_SDMMC2_MMC_Init>
  MX_USART6_UART_Init();
 810106e:	f000 f885 	bl	810117c <MX_USART6_UART_Init>
  MX_TIM2_Init();
 8101072:	f000 f835 	bl	81010e0 <MX_TIM2_Init>
  MX_USB_DEVICE_Init();
 8101076:	f00b ff2f 	bl	810ced8 <MX_USB_DEVICE_Init>

  /* USER CODE BEGIN 2 */

  SCH_Initialize();
 810107a:	f7ff f92d 	bl	81002d8 <SCH_Initialize>
  SchedulerTasks_Create();
 810107e:	f7ff fba3 	bl	81007c8 <SchedulerTasks_Create>
  SCH_StartScheduler();
 8101082:	f7ff fa73 	bl	810056c <SCH_StartScheduler>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	SCH_HandleScheduledTask();
 8101086:	f7ff fa7d 	bl	8100584 <SCH_HandleScheduledTask>
 810108a:	e7fc      	b.n	8101086 <main+0x96>
 810108c:	58024400 	.word	0x58024400
 8101090:	e000ed00 	.word	0xe000ed00
 8101094:	58026400 	.word	0x58026400

08101098 <MX_SDMMC2_MMC_Init>:
  * @brief SDMMC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SDMMC2_MMC_Init(void)
{
 8101098:	b580      	push	{r7, lr}
 810109a:	af00      	add	r7, sp, #0
  /* USER CODE END SDMMC2_Init 0 */

  /* USER CODE BEGIN SDMMC2_Init 1 */

  /* USER CODE END SDMMC2_Init 1 */
  hmmc2.Instance = SDMMC2;
 810109c:	4b0e      	ldr	r3, [pc, #56]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 810109e:	4a0f      	ldr	r2, [pc, #60]	@ (81010dc <MX_SDMMC2_MMC_Init+0x44>)
 81010a0:	601a      	str	r2, [r3, #0]
  hmmc2.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 81010a2:	4b0d      	ldr	r3, [pc, #52]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010a4:	2200      	movs	r2, #0
 81010a6:	605a      	str	r2, [r3, #4]
  hmmc2.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 81010a8:	4b0b      	ldr	r3, [pc, #44]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010aa:	2200      	movs	r2, #0
 81010ac:	609a      	str	r2, [r3, #8]
  hmmc2.Init.BusWide = SDMMC_BUS_WIDE_4B;
 81010ae:	4b0a      	ldr	r3, [pc, #40]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010b0:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 81010b4:	60da      	str	r2, [r3, #12]
  hmmc2.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 81010b6:	4b08      	ldr	r3, [pc, #32]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010b8:	2200      	movs	r2, #0
 81010ba:	611a      	str	r2, [r3, #16]
  hmmc2.Init.ClockDiv = 4;
 81010bc:	4b06      	ldr	r3, [pc, #24]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010be:	2204      	movs	r2, #4
 81010c0:	615a      	str	r2, [r3, #20]
  if (HAL_MMC_Init(&hmmc2) != HAL_OK)
 81010c2:	4805      	ldr	r0, [pc, #20]	@ (81010d8 <MX_SDMMC2_MMC_Init+0x40>)
 81010c4:	f000 ff34 	bl	8101f30 <HAL_MMC_Init>
 81010c8:	4603      	mov	r3, r0
 81010ca:	2b00      	cmp	r3, #0
 81010cc:	d001      	beq.n	81010d2 <MX_SDMMC2_MMC_Init+0x3a>
  {
    Error_Handler();
 81010ce:	f000 f9d9 	bl	8101484 <Error_Handler>
  }
  /* USER CODE BEGIN SDMMC2_Init 2 */

  /* USER CODE END SDMMC2_Init 2 */

}
 81010d2:	bf00      	nop
 81010d4:	bd80      	pop	{r7, pc}
 81010d6:	bf00      	nop
 81010d8:	10032398 	.word	0x10032398
 81010dc:	48022400 	.word	0x48022400

081010e0 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 81010e0:	b580      	push	{r7, lr}
 81010e2:	b086      	sub	sp, #24
 81010e4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  LL_TIM_InitTypeDef TIM_InitStruct = {0};
 81010e6:	1d3b      	adds	r3, r7, #4
 81010e8:	2200      	movs	r2, #0
 81010ea:	601a      	str	r2, [r3, #0]
 81010ec:	605a      	str	r2, [r3, #4]
 81010ee:	609a      	str	r2, [r3, #8]
 81010f0:	60da      	str	r2, [r3, #12]
 81010f2:	611a      	str	r2, [r3, #16]

  /* Peripheral clock enable */
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);
 81010f4:	2001      	movs	r0, #1
 81010f6:	f7ff fde5 	bl	8100cc4 <LL_APB1_GRP1_EnableClock>

  /* TIM2 interrupt Init */
  NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
 81010fa:	f7ff fc0b 	bl	8100914 <__NVIC_GetPriorityGrouping>
 81010fe:	4603      	mov	r3, r0
 8101100:	2200      	movs	r2, #0
 8101102:	2100      	movs	r1, #0
 8101104:	4618      	mov	r0, r3
 8101106:	f7ff fc5b 	bl	81009c0 <NVIC_EncodePriority>
 810110a:	4603      	mov	r3, r0
 810110c:	4619      	mov	r1, r3
 810110e:	201c      	movs	r0, #28
 8101110:	f7ff fc2c 	bl	810096c <__NVIC_SetPriority>
  NVIC_EnableIRQ(TIM2_IRQn);
 8101114:	201c      	movs	r0, #28
 8101116:	f7ff fc0b 	bl	8100930 <__NVIC_EnableIRQ>

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  TIM_InitStruct.Prescaler = 119;
 810111a:	2377      	movs	r3, #119	@ 0x77
 810111c:	80bb      	strh	r3, [r7, #4]
  TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
 810111e:	2300      	movs	r3, #0
 8101120:	60bb      	str	r3, [r7, #8]
  TIM_InitStruct.Autoreload = 999;
 8101122:	f240 33e7 	movw	r3, #999	@ 0x3e7
 8101126:	60fb      	str	r3, [r7, #12]
  TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
 8101128:	2300      	movs	r3, #0
 810112a:	613b      	str	r3, [r7, #16]
  LL_TIM_Init(TIM2, &TIM_InitStruct);
 810112c:	1d3b      	adds	r3, r7, #4
 810112e:	4619      	mov	r1, r3
 8101130:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101134:	f008 f9e8 	bl	8109508 <LL_TIM_Init>
  LL_TIM_EnableARRPreload(TIM2);
 8101138:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 810113c:	f7ff fc93 	bl	8100a66 <LL_TIM_EnableARRPreload>
  LL_TIM_SetClockSource(TIM2, LL_TIM_CLOCKSOURCE_INTERNAL);
 8101140:	2100      	movs	r1, #0
 8101142:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101146:	f7ff fc9e 	bl	8100a86 <LL_TIM_SetClockSource>
  LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
 810114a:	2120      	movs	r1, #32
 810114c:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101150:	f7ff fcae 	bl	8100ab0 <LL_TIM_SetTriggerOutput>
  LL_TIM_DisableMasterSlaveMode(TIM2);
 8101154:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101158:	f7ff fcbd 	bl	8100ad6 <LL_TIM_DisableMasterSlaveMode>
  /* USER CODE BEGIN TIM2_Init 2 */
  LL_TIM_EnableIT_UPDATE(TIM2);
 810115c:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101160:	f7ff fcc9 	bl	8100af6 <LL_TIM_EnableIT_UPDATE>
  LL_TIM_EnableUpdateEvent(TIM2);
 8101164:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101168:	f7ff fc6d 	bl	8100a46 <LL_TIM_EnableUpdateEvent>
  LL_TIM_EnableCounter(TIM2);
 810116c:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8101170:	f7ff fc59 	bl	8100a26 <LL_TIM_EnableCounter>
  /* USER CODE END TIM2_Init 2 */

}
 8101174:	bf00      	nop
 8101176:	3718      	adds	r7, #24
 8101178:	46bd      	mov	sp, r7
 810117a:	bd80      	pop	{r7, pc}

0810117c <MX_USART6_UART_Init>:
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{
 810117c:	b580      	push	{r7, lr}
 810117e:	b0be      	sub	sp, #248	@ 0xf8
 8101180:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  LL_USART_InitTypeDef USART_InitStruct = {0};
 8101182:	f107 03d8 	add.w	r3, r7, #216	@ 0xd8
 8101186:	2220      	movs	r2, #32
 8101188:	2100      	movs	r1, #0
 810118a:	4618      	mov	r0, r3
 810118c:	f00c fbce 	bl	810d92c <memset>

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8101190:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
 8101194:	2200      	movs	r2, #0
 8101196:	601a      	str	r2, [r3, #0]
 8101198:	605a      	str	r2, [r3, #4]
 810119a:	609a      	str	r2, [r3, #8]
 810119c:	60da      	str	r2, [r3, #12]
 810119e:	611a      	str	r2, [r3, #16]
 81011a0:	615a      	str	r2, [r3, #20]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 81011a2:	463b      	mov	r3, r7
 81011a4:	22c0      	movs	r2, #192	@ 0xc0
 81011a6:	2100      	movs	r1, #0
 81011a8:	4618      	mov	r0, r3
 81011aa:	f00c fbbf 	bl	810d92c <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART6;
 81011ae:	f04f 0201 	mov.w	r2, #1
 81011b2:	f04f 0300 	mov.w	r3, #0
 81011b6:	e9c7 2300 	strd	r2, r3, [r7]
  PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;
 81011ba:	2300      	movs	r3, #0
 81011bc:	67fb      	str	r3, [r7, #124]	@ 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 81011be:	463b      	mov	r3, r7
 81011c0:	4618      	mov	r0, r3
 81011c2:	f003 fda1 	bl	8104d08 <HAL_RCCEx_PeriphCLKConfig>
 81011c6:	4603      	mov	r3, r0
 81011c8:	2b00      	cmp	r3, #0
 81011ca:	d001      	beq.n	81011d0 <MX_USART6_UART_Init+0x54>
  {
    Error_Handler();
 81011cc:	f000 f95a 	bl	8101484 <Error_Handler>
  }

  /* Peripheral clock enable */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_USART6);
 81011d0:	2020      	movs	r0, #32
 81011d2:	f7ff fd93 	bl	8100cfc <LL_APB2_GRP1_EnableClock>

  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOG);
 81011d6:	2040      	movs	r0, #64	@ 0x40
 81011d8:	f7ff fd58 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>
  /**USART6 GPIO Configuration
  PG9   ------> USART6_RX
  PG14   ------> USART6_TX
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_9|LL_GPIO_PIN_14;
 81011dc:	f44f 4384 	mov.w	r3, #16896	@ 0x4200
 81011e0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 81011e4:	2302      	movs	r3, #2
 81011e6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 81011ea:	2300      	movs	r3, #0
 81011ec:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 81011f0:	2300      	movs	r3, #0
 81011f2:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 81011f6:	2300      	movs	r3, #0
 81011f8:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 81011fc:	2307      	movs	r3, #7
 81011fe:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  LL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8101202:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
 8101206:	4619      	mov	r1, r3
 8101208:	4841      	ldr	r0, [pc, #260]	@ (8101310 <MX_USART6_UART_Init+0x194>)
 810120a:	f006 fe1d 	bl	8107e48 <LL_GPIO_Init>

  /* USART6 DMA Init */

  /* USART6_RX Init */
  LL_DMA_SetPeriphRequest(DMA2, LL_DMA_STREAM_0, LL_DMAMUX1_REQ_USART6_RX);
 810120e:	2247      	movs	r2, #71	@ 0x47
 8101210:	2100      	movs	r1, #0
 8101212:	4840      	ldr	r0, [pc, #256]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 8101214:	f7ff fe98 	bl	8100f48 <LL_DMA_SetPeriphRequest>

  LL_DMA_SetDataTransferDirection(DMA2, LL_DMA_STREAM_0, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
 8101218:	2200      	movs	r2, #0
 810121a:	2100      	movs	r1, #0
 810121c:	483d      	ldr	r0, [pc, #244]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 810121e:	f7ff fd89 	bl	8100d34 <LL_DMA_SetDataTransferDirection>

  LL_DMA_SetStreamPriorityLevel(DMA2, LL_DMA_STREAM_0, LL_DMA_PRIORITY_LOW);
 8101222:	2200      	movs	r2, #0
 8101224:	2100      	movs	r1, #0
 8101226:	483b      	ldr	r0, [pc, #236]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 8101228:	f7ff fe68 	bl	8100efc <LL_DMA_SetStreamPriorityLevel>

  LL_DMA_SetMode(DMA2, LL_DMA_STREAM_0, LL_DMA_MODE_CIRCULAR);
 810122c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8101230:	2100      	movs	r1, #0
 8101232:	4838      	ldr	r0, [pc, #224]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 8101234:	f7ff fda4 	bl	8100d80 <LL_DMA_SetMode>

  LL_DMA_SetPeriphIncMode(DMA2, LL_DMA_STREAM_0, LL_DMA_PERIPH_NOINCREMENT);
 8101238:	2200      	movs	r2, #0
 810123a:	2100      	movs	r1, #0
 810123c:	4835      	ldr	r0, [pc, #212]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 810123e:	f7ff fdc5 	bl	8100dcc <LL_DMA_SetPeriphIncMode>

  LL_DMA_SetMemoryIncMode(DMA2, LL_DMA_STREAM_0, LL_DMA_MEMORY_INCREMENT);
 8101242:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8101246:	2100      	movs	r1, #0
 8101248:	4832      	ldr	r0, [pc, #200]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 810124a:	f7ff fde5 	bl	8100e18 <LL_DMA_SetMemoryIncMode>

  LL_DMA_SetPeriphSize(DMA2, LL_DMA_STREAM_0, LL_DMA_PDATAALIGN_BYTE);
 810124e:	2200      	movs	r2, #0
 8101250:	2100      	movs	r1, #0
 8101252:	4830      	ldr	r0, [pc, #192]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 8101254:	f7ff fe06 	bl	8100e64 <LL_DMA_SetPeriphSize>

  LL_DMA_SetMemorySize(DMA2, LL_DMA_STREAM_0, LL_DMA_MDATAALIGN_BYTE);
 8101258:	2200      	movs	r2, #0
 810125a:	2100      	movs	r1, #0
 810125c:	482d      	ldr	r0, [pc, #180]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 810125e:	f7ff fe27 	bl	8100eb0 <LL_DMA_SetMemorySize>

  LL_DMA_DisableFifoMode(DMA2, LL_DMA_STREAM_0);
 8101262:	2100      	movs	r1, #0
 8101264:	482b      	ldr	r0, [pc, #172]	@ (8101314 <MX_USART6_UART_Init+0x198>)
 8101266:	f7ff fea1 	bl	8100fac <LL_DMA_DisableFifoMode>

  /* USART6 interrupt Init */
  NVIC_SetPriority(USART6_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
 810126a:	f7ff fb53 	bl	8100914 <__NVIC_GetPriorityGrouping>
 810126e:	4603      	mov	r3, r0
 8101270:	2200      	movs	r2, #0
 8101272:	2100      	movs	r1, #0
 8101274:	4618      	mov	r0, r3
 8101276:	f7ff fba3 	bl	81009c0 <NVIC_EncodePriority>
 810127a:	4603      	mov	r3, r0
 810127c:	4619      	mov	r1, r3
 810127e:	2047      	movs	r0, #71	@ 0x47
 8101280:	f7ff fb74 	bl	810096c <__NVIC_SetPriority>
  NVIC_EnableIRQ(USART6_IRQn);
 8101284:	2047      	movs	r0, #71	@ 0x47
 8101286:	f7ff fb53 	bl	8100930 <__NVIC_EnableIRQ>

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  USART_InitStruct.PrescalerValue = LL_USART_PRESCALER_DIV1;
 810128a:	2300      	movs	r3, #0
 810128c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  USART_InitStruct.BaudRate = 115200;
 8101290:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 8101294:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8101298:	2300      	movs	r3, #0
 810129a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 810129e:	2300      	movs	r3, #0
 81012a0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 81012a4:	2300      	movs	r3, #0
 81012a6:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 81012aa:	230c      	movs	r3, #12
 81012ac:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 81012b0:	2300      	movs	r3, #0
 81012b2:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 81012b6:	2300      	movs	r3, #0
 81012b8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  LL_USART_Init(USART6, &USART_InitStruct);
 81012bc:	f107 03d8 	add.w	r3, r7, #216	@ 0xd8
 81012c0:	4619      	mov	r1, r3
 81012c2:	4815      	ldr	r0, [pc, #84]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012c4:	f008 fa52 	bl	810976c <LL_USART_Init>
  LL_USART_SetTXFIFOThreshold(USART6, LL_USART_FIFOTHRESHOLD_1_8);
 81012c8:	2100      	movs	r1, #0
 81012ca:	4813      	ldr	r0, [pc, #76]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012cc:	f7ff fc43 	bl	8100b56 <LL_USART_SetTXFIFOThreshold>
  LL_USART_SetRXFIFOThreshold(USART6, LL_USART_FIFOTHRESHOLD_1_8);
 81012d0:	2100      	movs	r1, #0
 81012d2:	4811      	ldr	r0, [pc, #68]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012d4:	f7ff fc66 	bl	8100ba4 <LL_USART_SetRXFIFOThreshold>
  LL_USART_DisableFIFO(USART6);
 81012d8:	480f      	ldr	r0, [pc, #60]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012da:	f7ff fc2c 	bl	8100b36 <LL_USART_DisableFIFO>
  LL_USART_ConfigAsyncMode(USART6);
 81012de:	480e      	ldr	r0, [pc, #56]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012e0:	f7ff fc87 	bl	8100bf2 <LL_USART_ConfigAsyncMode>

  /* USER CODE BEGIN WKUPType USART6 */

  /* USER CODE END WKUPType USART6 */

  LL_USART_Enable(USART6);
 81012e4:	480c      	ldr	r0, [pc, #48]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012e6:	f7ff fc16 	bl	8100b16 <LL_USART_Enable>

  /* Polling USART6 initialisation */
  while((!(LL_USART_IsActiveFlag_TEACK(USART6))) || (!(LL_USART_IsActiveFlag_REACK(USART6))))
 81012ea:	bf00      	nop
 81012ec:	480a      	ldr	r0, [pc, #40]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012ee:	f7ff fc96 	bl	8100c1e <LL_USART_IsActiveFlag_TEACK>
 81012f2:	4603      	mov	r3, r0
 81012f4:	2b00      	cmp	r3, #0
 81012f6:	d0f9      	beq.n	81012ec <MX_USART6_UART_Init+0x170>
 81012f8:	4807      	ldr	r0, [pc, #28]	@ (8101318 <MX_USART6_UART_Init+0x19c>)
 81012fa:	f7ff fca4 	bl	8100c46 <LL_USART_IsActiveFlag_REACK>
 81012fe:	4603      	mov	r3, r0
 8101300:	2b00      	cmp	r3, #0
 8101302:	d0f3      	beq.n	81012ec <MX_USART6_UART_Init+0x170>
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}
 8101304:	bf00      	nop
 8101306:	bf00      	nop
 8101308:	37f8      	adds	r7, #248	@ 0xf8
 810130a:	46bd      	mov	sp, r7
 810130c:	bd80      	pop	{r7, pc}
 810130e:	bf00      	nop
 8101310:	58021800 	.word	0x58021800
 8101314:	40020400 	.word	0x40020400
 8101318:	40011400 	.word	0x40011400

0810131c <MX_BDMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_BDMA_Init(void)
{
 810131c:	b480      	push	{r7}
 810131e:	b083      	sub	sp, #12
 8101320:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
 8101322:	4b0a      	ldr	r3, [pc, #40]	@ (810134c <MX_BDMA_Init+0x30>)
 8101324:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8101328:	4a08      	ldr	r2, [pc, #32]	@ (810134c <MX_BDMA_Init+0x30>)
 810132a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 810132e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8101332:	4b06      	ldr	r3, [pc, #24]	@ (810134c <MX_BDMA_Init+0x30>)
 8101334:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8101338:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 810133c:	607b      	str	r3, [r7, #4]
 810133e:	687b      	ldr	r3, [r7, #4]

}
 8101340:	bf00      	nop
 8101342:	370c      	adds	r7, #12
 8101344:	46bd      	mov	sp, r7
 8101346:	f85d 7b04 	ldr.w	r7, [sp], #4
 810134a:	4770      	bx	lr
 810134c:	58024400 	.word	0x58024400

08101350 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 8101350:	b580      	push	{r7, lr}
 8101352:	b082      	sub	sp, #8
 8101354:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8101356:	4b19      	ldr	r3, [pc, #100]	@ (81013bc <MX_DMA_Init+0x6c>)
 8101358:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810135c:	4a17      	ldr	r2, [pc, #92]	@ (81013bc <MX_DMA_Init+0x6c>)
 810135e:	f043 0302 	orr.w	r3, r3, #2
 8101362:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 8101366:	4b15      	ldr	r3, [pc, #84]	@ (81013bc <MX_DMA_Init+0x6c>)
 8101368:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810136c:	f003 0302 	and.w	r3, r3, #2
 8101370:	607b      	str	r3, [r7, #4]
 8101372:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8101374:	4b11      	ldr	r3, [pc, #68]	@ (81013bc <MX_DMA_Init+0x6c>)
 8101376:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810137a:	4a10      	ldr	r2, [pc, #64]	@ (81013bc <MX_DMA_Init+0x6c>)
 810137c:	f043 0301 	orr.w	r3, r3, #1
 8101380:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 8101384:	4b0d      	ldr	r3, [pc, #52]	@ (81013bc <MX_DMA_Init+0x6c>)
 8101386:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810138a:	f003 0301 	and.w	r3, r3, #1
 810138e:	603b      	str	r3, [r7, #0]
 8101390:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  NVIC_SetPriority(DMA2_Stream0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
 8101392:	f7ff fabf 	bl	8100914 <__NVIC_GetPriorityGrouping>
 8101396:	4603      	mov	r3, r0
 8101398:	2200      	movs	r2, #0
 810139a:	2100      	movs	r1, #0
 810139c:	4618      	mov	r0, r3
 810139e:	f7ff fb0f 	bl	81009c0 <NVIC_EncodePriority>
 81013a2:	4603      	mov	r3, r0
 81013a4:	4619      	mov	r1, r3
 81013a6:	2038      	movs	r0, #56	@ 0x38
 81013a8:	f7ff fae0 	bl	810096c <__NVIC_SetPriority>
  NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 81013ac:	2038      	movs	r0, #56	@ 0x38
 81013ae:	f7ff fabf 	bl	8100930 <__NVIC_EnableIRQ>

}
 81013b2:	bf00      	nop
 81013b4:	3708      	adds	r7, #8
 81013b6:	46bd      	mov	sp, r7
 81013b8:	bd80      	pop	{r7, pc}
 81013ba:	bf00      	nop
 81013bc:	58024400 	.word	0x58024400

081013c0 <MX_MDMA_Init>:

/**
  * Enable MDMA controller clock
  */
static void MX_MDMA_Init(void)
{
 81013c0:	b480      	push	{r7}
 81013c2:	b083      	sub	sp, #12
 81013c4:	af00      	add	r7, sp, #0

  /* MDMA controller clock enable */
  __HAL_RCC_MDMA_CLK_ENABLE();
 81013c6:	4b0a      	ldr	r3, [pc, #40]	@ (81013f0 <MX_MDMA_Init+0x30>)
 81013c8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 81013cc:	4a08      	ldr	r2, [pc, #32]	@ (81013f0 <MX_MDMA_Init+0x30>)
 81013ce:	f043 0301 	orr.w	r3, r3, #1
 81013d2:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
 81013d6:	4b06      	ldr	r3, [pc, #24]	@ (81013f0 <MX_MDMA_Init+0x30>)
 81013d8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 81013dc:	f003 0301 	and.w	r3, r3, #1
 81013e0:	607b      	str	r3, [r7, #4]
 81013e2:	687b      	ldr	r3, [r7, #4]
  /* Local variables */

}
 81013e4:	bf00      	nop
 81013e6:	370c      	adds	r7, #12
 81013e8:	46bd      	mov	sp, r7
 81013ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 81013ee:	4770      	bx	lr
 81013f0:	58024400 	.word	0x58024400

081013f4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 81013f4:	b580      	push	{r7, lr}
 81013f6:	b086      	sub	sp, #24
 81013f8:	af00      	add	r7, sp, #0
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 81013fa:	463b      	mov	r3, r7
 81013fc:	2200      	movs	r2, #0
 81013fe:	601a      	str	r2, [r3, #0]
 8101400:	605a      	str	r2, [r3, #4]
 8101402:	609a      	str	r2, [r3, #8]
 8101404:	60da      	str	r2, [r3, #12]
 8101406:	611a      	str	r2, [r3, #16]
 8101408:	615a      	str	r2, [r3, #20]
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOC);
 810140a:	2004      	movs	r0, #4
 810140c:	f7ff fc3e 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOA);
 8101410:	2001      	movs	r0, #1
 8101412:	f7ff fc3b 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOB);
 8101416:	2002      	movs	r0, #2
 8101418:	f7ff fc38 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOD);
 810141c:	2008      	movs	r0, #8
 810141e:	f7ff fc35 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOG);
 8101422:	2040      	movs	r0, #64	@ 0x40
 8101424:	f7ff fc32 	bl	8100c8c <LL_AHB4_GRP1_EnableClock>

  /**/
  LL_GPIO_ResetOutputPin(GPIOD, MCU_IO_DEBUG_LED2_Pin|MCU_IO_DEBUG_LED3_Pin);
 8101428:	f44f 4140 	mov.w	r1, #49152	@ 0xc000
 810142c:	480b      	ldr	r0, [pc, #44]	@ (810145c <MX_GPIO_Init+0x68>)
 810142e:	f7ff fc1e 	bl	8100c6e <LL_GPIO_ResetOutputPin>

  /**/
  GPIO_InitStruct.Pin = MCU_IO_DEBUG_LED2_Pin|MCU_IO_DEBUG_LED3_Pin;
 8101432:	f44f 4340 	mov.w	r3, #49152	@ 0xc000
 8101436:	603b      	str	r3, [r7, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8101438:	2301      	movs	r3, #1
 810143a:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 810143c:	2300      	movs	r3, #0
 810143e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8101440:	2300      	movs	r3, #0
 8101442:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8101444:	2300      	movs	r3, #0
 8101446:	613b      	str	r3, [r7, #16]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8101448:	463b      	mov	r3, r7
 810144a:	4619      	mov	r1, r3
 810144c:	4803      	ldr	r0, [pc, #12]	@ (810145c <MX_GPIO_Init+0x68>)
 810144e:	f006 fcfb 	bl	8107e48 <LL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 8101452:	bf00      	nop
 8101454:	3718      	adds	r7, #24
 8101456:	46bd      	mov	sp, r7
 8101458:	bd80      	pop	{r7, pc}
 810145a:	bf00      	nop
 810145c:	58020c00 	.word	0x58020c00

08101460 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8101460:	b580      	push	{r7, lr}
 8101462:	b082      	sub	sp, #8
 8101464:	af00      	add	r7, sp, #0
 8101466:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM4)
 8101468:	687b      	ldr	r3, [r7, #4]
 810146a:	681b      	ldr	r3, [r3, #0]
 810146c:	4a04      	ldr	r2, [pc, #16]	@ (8101480 <HAL_TIM_PeriodElapsedCallback+0x20>)
 810146e:	4293      	cmp	r3, r2
 8101470:	d101      	bne.n	8101476 <HAL_TIM_PeriodElapsedCallback+0x16>
  {
    HAL_IncTick();
 8101472:	f000 fa65 	bl	8101940 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8101476:	bf00      	nop
 8101478:	3708      	adds	r7, #8
 810147a:	46bd      	mov	sp, r7
 810147c:	bd80      	pop	{r7, pc}
 810147e:	bf00      	nop
 8101480:	40000800 	.word	0x40000800

08101484 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8101484:	b480      	push	{r7}
 8101486:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8101488:	b672      	cpsid	i
}
 810148a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 810148c:	bf00      	nop
 810148e:	e7fd      	b.n	810148c <Error_Handler+0x8>

08101490 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8101490:	b480      	push	{r7}
 8101492:	b083      	sub	sp, #12
 8101494:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8101496:	4b0a      	ldr	r3, [pc, #40]	@ (81014c0 <HAL_MspInit+0x30>)
 8101498:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 810149c:	4a08      	ldr	r2, [pc, #32]	@ (81014c0 <HAL_MspInit+0x30>)
 810149e:	f043 0302 	orr.w	r3, r3, #2
 81014a2:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 81014a6:	4b06      	ldr	r3, [pc, #24]	@ (81014c0 <HAL_MspInit+0x30>)
 81014a8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 81014ac:	f003 0302 	and.w	r3, r3, #2
 81014b0:	607b      	str	r3, [r7, #4]
 81014b2:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 81014b4:	bf00      	nop
 81014b6:	370c      	adds	r7, #12
 81014b8:	46bd      	mov	sp, r7
 81014ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 81014be:	4770      	bx	lr
 81014c0:	58024400 	.word	0x58024400

081014c4 <HAL_MMC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hmmc: MMC handle pointer
  * @retval None
  */
void HAL_MMC_MspInit(MMC_HandleTypeDef* hmmc)
{
 81014c4:	b580      	push	{r7, lr}
 81014c6:	b0be      	sub	sp, #248	@ 0xf8
 81014c8:	af00      	add	r7, sp, #0
 81014ca:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 81014cc:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 81014d0:	2200      	movs	r2, #0
 81014d2:	601a      	str	r2, [r3, #0]
 81014d4:	605a      	str	r2, [r3, #4]
 81014d6:	609a      	str	r2, [r3, #8]
 81014d8:	60da      	str	r2, [r3, #12]
 81014da:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 81014dc:	f107 0320 	add.w	r3, r7, #32
 81014e0:	22c0      	movs	r2, #192	@ 0xc0
 81014e2:	2100      	movs	r1, #0
 81014e4:	4618      	mov	r0, r3
 81014e6:	f00c fa21 	bl	810d92c <memset>
  if(hmmc->Instance==SDMMC2)
 81014ea:	687b      	ldr	r3, [r7, #4]
 81014ec:	681b      	ldr	r3, [r3, #0]
 81014ee:	4a61      	ldr	r2, [pc, #388]	@ (8101674 <HAL_MMC_MspInit+0x1b0>)
 81014f0:	4293      	cmp	r3, r2
 81014f2:	f040 80bb 	bne.w	810166c <HAL_MMC_MspInit+0x1a8>

    /* USER CODE END SDMMC2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;
 81014f6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 81014fa:	f04f 0300 	mov.w	r3, #0
 81014fe:	e9c7 2308 	strd	r2, r3, [r7, #32]
    PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
 8101502:	2300      	movs	r3, #0
 8101504:	673b      	str	r3, [r7, #112]	@ 0x70
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8101506:	f107 0320 	add.w	r3, r7, #32
 810150a:	4618      	mov	r0, r3
 810150c:	f003 fbfc 	bl	8104d08 <HAL_RCCEx_PeriphCLKConfig>
 8101510:	4603      	mov	r3, r0
 8101512:	2b00      	cmp	r3, #0
 8101514:	d001      	beq.n	810151a <HAL_MMC_MspInit+0x56>
    {
      Error_Handler();
 8101516:	f7ff ffb5 	bl	8101484 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SDMMC2_CLK_ENABLE();
 810151a:	4b57      	ldr	r3, [pc, #348]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810151c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8101520:	4a55      	ldr	r2, [pc, #340]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101522:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8101526:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
 810152a:	4b53      	ldr	r3, [pc, #332]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810152c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8101530:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8101534:	61fb      	str	r3, [r7, #28]
 8101536:	69fb      	ldr	r3, [r7, #28]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8101538:	4b4f      	ldr	r3, [pc, #316]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810153a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810153e:	4a4e      	ldr	r2, [pc, #312]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101540:	f043 0304 	orr.w	r3, r3, #4
 8101544:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8101548:	4b4b      	ldr	r3, [pc, #300]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810154a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810154e:	f003 0304 	and.w	r3, r3, #4
 8101552:	61bb      	str	r3, [r7, #24]
 8101554:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8101556:	4b48      	ldr	r3, [pc, #288]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101558:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810155c:	4a46      	ldr	r2, [pc, #280]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810155e:	f043 0301 	orr.w	r3, r3, #1
 8101562:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8101566:	4b44      	ldr	r3, [pc, #272]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101568:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810156c:	f003 0301 	and.w	r3, r3, #1
 8101570:	617b      	str	r3, [r7, #20]
 8101572:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8101574:	4b40      	ldr	r3, [pc, #256]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101576:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810157a:	4a3f      	ldr	r2, [pc, #252]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810157c:	f043 0302 	orr.w	r3, r3, #2
 8101580:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8101584:	4b3c      	ldr	r3, [pc, #240]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101586:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810158a:	f003 0302 	and.w	r3, r3, #2
 810158e:	613b      	str	r3, [r7, #16]
 8101590:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 8101592:	4b39      	ldr	r3, [pc, #228]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 8101594:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8101598:	4a37      	ldr	r2, [pc, #220]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 810159a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 810159e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 81015a2:	4b35      	ldr	r3, [pc, #212]	@ (8101678 <HAL_MMC_MspInit+0x1b4>)
 81015a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 81015a8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 81015ac:	60fb      	str	r3, [r7, #12]
 81015ae:	68fb      	ldr	r3, [r7, #12]
    PB14     ------> SDMMC2_D0
    PB15     ------> SDMMC2_D1
    PG11     ------> SDMMC2_D2
    PB4 (NJTRST)     ------> SDMMC2_D3
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 81015b0:	2302      	movs	r3, #2
 81015b2:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81015b6:	2302      	movs	r3, #2
 81015b8:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 81015bc:	2300      	movs	r3, #0
 81015be:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 81015c2:	2303      	movs	r3, #3
 81015c4:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF9_SDIO2;
 81015c8:	2309      	movs	r3, #9
 81015ca:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 81015ce:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 81015d2:	4619      	mov	r1, r3
 81015d4:	4829      	ldr	r0, [pc, #164]	@ (810167c <HAL_MMC_MspInit+0x1b8>)
 81015d6:	f000 fae9 	bl	8101bac <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0;
 81015da:	2301      	movs	r3, #1
 81015dc:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81015e0:	2302      	movs	r3, #2
 81015e2:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 81015e6:	2300      	movs	r3, #0
 81015e8:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 81015ec:	2303      	movs	r3, #3
 81015ee:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF9_SDIO2;
 81015f2:	2309      	movs	r3, #9
 81015f4:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 81015f8:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 81015fc:	4619      	mov	r1, r3
 81015fe:	4820      	ldr	r0, [pc, #128]	@ (8101680 <HAL_MMC_MspInit+0x1bc>)
 8101600:	f000 fad4 	bl	8101bac <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_4;
 8101604:	f24c 0310 	movw	r3, #49168	@ 0xc010
 8101608:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810160c:	2302      	movs	r3, #2
 810160e:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8101612:	2300      	movs	r3, #0
 8101614:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8101618:	2303      	movs	r3, #3
 810161a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF9_SDIO2;
 810161e:	2309      	movs	r3, #9
 8101620:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8101624:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 8101628:	4619      	mov	r1, r3
 810162a:	4816      	ldr	r0, [pc, #88]	@ (8101684 <HAL_MMC_MspInit+0x1c0>)
 810162c:	f000 fabe 	bl	8101bac <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8101630:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8101634:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8101638:	2302      	movs	r3, #2
 810163a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810163e:	2300      	movs	r3, #0
 8101640:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8101644:	2303      	movs	r3, #3
 8101646:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF10_SDIO2;
 810164a:	230a      	movs	r3, #10
 810164c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8101650:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 8101654:	4619      	mov	r1, r3
 8101656:	480c      	ldr	r0, [pc, #48]	@ (8101688 <HAL_MMC_MspInit+0x1c4>)
 8101658:	f000 faa8 	bl	8101bac <HAL_GPIO_Init>

    /* SDMMC2 interrupt Init */
    HAL_NVIC_SetPriority(SDMMC2_IRQn, 0, 0);
 810165c:	2200      	movs	r2, #0
 810165e:	2100      	movs	r1, #0
 8101660:	207c      	movs	r0, #124	@ 0x7c
 8101662:	f000 fa69 	bl	8101b38 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC2_IRQn);
 8101666:	207c      	movs	r0, #124	@ 0x7c
 8101668:	f000 fa80 	bl	8101b6c <HAL_NVIC_EnableIRQ>

    /* USER CODE END SDMMC2_MspInit 1 */

  }

}
 810166c:	bf00      	nop
 810166e:	37f8      	adds	r7, #248	@ 0xf8
 8101670:	46bd      	mov	sp, r7
 8101672:	bd80      	pop	{r7, pc}
 8101674:	48022400 	.word	0x48022400
 8101678:	58024400 	.word	0x58024400
 810167c:	58020800 	.word	0x58020800
 8101680:	58020000 	.word	0x58020000
 8101684:	58020400 	.word	0x58020400
 8101688:	58021800 	.word	0x58021800

0810168c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 810168c:	b580      	push	{r7, lr}
 810168e:	b090      	sub	sp, #64	@ 0x40
 8101690:	af00      	add	r7, sp, #0
 8101692:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock, uwAPB1Prescaler;
  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;

  /*Configure the TIM4 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8101694:	687b      	ldr	r3, [r7, #4]
 8101696:	2b0f      	cmp	r3, #15
 8101698:	d827      	bhi.n	81016ea <HAL_InitTick+0x5e>
   {
     HAL_NVIC_SetPriority(TIM4_IRQn, TickPriority ,0);
 810169a:	2200      	movs	r2, #0
 810169c:	6879      	ldr	r1, [r7, #4]
 810169e:	201e      	movs	r0, #30
 81016a0:	f000 fa4a 	bl	8101b38 <HAL_NVIC_SetPriority>

     /* Enable the TIM4 global Interrupt */
     HAL_NVIC_EnableIRQ(TIM4_IRQn);
 81016a4:	201e      	movs	r0, #30
 81016a6:	f000 fa61 	bl	8101b6c <HAL_NVIC_EnableIRQ>
     uwTickPrio = TickPriority;
 81016aa:	4a29      	ldr	r2, [pc, #164]	@ (8101750 <HAL_InitTick+0xc4>)
 81016ac:	687b      	ldr	r3, [r7, #4]
 81016ae:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM4 clock */
  __HAL_RCC_TIM4_CLK_ENABLE();
 81016b0:	4b28      	ldr	r3, [pc, #160]	@ (8101754 <HAL_InitTick+0xc8>)
 81016b2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81016b6:	4a27      	ldr	r2, [pc, #156]	@ (8101754 <HAL_InitTick+0xc8>)
 81016b8:	f043 0304 	orr.w	r3, r3, #4
 81016bc:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 81016c0:	4b24      	ldr	r3, [pc, #144]	@ (8101754 <HAL_InitTick+0xc8>)
 81016c2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81016c6:	f003 0304 	and.w	r3, r3, #4
 81016ca:	60fb      	str	r3, [r7, #12]
 81016cc:	68fb      	ldr	r3, [r7, #12]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 81016ce:	f107 0210 	add.w	r2, r7, #16
 81016d2:	f107 0314 	add.w	r3, r7, #20
 81016d6:	4611      	mov	r1, r2
 81016d8:	4618      	mov	r0, r3
 81016da:	f003 fad3 	bl	8104c84 <HAL_RCC_GetClockConfig>

  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
 81016de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81016e0:	63bb      	str	r3, [r7, #56]	@ 0x38
  /* Compute TIM4 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 81016e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81016e4:	2b00      	cmp	r3, #0
 81016e6:	d106      	bne.n	81016f6 <HAL_InitTick+0x6a>
 81016e8:	e001      	b.n	81016ee <HAL_InitTick+0x62>
    return HAL_ERROR;
 81016ea:	2301      	movs	r3, #1
 81016ec:	e02b      	b.n	8101746 <HAL_InitTick+0xba>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 81016ee:	f003 fab3 	bl	8104c58 <HAL_RCC_GetPCLK1Freq>
 81016f2:	63f8      	str	r0, [r7, #60]	@ 0x3c
 81016f4:	e004      	b.n	8101700 <HAL_InitTick+0x74>
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
 81016f6:	f003 faaf 	bl	8104c58 <HAL_RCC_GetPCLK1Freq>
 81016fa:	4603      	mov	r3, r0
 81016fc:	005b      	lsls	r3, r3, #1
 81016fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  /* Compute the prescaler value to have TIM4 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8101700:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8101702:	4a15      	ldr	r2, [pc, #84]	@ (8101758 <HAL_InitTick+0xcc>)
 8101704:	fba2 2303 	umull	r2, r3, r2, r3
 8101708:	0c9b      	lsrs	r3, r3, #18
 810170a:	3b01      	subs	r3, #1
 810170c:	637b      	str	r3, [r7, #52]	@ 0x34

  /* Initialize TIM4 */
  htim4.Instance = TIM4;
 810170e:	4b13      	ldr	r3, [pc, #76]	@ (810175c <HAL_InitTick+0xd0>)
 8101710:	4a13      	ldr	r2, [pc, #76]	@ (8101760 <HAL_InitTick+0xd4>)
 8101712:	601a      	str	r2, [r3, #0]
   * Period = [(TIM4CLK/1000) - 1]. to have a (1/1000) s time base.
   * Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
   * ClockDivision = 0
   * Counter direction = Up
   */
  htim4.Init.Period = (1000000U / 1000U) - 1U;
 8101714:	4b11      	ldr	r3, [pc, #68]	@ (810175c <HAL_InitTick+0xd0>)
 8101716:	f240 32e7 	movw	r2, #999	@ 0x3e7
 810171a:	60da      	str	r2, [r3, #12]
  htim4.Init.Prescaler = uwPrescalerValue;
 810171c:	4a0f      	ldr	r2, [pc, #60]	@ (810175c <HAL_InitTick+0xd0>)
 810171e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8101720:	6053      	str	r3, [r2, #4]
  htim4.Init.ClockDivision = 0;
 8101722:	4b0e      	ldr	r3, [pc, #56]	@ (810175c <HAL_InitTick+0xd0>)
 8101724:	2200      	movs	r2, #0
 8101726:	611a      	str	r2, [r3, #16]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8101728:	4b0c      	ldr	r3, [pc, #48]	@ (810175c <HAL_InitTick+0xd0>)
 810172a:	2200      	movs	r2, #0
 810172c:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim4) == HAL_OK)
 810172e:	480b      	ldr	r0, [pc, #44]	@ (810175c <HAL_InitTick+0xd0>)
 8101730:	f005 ffe8 	bl	8107704 <HAL_TIM_Base_Init>
 8101734:	4603      	mov	r3, r0
 8101736:	2b00      	cmp	r3, #0
 8101738:	d104      	bne.n	8101744 <HAL_InitTick+0xb8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim4);
 810173a:	4808      	ldr	r0, [pc, #32]	@ (810175c <HAL_InitTick+0xd0>)
 810173c:	f006 f844 	bl	81077c8 <HAL_TIM_Base_Start_IT>
 8101740:	4603      	mov	r3, r0
 8101742:	e000      	b.n	8101746 <HAL_InitTick+0xba>
  }

  /* Return function status */
  return HAL_ERROR;
 8101744:	2301      	movs	r3, #1
}
 8101746:	4618      	mov	r0, r3
 8101748:	3740      	adds	r7, #64	@ 0x40
 810174a:	46bd      	mov	sp, r7
 810174c:	bd80      	pop	{r7, pc}
 810174e:	bf00      	nop
 8101750:	10032030 	.word	0x10032030
 8101754:	58024400 	.word	0x58024400
 8101758:	431bde83 	.word	0x431bde83
 810175c:	10032610 	.word	0x10032610
 8101760:	40000800 	.word	0x40000800

08101764 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8101764:	b480      	push	{r7}
 8101766:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8101768:	bf00      	nop
 810176a:	e7fd      	b.n	8101768 <NMI_Handler+0x4>

0810176c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 810176c:	b480      	push	{r7}
 810176e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8101770:	bf00      	nop
 8101772:	e7fd      	b.n	8101770 <HardFault_Handler+0x4>

08101774 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8101774:	b480      	push	{r7}
 8101776:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8101778:	bf00      	nop
 810177a:	e7fd      	b.n	8101778 <MemManage_Handler+0x4>

0810177c <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 810177c:	b480      	push	{r7}
 810177e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8101780:	bf00      	nop
 8101782:	e7fd      	b.n	8101780 <BusFault_Handler+0x4>

08101784 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8101784:	b480      	push	{r7}
 8101786:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8101788:	bf00      	nop
 810178a:	e7fd      	b.n	8101788 <UsageFault_Handler+0x4>

0810178c <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 810178c:	b480      	push	{r7}
 810178e:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8101790:	bf00      	nop
 8101792:	46bd      	mov	sp, r7
 8101794:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101798:	4770      	bx	lr

0810179a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 810179a:	b480      	push	{r7}
 810179c:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 810179e:	bf00      	nop
 81017a0:	46bd      	mov	sp, r7
 81017a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017a6:	4770      	bx	lr

081017a8 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 81017a8:	b480      	push	{r7}
 81017aa:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 81017ac:	bf00      	nop
 81017ae:	46bd      	mov	sp, r7
 81017b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017b4:	4770      	bx	lr

081017b6 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 81017b6:	b480      	push	{r7}
 81017b8:	af00      	add	r7, sp, #0
  /* USER CODE END SysTick_IRQn 0 */

  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 81017ba:	bf00      	nop
 81017bc:	46bd      	mov	sp, r7
 81017be:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017c2:	4770      	bx	lr

081017c4 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 81017c4:	b580      	push	{r7, lr}
 81017c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */
  TickTimer_IRQHandler();
 81017c8:	f7ff f85c 	bl	8100884 <TickTimer_IRQHandler>
  SCH_RunSystemTickTimer();
 81017cc:	f7fe fe10 	bl	81003f0 <SCH_RunSystemTickTimer>
  /* USER CODE END TIM2_IRQn 0 */
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 81017d0:	bf00      	nop
 81017d2:	bd80      	pop	{r7, pc}

081017d4 <TIM4_IRQHandler>:

/**
  * @brief This function handles TIM4 global interrupt.
  */
void TIM4_IRQHandler(void)
{
 81017d4:	b580      	push	{r7, lr}
 81017d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM4_IRQn 0 */

  /* USER CODE END TIM4_IRQn 0 */
  HAL_TIM_IRQHandler(&htim4);
 81017d8:	4802      	ldr	r0, [pc, #8]	@ (81017e4 <TIM4_IRQHandler+0x10>)
 81017da:	f006 f86d 	bl	81078b8 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM4_IRQn 1 */

  /* USER CODE END TIM4_IRQn 1 */
}
 81017de:	bf00      	nop
 81017e0:	bd80      	pop	{r7, pc}
 81017e2:	bf00      	nop
 81017e4:	10032610 	.word	0x10032610

081017e8 <DMA2_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA2 stream0 global interrupt.
  */
void DMA2_Stream0_IRQHandler(void)
{
 81017e8:	b480      	push	{r7}
 81017ea:	af00      	add	r7, sp, #0

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 81017ec:	bf00      	nop
 81017ee:	46bd      	mov	sp, r7
 81017f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017f4:	4770      	bx	lr

081017f6 <USART6_IRQHandler>:

/**
  * @brief This function handles USART6 global interrupt.
  */
void USART6_IRQHandler(void)
{
 81017f6:	b480      	push	{r7}
 81017f8:	af00      	add	r7, sp, #0

  /* USER CODE END USART6_IRQn 0 */
  /* USER CODE BEGIN USART6_IRQn 1 */

  /* USER CODE END USART6_IRQn 1 */
}
 81017fa:	bf00      	nop
 81017fc:	46bd      	mov	sp, r7
 81017fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101802:	4770      	bx	lr

08101804 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8101804:	b580      	push	{r7, lr}
 8101806:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8101808:	4802      	ldr	r0, [pc, #8]	@ (8101814 <OTG_FS_IRQHandler+0x10>)
 810180a:	f001 fe82 	bl	8103512 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 810180e:	bf00      	nop
 8101810:	bd80      	pop	{r7, pc}
 8101812:	bf00      	nop
 8101814:	10033b40 	.word	0x10033b40

08101818 <SDMMC2_IRQHandler>:

/**
  * @brief This function handles SDMMC2 global interrupt.
  */
void SDMMC2_IRQHandler(void)
{
 8101818:	b580      	push	{r7, lr}
 810181a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDMMC2_IRQn 0 */

  /* USER CODE END SDMMC2_IRQn 0 */
  HAL_MMC_IRQHandler(&hmmc2);
 810181c:	4802      	ldr	r0, [pc, #8]	@ (8101828 <SDMMC2_IRQHandler+0x10>)
 810181e:	f000 fc63 	bl	81020e8 <HAL_MMC_IRQHandler>
  /* USER CODE BEGIN SDMMC2_IRQn 1 */

  /* USER CODE END SDMMC2_IRQn 1 */
}
 8101822:	bf00      	nop
 8101824:	bd80      	pop	{r7, pc}
 8101826:	bf00      	nop
 8101828:	10032398 	.word	0x10032398

0810182c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 810182c:	f8df d038 	ldr.w	sp, [pc, #56]	@ 8101868 <LoopFillZerobss+0xe>

/* Call the ExitRun0Mode function to configure the power supply */
  bl  ExitRun0Mode
 8101830:	f7ff f856 	bl	81008e0 <ExitRun0Mode>
/* Call the clock system initialization function.*/
  bl  SystemInit
 8101834:	f7ff f83c 	bl	81008b0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8101838:	480c      	ldr	r0, [pc, #48]	@ (810186c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 810183a:	490d      	ldr	r1, [pc, #52]	@ (8101870 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 810183c:	4a0d      	ldr	r2, [pc, #52]	@ (8101874 <LoopFillZerobss+0x1a>)
  movs r3, #0
 810183e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8101840:	e002      	b.n	8101848 <LoopCopyDataInit>

08101842 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8101842:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8101844:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8101846:	3304      	adds	r3, #4

08101848 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8101848:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 810184a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 810184c:	d3f9      	bcc.n	8101842 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 810184e:	4a0a      	ldr	r2, [pc, #40]	@ (8101878 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8101850:	4c0a      	ldr	r4, [pc, #40]	@ (810187c <LoopFillZerobss+0x22>)
  movs r3, #0
 8101852:	2300      	movs	r3, #0
  b LoopFillZerobss
 8101854:	e001      	b.n	810185a <LoopFillZerobss>

08101856 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8101856:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8101858:	3204      	adds	r2, #4

0810185a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 810185a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 810185c:	d3fb      	bcc.n	8101856 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 810185e:	f00c f86d 	bl	810d93c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8101862:	f7ff fbc5 	bl	8100ff0 <main>
  bx  lr
 8101866:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8101868:	10048000 	.word	0x10048000
  ldr r0, =_sdata
 810186c:	10032000 	.word	0x10032000
  ldr r1, =_edata
 8101870:	1003212c 	.word	0x1003212c
  ldr r2, =_sidata
 8101874:	0810da5c 	.word	0x0810da5c
  ldr r2, =_sbss
 8101878:	1003212c 	.word	0x1003212c
  ldr r4, =_ebss
 810187c:	10034244 	.word	0x10034244

08101880 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8101880:	e7fe      	b.n	8101880 <ADC3_IRQHandler>
	...

08101884 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8101884:	b580      	push	{r7, lr}
 8101886:	b082      	sub	sp, #8
 8101888:	af00      	add	r7, sp, #0

uint32_t common_system_clock;

#if defined(DUAL_CORE) && defined(CORE_CM4)
   /* Configure Cortex-M4 Instruction cache through ART accelerator */
   __HAL_RCC_ART_CLK_ENABLE();                   /* Enable the Cortex-M4 ART Clock */
 810188a:	4b28      	ldr	r3, [pc, #160]	@ (810192c <HAL_Init+0xa8>)
 810188c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8101890:	4a26      	ldr	r2, [pc, #152]	@ (810192c <HAL_Init+0xa8>)
 8101892:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8101896:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 810189a:	4b24      	ldr	r3, [pc, #144]	@ (810192c <HAL_Init+0xa8>)
 810189c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 81018a0:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 81018a4:	603b      	str	r3, [r7, #0]
 81018a6:	683b      	ldr	r3, [r7, #0]
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
 81018a8:	4b21      	ldr	r3, [pc, #132]	@ (8101930 <HAL_Init+0xac>)
 81018aa:	681b      	ldr	r3, [r3, #0]
 81018ac:	f423 237f 	bic.w	r3, r3, #1044480	@ 0xff000
 81018b0:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 81018b4:	4a1e      	ldr	r2, [pc, #120]	@ (8101930 <HAL_Init+0xac>)
 81018b6:	f443 4301 	orr.w	r3, r3, #33024	@ 0x8100
 81018ba:	6013      	str	r3, [r2, #0]
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
 81018bc:	4b1c      	ldr	r3, [pc, #112]	@ (8101930 <HAL_Init+0xac>)
 81018be:	681b      	ldr	r3, [r3, #0]
 81018c0:	4a1b      	ldr	r2, [pc, #108]	@ (8101930 <HAL_Init+0xac>)
 81018c2:	f043 0301 	orr.w	r3, r3, #1
 81018c6:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 81018c8:	2003      	movs	r0, #3
 81018ca:	f000 f92a 	bl	8101b22 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 81018ce:	f003 f817 	bl	8104900 <HAL_RCC_GetSysClockFreq>
 81018d2:	4602      	mov	r2, r0
 81018d4:	4b15      	ldr	r3, [pc, #84]	@ (810192c <HAL_Init+0xa8>)
 81018d6:	699b      	ldr	r3, [r3, #24]
 81018d8:	0a1b      	lsrs	r3, r3, #8
 81018da:	f003 030f 	and.w	r3, r3, #15
 81018de:	4915      	ldr	r1, [pc, #84]	@ (8101934 <HAL_Init+0xb0>)
 81018e0:	5ccb      	ldrb	r3, [r1, r3]
 81018e2:	f003 031f 	and.w	r3, r3, #31
 81018e6:	fa22 f303 	lsr.w	r3, r2, r3
 81018ea:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 81018ec:	4b0f      	ldr	r3, [pc, #60]	@ (810192c <HAL_Init+0xa8>)
 81018ee:	699b      	ldr	r3, [r3, #24]
 81018f0:	f003 030f 	and.w	r3, r3, #15
 81018f4:	4a0f      	ldr	r2, [pc, #60]	@ (8101934 <HAL_Init+0xb0>)
 81018f6:	5cd3      	ldrb	r3, [r2, r3]
 81018f8:	f003 031f 	and.w	r3, r3, #31
 81018fc:	687a      	ldr	r2, [r7, #4]
 81018fe:	fa22 f303 	lsr.w	r3, r2, r3
 8101902:	4a0d      	ldr	r2, [pc, #52]	@ (8101938 <HAL_Init+0xb4>)
 8101904:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 8101906:	4b0c      	ldr	r3, [pc, #48]	@ (8101938 <HAL_Init+0xb4>)
 8101908:	681b      	ldr	r3, [r3, #0]
 810190a:	4a0c      	ldr	r2, [pc, #48]	@ (810193c <HAL_Init+0xb8>)
 810190c:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 810190e:	200f      	movs	r0, #15
 8101910:	f7ff febc 	bl	810168c <HAL_InitTick>
 8101914:	4603      	mov	r3, r0
 8101916:	2b00      	cmp	r3, #0
 8101918:	d001      	beq.n	810191e <HAL_Init+0x9a>
  {
    return HAL_ERROR;
 810191a:	2301      	movs	r3, #1
 810191c:	e002      	b.n	8101924 <HAL_Init+0xa0>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 810191e:	f7ff fdb7 	bl	8101490 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8101922:	2300      	movs	r3, #0
}
 8101924:	4618      	mov	r0, r3
 8101926:	3708      	adds	r7, #8
 8101928:	46bd      	mov	sp, r7
 810192a:	bd80      	pop	{r7, pc}
 810192c:	58024400 	.word	0x58024400
 8101930:	40024400 	.word	0x40024400
 8101934:	0810d9fc 	.word	0x0810d9fc
 8101938:	1003202c 	.word	0x1003202c
 810193c:	10032028 	.word	0x10032028

08101940 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8101940:	b480      	push	{r7}
 8101942:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8101944:	4b06      	ldr	r3, [pc, #24]	@ (8101960 <HAL_IncTick+0x20>)
 8101946:	781b      	ldrb	r3, [r3, #0]
 8101948:	461a      	mov	r2, r3
 810194a:	4b06      	ldr	r3, [pc, #24]	@ (8101964 <HAL_IncTick+0x24>)
 810194c:	681b      	ldr	r3, [r3, #0]
 810194e:	4413      	add	r3, r2
 8101950:	4a04      	ldr	r2, [pc, #16]	@ (8101964 <HAL_IncTick+0x24>)
 8101952:	6013      	str	r3, [r2, #0]
}
 8101954:	bf00      	nop
 8101956:	46bd      	mov	sp, r7
 8101958:	f85d 7b04 	ldr.w	r7, [sp], #4
 810195c:	4770      	bx	lr
 810195e:	bf00      	nop
 8101960:	10032034 	.word	0x10032034
 8101964:	1003265c 	.word	0x1003265c

08101968 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8101968:	b480      	push	{r7}
 810196a:	af00      	add	r7, sp, #0
  return uwTick;
 810196c:	4b03      	ldr	r3, [pc, #12]	@ (810197c <HAL_GetTick+0x14>)
 810196e:	681b      	ldr	r3, [r3, #0]
}
 8101970:	4618      	mov	r0, r3
 8101972:	46bd      	mov	sp, r7
 8101974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101978:	4770      	bx	lr
 810197a:	bf00      	nop
 810197c:	1003265c 	.word	0x1003265c

08101980 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8101980:	b580      	push	{r7, lr}
 8101982:	b084      	sub	sp, #16
 8101984:	af00      	add	r7, sp, #0
 8101986:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8101988:	f7ff ffee 	bl	8101968 <HAL_GetTick>
 810198c:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 810198e:	687b      	ldr	r3, [r7, #4]
 8101990:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8101992:	68fb      	ldr	r3, [r7, #12]
 8101994:	f1b3 3fff 	cmp.w	r3, #4294967295
 8101998:	d005      	beq.n	81019a6 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 810199a:	4b0a      	ldr	r3, [pc, #40]	@ (81019c4 <HAL_Delay+0x44>)
 810199c:	781b      	ldrb	r3, [r3, #0]
 810199e:	461a      	mov	r2, r3
 81019a0:	68fb      	ldr	r3, [r7, #12]
 81019a2:	4413      	add	r3, r2
 81019a4:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 81019a6:	bf00      	nop
 81019a8:	f7ff ffde 	bl	8101968 <HAL_GetTick>
 81019ac:	4602      	mov	r2, r0
 81019ae:	68bb      	ldr	r3, [r7, #8]
 81019b0:	1ad3      	subs	r3, r2, r3
 81019b2:	68fa      	ldr	r2, [r7, #12]
 81019b4:	429a      	cmp	r2, r3
 81019b6:	d8f7      	bhi.n	81019a8 <HAL_Delay+0x28>
  {
  }
}
 81019b8:	bf00      	nop
 81019ba:	bf00      	nop
 81019bc:	3710      	adds	r7, #16
 81019be:	46bd      	mov	sp, r7
 81019c0:	bd80      	pop	{r7, pc}
 81019c2:	bf00      	nop
 81019c4:	10032034 	.word	0x10032034

081019c8 <__NVIC_SetPriorityGrouping>:
{
 81019c8:	b480      	push	{r7}
 81019ca:	b085      	sub	sp, #20
 81019cc:	af00      	add	r7, sp, #0
 81019ce:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 81019d0:	687b      	ldr	r3, [r7, #4]
 81019d2:	f003 0307 	and.w	r3, r3, #7
 81019d6:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81019d8:	4b0c      	ldr	r3, [pc, #48]	@ (8101a0c <__NVIC_SetPriorityGrouping+0x44>)
 81019da:	68db      	ldr	r3, [r3, #12]
 81019dc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 81019de:	68ba      	ldr	r2, [r7, #8]
 81019e0:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 81019e4:	4013      	ands	r3, r2
 81019e6:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 81019e8:	68fb      	ldr	r3, [r7, #12]
 81019ea:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 81019ec:	68bb      	ldr	r3, [r7, #8]
 81019ee:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 81019f0:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 81019f4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81019f8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 81019fa:	4a04      	ldr	r2, [pc, #16]	@ (8101a0c <__NVIC_SetPriorityGrouping+0x44>)
 81019fc:	68bb      	ldr	r3, [r7, #8]
 81019fe:	60d3      	str	r3, [r2, #12]
}
 8101a00:	bf00      	nop
 8101a02:	3714      	adds	r7, #20
 8101a04:	46bd      	mov	sp, r7
 8101a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101a0a:	4770      	bx	lr
 8101a0c:	e000ed00 	.word	0xe000ed00

08101a10 <__NVIC_GetPriorityGrouping>:
{
 8101a10:	b480      	push	{r7}
 8101a12:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8101a14:	4b04      	ldr	r3, [pc, #16]	@ (8101a28 <__NVIC_GetPriorityGrouping+0x18>)
 8101a16:	68db      	ldr	r3, [r3, #12]
 8101a18:	0a1b      	lsrs	r3, r3, #8
 8101a1a:	f003 0307 	and.w	r3, r3, #7
}
 8101a1e:	4618      	mov	r0, r3
 8101a20:	46bd      	mov	sp, r7
 8101a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101a26:	4770      	bx	lr
 8101a28:	e000ed00 	.word	0xe000ed00

08101a2c <__NVIC_EnableIRQ>:
{
 8101a2c:	b480      	push	{r7}
 8101a2e:	b083      	sub	sp, #12
 8101a30:	af00      	add	r7, sp, #0
 8101a32:	4603      	mov	r3, r0
 8101a34:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8101a36:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101a3a:	2b00      	cmp	r3, #0
 8101a3c:	db0b      	blt.n	8101a56 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8101a3e:	88fb      	ldrh	r3, [r7, #6]
 8101a40:	f003 021f 	and.w	r2, r3, #31
 8101a44:	4907      	ldr	r1, [pc, #28]	@ (8101a64 <__NVIC_EnableIRQ+0x38>)
 8101a46:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101a4a:	095b      	lsrs	r3, r3, #5
 8101a4c:	2001      	movs	r0, #1
 8101a4e:	fa00 f202 	lsl.w	r2, r0, r2
 8101a52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8101a56:	bf00      	nop
 8101a58:	370c      	adds	r7, #12
 8101a5a:	46bd      	mov	sp, r7
 8101a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101a60:	4770      	bx	lr
 8101a62:	bf00      	nop
 8101a64:	e000e100 	.word	0xe000e100

08101a68 <__NVIC_SetPriority>:
{
 8101a68:	b480      	push	{r7}
 8101a6a:	b083      	sub	sp, #12
 8101a6c:	af00      	add	r7, sp, #0
 8101a6e:	4603      	mov	r3, r0
 8101a70:	6039      	str	r1, [r7, #0]
 8101a72:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8101a74:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101a78:	2b00      	cmp	r3, #0
 8101a7a:	db0a      	blt.n	8101a92 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8101a7c:	683b      	ldr	r3, [r7, #0]
 8101a7e:	b2da      	uxtb	r2, r3
 8101a80:	490c      	ldr	r1, [pc, #48]	@ (8101ab4 <__NVIC_SetPriority+0x4c>)
 8101a82:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101a86:	0112      	lsls	r2, r2, #4
 8101a88:	b2d2      	uxtb	r2, r2
 8101a8a:	440b      	add	r3, r1
 8101a8c:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 8101a90:	e00a      	b.n	8101aa8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8101a92:	683b      	ldr	r3, [r7, #0]
 8101a94:	b2da      	uxtb	r2, r3
 8101a96:	4908      	ldr	r1, [pc, #32]	@ (8101ab8 <__NVIC_SetPriority+0x50>)
 8101a98:	88fb      	ldrh	r3, [r7, #6]
 8101a9a:	f003 030f 	and.w	r3, r3, #15
 8101a9e:	3b04      	subs	r3, #4
 8101aa0:	0112      	lsls	r2, r2, #4
 8101aa2:	b2d2      	uxtb	r2, r2
 8101aa4:	440b      	add	r3, r1
 8101aa6:	761a      	strb	r2, [r3, #24]
}
 8101aa8:	bf00      	nop
 8101aaa:	370c      	adds	r7, #12
 8101aac:	46bd      	mov	sp, r7
 8101aae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101ab2:	4770      	bx	lr
 8101ab4:	e000e100 	.word	0xe000e100
 8101ab8:	e000ed00 	.word	0xe000ed00

08101abc <NVIC_EncodePriority>:
{
 8101abc:	b480      	push	{r7}
 8101abe:	b089      	sub	sp, #36	@ 0x24
 8101ac0:	af00      	add	r7, sp, #0
 8101ac2:	60f8      	str	r0, [r7, #12]
 8101ac4:	60b9      	str	r1, [r7, #8]
 8101ac6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8101ac8:	68fb      	ldr	r3, [r7, #12]
 8101aca:	f003 0307 	and.w	r3, r3, #7
 8101ace:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8101ad0:	69fb      	ldr	r3, [r7, #28]
 8101ad2:	f1c3 0307 	rsb	r3, r3, #7
 8101ad6:	2b04      	cmp	r3, #4
 8101ad8:	bf28      	it	cs
 8101ada:	2304      	movcs	r3, #4
 8101adc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8101ade:	69fb      	ldr	r3, [r7, #28]
 8101ae0:	3304      	adds	r3, #4
 8101ae2:	2b06      	cmp	r3, #6
 8101ae4:	d902      	bls.n	8101aec <NVIC_EncodePriority+0x30>
 8101ae6:	69fb      	ldr	r3, [r7, #28]
 8101ae8:	3b03      	subs	r3, #3
 8101aea:	e000      	b.n	8101aee <NVIC_EncodePriority+0x32>
 8101aec:	2300      	movs	r3, #0
 8101aee:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8101af0:	f04f 32ff 	mov.w	r2, #4294967295
 8101af4:	69bb      	ldr	r3, [r7, #24]
 8101af6:	fa02 f303 	lsl.w	r3, r2, r3
 8101afa:	43da      	mvns	r2, r3
 8101afc:	68bb      	ldr	r3, [r7, #8]
 8101afe:	401a      	ands	r2, r3
 8101b00:	697b      	ldr	r3, [r7, #20]
 8101b02:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8101b04:	f04f 31ff 	mov.w	r1, #4294967295
 8101b08:	697b      	ldr	r3, [r7, #20]
 8101b0a:	fa01 f303 	lsl.w	r3, r1, r3
 8101b0e:	43d9      	mvns	r1, r3
 8101b10:	687b      	ldr	r3, [r7, #4]
 8101b12:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8101b14:	4313      	orrs	r3, r2
}
 8101b16:	4618      	mov	r0, r3
 8101b18:	3724      	adds	r7, #36	@ 0x24
 8101b1a:	46bd      	mov	sp, r7
 8101b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101b20:	4770      	bx	lr

08101b22 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8101b22:	b580      	push	{r7, lr}
 8101b24:	b082      	sub	sp, #8
 8101b26:	af00      	add	r7, sp, #0
 8101b28:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8101b2a:	6878      	ldr	r0, [r7, #4]
 8101b2c:	f7ff ff4c 	bl	81019c8 <__NVIC_SetPriorityGrouping>
}
 8101b30:	bf00      	nop
 8101b32:	3708      	adds	r7, #8
 8101b34:	46bd      	mov	sp, r7
 8101b36:	bd80      	pop	{r7, pc}

08101b38 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8101b38:	b580      	push	{r7, lr}
 8101b3a:	b086      	sub	sp, #24
 8101b3c:	af00      	add	r7, sp, #0
 8101b3e:	4603      	mov	r3, r0
 8101b40:	60b9      	str	r1, [r7, #8]
 8101b42:	607a      	str	r2, [r7, #4]
 8101b44:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8101b46:	f7ff ff63 	bl	8101a10 <__NVIC_GetPriorityGrouping>
 8101b4a:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8101b4c:	687a      	ldr	r2, [r7, #4]
 8101b4e:	68b9      	ldr	r1, [r7, #8]
 8101b50:	6978      	ldr	r0, [r7, #20]
 8101b52:	f7ff ffb3 	bl	8101abc <NVIC_EncodePriority>
 8101b56:	4602      	mov	r2, r0
 8101b58:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8101b5c:	4611      	mov	r1, r2
 8101b5e:	4618      	mov	r0, r3
 8101b60:	f7ff ff82 	bl	8101a68 <__NVIC_SetPriority>
}
 8101b64:	bf00      	nop
 8101b66:	3718      	adds	r7, #24
 8101b68:	46bd      	mov	sp, r7
 8101b6a:	bd80      	pop	{r7, pc}

08101b6c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8101b6c:	b580      	push	{r7, lr}
 8101b6e:	b082      	sub	sp, #8
 8101b70:	af00      	add	r7, sp, #0
 8101b72:	4603      	mov	r3, r0
 8101b74:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8101b76:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101b7a:	4618      	mov	r0, r3
 8101b7c:	f7ff ff56 	bl	8101a2c <__NVIC_EnableIRQ>
}
 8101b80:	bf00      	nop
 8101b82:	3708      	adds	r7, #8
 8101b84:	46bd      	mov	sp, r7
 8101b86:	bd80      	pop	{r7, pc}

08101b88 <HAL_GetCurrentCPUID>:
/**
  * @brief  Returns the current CPU ID.
  * @retval CPU identifier
  */
uint32_t HAL_GetCurrentCPUID(void)
{
 8101b88:	b480      	push	{r7}
 8101b8a:	af00      	add	r7, sp, #0
  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)
 8101b8c:	4b06      	ldr	r3, [pc, #24]	@ (8101ba8 <HAL_GetCurrentCPUID+0x20>)
 8101b8e:	681b      	ldr	r3, [r3, #0]
 8101b90:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8101b94:	2b70      	cmp	r3, #112	@ 0x70
 8101b96:	d101      	bne.n	8101b9c <HAL_GetCurrentCPUID+0x14>
  {
    return  CM7_CPUID;
 8101b98:	2303      	movs	r3, #3
 8101b9a:	e000      	b.n	8101b9e <HAL_GetCurrentCPUID+0x16>
  }
  else
  {
    return CM4_CPUID;
 8101b9c:	2301      	movs	r3, #1
  }
}
 8101b9e:	4618      	mov	r0, r3
 8101ba0:	46bd      	mov	sp, r7
 8101ba2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101ba6:	4770      	bx	lr
 8101ba8:	e000ed00 	.word	0xe000ed00

08101bac <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
 8101bac:	b480      	push	{r7}
 8101bae:	b089      	sub	sp, #36	@ 0x24
 8101bb0:	af00      	add	r7, sp, #0
 8101bb2:	6078      	str	r0, [r7, #4]
 8101bb4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8101bb6:	2300      	movs	r3, #0
 8101bb8:	61fb      	str	r3, [r7, #28]
  uint32_t iocurrent;
  uint32_t temp;
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
 8101bba:	4b89      	ldr	r3, [pc, #548]	@ (8101de0 <HAL_GPIO_Init+0x234>)
 8101bbc:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8101bbe:	e194      	b.n	8101eea <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8101bc0:	683b      	ldr	r3, [r7, #0]
 8101bc2:	681a      	ldr	r2, [r3, #0]
 8101bc4:	2101      	movs	r1, #1
 8101bc6:	69fb      	ldr	r3, [r7, #28]
 8101bc8:	fa01 f303 	lsl.w	r3, r1, r3
 8101bcc:	4013      	ands	r3, r2
 8101bce:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 8101bd0:	693b      	ldr	r3, [r7, #16]
 8101bd2:	2b00      	cmp	r3, #0
 8101bd4:	f000 8186 	beq.w	8101ee4 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8101bd8:	683b      	ldr	r3, [r7, #0]
 8101bda:	685b      	ldr	r3, [r3, #4]
 8101bdc:	f003 0303 	and.w	r3, r3, #3
 8101be0:	2b01      	cmp	r3, #1
 8101be2:	d005      	beq.n	8101bf0 <HAL_GPIO_Init+0x44>
 8101be4:	683b      	ldr	r3, [r7, #0]
 8101be6:	685b      	ldr	r3, [r3, #4]
 8101be8:	f003 0303 	and.w	r3, r3, #3
 8101bec:	2b02      	cmp	r3, #2
 8101bee:	d130      	bne.n	8101c52 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8101bf0:	687b      	ldr	r3, [r7, #4]
 8101bf2:	689b      	ldr	r3, [r3, #8]
 8101bf4:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8101bf6:	69fb      	ldr	r3, [r7, #28]
 8101bf8:	005b      	lsls	r3, r3, #1
 8101bfa:	2203      	movs	r2, #3
 8101bfc:	fa02 f303 	lsl.w	r3, r2, r3
 8101c00:	43db      	mvns	r3, r3
 8101c02:	69ba      	ldr	r2, [r7, #24]
 8101c04:	4013      	ands	r3, r2
 8101c06:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8101c08:	683b      	ldr	r3, [r7, #0]
 8101c0a:	68da      	ldr	r2, [r3, #12]
 8101c0c:	69fb      	ldr	r3, [r7, #28]
 8101c0e:	005b      	lsls	r3, r3, #1
 8101c10:	fa02 f303 	lsl.w	r3, r2, r3
 8101c14:	69ba      	ldr	r2, [r7, #24]
 8101c16:	4313      	orrs	r3, r2
 8101c18:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8101c1a:	687b      	ldr	r3, [r7, #4]
 8101c1c:	69ba      	ldr	r2, [r7, #24]
 8101c1e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8101c20:	687b      	ldr	r3, [r7, #4]
 8101c22:	685b      	ldr	r3, [r3, #4]
 8101c24:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8101c26:	2201      	movs	r2, #1
 8101c28:	69fb      	ldr	r3, [r7, #28]
 8101c2a:	fa02 f303 	lsl.w	r3, r2, r3
 8101c2e:	43db      	mvns	r3, r3
 8101c30:	69ba      	ldr	r2, [r7, #24]
 8101c32:	4013      	ands	r3, r2
 8101c34:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8101c36:	683b      	ldr	r3, [r7, #0]
 8101c38:	685b      	ldr	r3, [r3, #4]
 8101c3a:	091b      	lsrs	r3, r3, #4
 8101c3c:	f003 0201 	and.w	r2, r3, #1
 8101c40:	69fb      	ldr	r3, [r7, #28]
 8101c42:	fa02 f303 	lsl.w	r3, r2, r3
 8101c46:	69ba      	ldr	r2, [r7, #24]
 8101c48:	4313      	orrs	r3, r2
 8101c4a:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8101c4c:	687b      	ldr	r3, [r7, #4]
 8101c4e:	69ba      	ldr	r2, [r7, #24]
 8101c50:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8101c52:	683b      	ldr	r3, [r7, #0]
 8101c54:	685b      	ldr	r3, [r3, #4]
 8101c56:	f003 0303 	and.w	r3, r3, #3
 8101c5a:	2b03      	cmp	r3, #3
 8101c5c:	d017      	beq.n	8101c8e <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8101c5e:	687b      	ldr	r3, [r7, #4]
 8101c60:	68db      	ldr	r3, [r3, #12]
 8101c62:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8101c64:	69fb      	ldr	r3, [r7, #28]
 8101c66:	005b      	lsls	r3, r3, #1
 8101c68:	2203      	movs	r2, #3
 8101c6a:	fa02 f303 	lsl.w	r3, r2, r3
 8101c6e:	43db      	mvns	r3, r3
 8101c70:	69ba      	ldr	r2, [r7, #24]
 8101c72:	4013      	ands	r3, r2
 8101c74:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8101c76:	683b      	ldr	r3, [r7, #0]
 8101c78:	689a      	ldr	r2, [r3, #8]
 8101c7a:	69fb      	ldr	r3, [r7, #28]
 8101c7c:	005b      	lsls	r3, r3, #1
 8101c7e:	fa02 f303 	lsl.w	r3, r2, r3
 8101c82:	69ba      	ldr	r2, [r7, #24]
 8101c84:	4313      	orrs	r3, r2
 8101c86:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8101c88:	687b      	ldr	r3, [r7, #4]
 8101c8a:	69ba      	ldr	r2, [r7, #24]
 8101c8c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8101c8e:	683b      	ldr	r3, [r7, #0]
 8101c90:	685b      	ldr	r3, [r3, #4]
 8101c92:	f003 0303 	and.w	r3, r3, #3
 8101c96:	2b02      	cmp	r3, #2
 8101c98:	d123      	bne.n	8101ce2 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8101c9a:	69fb      	ldr	r3, [r7, #28]
 8101c9c:	08da      	lsrs	r2, r3, #3
 8101c9e:	687b      	ldr	r3, [r7, #4]
 8101ca0:	3208      	adds	r2, #8
 8101ca2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8101ca6:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8101ca8:	69fb      	ldr	r3, [r7, #28]
 8101caa:	f003 0307 	and.w	r3, r3, #7
 8101cae:	009b      	lsls	r3, r3, #2
 8101cb0:	220f      	movs	r2, #15
 8101cb2:	fa02 f303 	lsl.w	r3, r2, r3
 8101cb6:	43db      	mvns	r3, r3
 8101cb8:	69ba      	ldr	r2, [r7, #24]
 8101cba:	4013      	ands	r3, r2
 8101cbc:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8101cbe:	683b      	ldr	r3, [r7, #0]
 8101cc0:	691a      	ldr	r2, [r3, #16]
 8101cc2:	69fb      	ldr	r3, [r7, #28]
 8101cc4:	f003 0307 	and.w	r3, r3, #7
 8101cc8:	009b      	lsls	r3, r3, #2
 8101cca:	fa02 f303 	lsl.w	r3, r2, r3
 8101cce:	69ba      	ldr	r2, [r7, #24]
 8101cd0:	4313      	orrs	r3, r2
 8101cd2:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8101cd4:	69fb      	ldr	r3, [r7, #28]
 8101cd6:	08da      	lsrs	r2, r3, #3
 8101cd8:	687b      	ldr	r3, [r7, #4]
 8101cda:	3208      	adds	r2, #8
 8101cdc:	69b9      	ldr	r1, [r7, #24]
 8101cde:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8101ce2:	687b      	ldr	r3, [r7, #4]
 8101ce4:	681b      	ldr	r3, [r3, #0]
 8101ce6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8101ce8:	69fb      	ldr	r3, [r7, #28]
 8101cea:	005b      	lsls	r3, r3, #1
 8101cec:	2203      	movs	r2, #3
 8101cee:	fa02 f303 	lsl.w	r3, r2, r3
 8101cf2:	43db      	mvns	r3, r3
 8101cf4:	69ba      	ldr	r2, [r7, #24]
 8101cf6:	4013      	ands	r3, r2
 8101cf8:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8101cfa:	683b      	ldr	r3, [r7, #0]
 8101cfc:	685b      	ldr	r3, [r3, #4]
 8101cfe:	f003 0203 	and.w	r2, r3, #3
 8101d02:	69fb      	ldr	r3, [r7, #28]
 8101d04:	005b      	lsls	r3, r3, #1
 8101d06:	fa02 f303 	lsl.w	r3, r2, r3
 8101d0a:	69ba      	ldr	r2, [r7, #24]
 8101d0c:	4313      	orrs	r3, r2
 8101d0e:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8101d10:	687b      	ldr	r3, [r7, #4]
 8101d12:	69ba      	ldr	r2, [r7, #24]
 8101d14:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8101d16:	683b      	ldr	r3, [r7, #0]
 8101d18:	685b      	ldr	r3, [r3, #4]
 8101d1a:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8101d1e:	2b00      	cmp	r3, #0
 8101d20:	f000 80e0 	beq.w	8101ee4 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8101d24:	4b2f      	ldr	r3, [pc, #188]	@ (8101de4 <HAL_GPIO_Init+0x238>)
 8101d26:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8101d2a:	4a2e      	ldr	r2, [pc, #184]	@ (8101de4 <HAL_GPIO_Init+0x238>)
 8101d2c:	f043 0302 	orr.w	r3, r3, #2
 8101d30:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 8101d34:	4b2b      	ldr	r3, [pc, #172]	@ (8101de4 <HAL_GPIO_Init+0x238>)
 8101d36:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8101d3a:	f003 0302 	and.w	r3, r3, #2
 8101d3e:	60fb      	str	r3, [r7, #12]
 8101d40:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8101d42:	4a29      	ldr	r2, [pc, #164]	@ (8101de8 <HAL_GPIO_Init+0x23c>)
 8101d44:	69fb      	ldr	r3, [r7, #28]
 8101d46:	089b      	lsrs	r3, r3, #2
 8101d48:	3302      	adds	r3, #2
 8101d4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8101d4e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8101d50:	69fb      	ldr	r3, [r7, #28]
 8101d52:	f003 0303 	and.w	r3, r3, #3
 8101d56:	009b      	lsls	r3, r3, #2
 8101d58:	220f      	movs	r2, #15
 8101d5a:	fa02 f303 	lsl.w	r3, r2, r3
 8101d5e:	43db      	mvns	r3, r3
 8101d60:	69ba      	ldr	r2, [r7, #24]
 8101d62:	4013      	ands	r3, r2
 8101d64:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8101d66:	687b      	ldr	r3, [r7, #4]
 8101d68:	4a20      	ldr	r2, [pc, #128]	@ (8101dec <HAL_GPIO_Init+0x240>)
 8101d6a:	4293      	cmp	r3, r2
 8101d6c:	d052      	beq.n	8101e14 <HAL_GPIO_Init+0x268>
 8101d6e:	687b      	ldr	r3, [r7, #4]
 8101d70:	4a1f      	ldr	r2, [pc, #124]	@ (8101df0 <HAL_GPIO_Init+0x244>)
 8101d72:	4293      	cmp	r3, r2
 8101d74:	d031      	beq.n	8101dda <HAL_GPIO_Init+0x22e>
 8101d76:	687b      	ldr	r3, [r7, #4]
 8101d78:	4a1e      	ldr	r2, [pc, #120]	@ (8101df4 <HAL_GPIO_Init+0x248>)
 8101d7a:	4293      	cmp	r3, r2
 8101d7c:	d02b      	beq.n	8101dd6 <HAL_GPIO_Init+0x22a>
 8101d7e:	687b      	ldr	r3, [r7, #4]
 8101d80:	4a1d      	ldr	r2, [pc, #116]	@ (8101df8 <HAL_GPIO_Init+0x24c>)
 8101d82:	4293      	cmp	r3, r2
 8101d84:	d025      	beq.n	8101dd2 <HAL_GPIO_Init+0x226>
 8101d86:	687b      	ldr	r3, [r7, #4]
 8101d88:	4a1c      	ldr	r2, [pc, #112]	@ (8101dfc <HAL_GPIO_Init+0x250>)
 8101d8a:	4293      	cmp	r3, r2
 8101d8c:	d01f      	beq.n	8101dce <HAL_GPIO_Init+0x222>
 8101d8e:	687b      	ldr	r3, [r7, #4]
 8101d90:	4a1b      	ldr	r2, [pc, #108]	@ (8101e00 <HAL_GPIO_Init+0x254>)
 8101d92:	4293      	cmp	r3, r2
 8101d94:	d019      	beq.n	8101dca <HAL_GPIO_Init+0x21e>
 8101d96:	687b      	ldr	r3, [r7, #4]
 8101d98:	4a1a      	ldr	r2, [pc, #104]	@ (8101e04 <HAL_GPIO_Init+0x258>)
 8101d9a:	4293      	cmp	r3, r2
 8101d9c:	d013      	beq.n	8101dc6 <HAL_GPIO_Init+0x21a>
 8101d9e:	687b      	ldr	r3, [r7, #4]
 8101da0:	4a19      	ldr	r2, [pc, #100]	@ (8101e08 <HAL_GPIO_Init+0x25c>)
 8101da2:	4293      	cmp	r3, r2
 8101da4:	d00d      	beq.n	8101dc2 <HAL_GPIO_Init+0x216>
 8101da6:	687b      	ldr	r3, [r7, #4]
 8101da8:	4a18      	ldr	r2, [pc, #96]	@ (8101e0c <HAL_GPIO_Init+0x260>)
 8101daa:	4293      	cmp	r3, r2
 8101dac:	d007      	beq.n	8101dbe <HAL_GPIO_Init+0x212>
 8101dae:	687b      	ldr	r3, [r7, #4]
 8101db0:	4a17      	ldr	r2, [pc, #92]	@ (8101e10 <HAL_GPIO_Init+0x264>)
 8101db2:	4293      	cmp	r3, r2
 8101db4:	d101      	bne.n	8101dba <HAL_GPIO_Init+0x20e>
 8101db6:	2309      	movs	r3, #9
 8101db8:	e02d      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dba:	230a      	movs	r3, #10
 8101dbc:	e02b      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dbe:	2308      	movs	r3, #8
 8101dc0:	e029      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dc2:	2307      	movs	r3, #7
 8101dc4:	e027      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dc6:	2306      	movs	r3, #6
 8101dc8:	e025      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dca:	2305      	movs	r3, #5
 8101dcc:	e023      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dce:	2304      	movs	r3, #4
 8101dd0:	e021      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dd2:	2303      	movs	r3, #3
 8101dd4:	e01f      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dd6:	2302      	movs	r3, #2
 8101dd8:	e01d      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dda:	2301      	movs	r3, #1
 8101ddc:	e01b      	b.n	8101e16 <HAL_GPIO_Init+0x26a>
 8101dde:	bf00      	nop
 8101de0:	580000c0 	.word	0x580000c0
 8101de4:	58024400 	.word	0x58024400
 8101de8:	58000400 	.word	0x58000400
 8101dec:	58020000 	.word	0x58020000
 8101df0:	58020400 	.word	0x58020400
 8101df4:	58020800 	.word	0x58020800
 8101df8:	58020c00 	.word	0x58020c00
 8101dfc:	58021000 	.word	0x58021000
 8101e00:	58021400 	.word	0x58021400
 8101e04:	58021800 	.word	0x58021800
 8101e08:	58021c00 	.word	0x58021c00
 8101e0c:	58022000 	.word	0x58022000
 8101e10:	58022400 	.word	0x58022400
 8101e14:	2300      	movs	r3, #0
 8101e16:	69fa      	ldr	r2, [r7, #28]
 8101e18:	f002 0203 	and.w	r2, r2, #3
 8101e1c:	0092      	lsls	r2, r2, #2
 8101e1e:	4093      	lsls	r3, r2
 8101e20:	69ba      	ldr	r2, [r7, #24]
 8101e22:	4313      	orrs	r3, r2
 8101e24:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8101e26:	4938      	ldr	r1, [pc, #224]	@ (8101f08 <HAL_GPIO_Init+0x35c>)
 8101e28:	69fb      	ldr	r3, [r7, #28]
 8101e2a:	089b      	lsrs	r3, r3, #2
 8101e2c:	3302      	adds	r3, #2
 8101e2e:	69ba      	ldr	r2, [r7, #24]
 8101e30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8101e34:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8101e38:	681b      	ldr	r3, [r3, #0]
 8101e3a:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101e3c:	693b      	ldr	r3, [r7, #16]
 8101e3e:	43db      	mvns	r3, r3
 8101e40:	69ba      	ldr	r2, [r7, #24]
 8101e42:	4013      	ands	r3, r2
 8101e44:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8101e46:	683b      	ldr	r3, [r7, #0]
 8101e48:	685b      	ldr	r3, [r3, #4]
 8101e4a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8101e4e:	2b00      	cmp	r3, #0
 8101e50:	d003      	beq.n	8101e5a <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8101e52:	69ba      	ldr	r2, [r7, #24]
 8101e54:	693b      	ldr	r3, [r7, #16]
 8101e56:	4313      	orrs	r3, r2
 8101e58:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 8101e5a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8101e5e:	69bb      	ldr	r3, [r7, #24]
 8101e60:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8101e62:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8101e66:	685b      	ldr	r3, [r3, #4]
 8101e68:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101e6a:	693b      	ldr	r3, [r7, #16]
 8101e6c:	43db      	mvns	r3, r3
 8101e6e:	69ba      	ldr	r2, [r7, #24]
 8101e70:	4013      	ands	r3, r2
 8101e72:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8101e74:	683b      	ldr	r3, [r7, #0]
 8101e76:	685b      	ldr	r3, [r3, #4]
 8101e78:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8101e7c:	2b00      	cmp	r3, #0
 8101e7e:	d003      	beq.n	8101e88 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8101e80:	69ba      	ldr	r2, [r7, #24]
 8101e82:	693b      	ldr	r3, [r7, #16]
 8101e84:	4313      	orrs	r3, r2
 8101e86:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 8101e88:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8101e8c:	69bb      	ldr	r3, [r7, #24]
 8101e8e:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8101e90:	697b      	ldr	r3, [r7, #20]
 8101e92:	685b      	ldr	r3, [r3, #4]
 8101e94:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101e96:	693b      	ldr	r3, [r7, #16]
 8101e98:	43db      	mvns	r3, r3
 8101e9a:	69ba      	ldr	r2, [r7, #24]
 8101e9c:	4013      	ands	r3, r2
 8101e9e:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8101ea0:	683b      	ldr	r3, [r7, #0]
 8101ea2:	685b      	ldr	r3, [r3, #4]
 8101ea4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8101ea8:	2b00      	cmp	r3, #0
 8101eaa:	d003      	beq.n	8101eb4 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8101eac:	69ba      	ldr	r2, [r7, #24]
 8101eae:	693b      	ldr	r3, [r7, #16]
 8101eb0:	4313      	orrs	r3, r2
 8101eb2:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8101eb4:	697b      	ldr	r3, [r7, #20]
 8101eb6:	69ba      	ldr	r2, [r7, #24]
 8101eb8:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8101eba:	697b      	ldr	r3, [r7, #20]
 8101ebc:	681b      	ldr	r3, [r3, #0]
 8101ebe:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101ec0:	693b      	ldr	r3, [r7, #16]
 8101ec2:	43db      	mvns	r3, r3
 8101ec4:	69ba      	ldr	r2, [r7, #24]
 8101ec6:	4013      	ands	r3, r2
 8101ec8:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8101eca:	683b      	ldr	r3, [r7, #0]
 8101ecc:	685b      	ldr	r3, [r3, #4]
 8101ece:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8101ed2:	2b00      	cmp	r3, #0
 8101ed4:	d003      	beq.n	8101ede <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 8101ed6:	69ba      	ldr	r2, [r7, #24]
 8101ed8:	693b      	ldr	r3, [r7, #16]
 8101eda:	4313      	orrs	r3, r2
 8101edc:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8101ede:	697b      	ldr	r3, [r7, #20]
 8101ee0:	69ba      	ldr	r2, [r7, #24]
 8101ee2:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8101ee4:	69fb      	ldr	r3, [r7, #28]
 8101ee6:	3301      	adds	r3, #1
 8101ee8:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8101eea:	683b      	ldr	r3, [r7, #0]
 8101eec:	681a      	ldr	r2, [r3, #0]
 8101eee:	69fb      	ldr	r3, [r7, #28]
 8101ef0:	fa22 f303 	lsr.w	r3, r2, r3
 8101ef4:	2b00      	cmp	r3, #0
 8101ef6:	f47f ae63 	bne.w	8101bc0 <HAL_GPIO_Init+0x14>
  }
}
 8101efa:	bf00      	nop
 8101efc:	bf00      	nop
 8101efe:	3724      	adds	r7, #36	@ 0x24
 8101f00:	46bd      	mov	sp, r7
 8101f02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101f06:	4770      	bx	lr
 8101f08:	58000400 	.word	0x58000400

08101f0c <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
 8101f0c:	b480      	push	{r7}
 8101f0e:	b083      	sub	sp, #12
 8101f10:	af00      	add	r7, sp, #0
 8101f12:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
 8101f14:	4b05      	ldr	r3, [pc, #20]	@ (8101f2c <HAL_HSEM_ActivateNotification+0x20>)
 8101f16:	681a      	ldr	r2, [r3, #0]
 8101f18:	4904      	ldr	r1, [pc, #16]	@ (8101f2c <HAL_HSEM_ActivateNotification+0x20>)
 8101f1a:	687b      	ldr	r3, [r7, #4]
 8101f1c:	4313      	orrs	r3, r2
 8101f1e:	600b      	str	r3, [r1, #0]
#endif
}
 8101f20:	bf00      	nop
 8101f22:	370c      	adds	r7, #12
 8101f24:	46bd      	mov	sp, r7
 8101f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101f2a:	4770      	bx	lr
 8101f2c:	58026510 	.word	0x58026510

08101f30 <HAL_MMC_Init>:
            MMC_HandleTypeDef and create the associated handle.
  * @param  hmmc: Pointer to the MMC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_Init(MMC_HandleTypeDef *hmmc)
{
 8101f30:	b580      	push	{r7, lr}
 8101f32:	b082      	sub	sp, #8
 8101f34:	af00      	add	r7, sp, #0
 8101f36:	6078      	str	r0, [r7, #4]
  /* Check the MMC handle allocation */
  if (hmmc == NULL)
 8101f38:	687b      	ldr	r3, [r7, #4]
 8101f3a:	2b00      	cmp	r3, #0
 8101f3c:	d101      	bne.n	8101f42 <HAL_MMC_Init+0x12>
  {
    return HAL_ERROR;
 8101f3e:	2301      	movs	r3, #1
 8101f40:	e031      	b.n	8101fa6 <HAL_MMC_Init+0x76>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hmmc->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hmmc->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hmmc->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hmmc->Init.ClockDiv));

  if (hmmc->State == HAL_MMC_STATE_RESET)
 8101f42:	687b      	ldr	r3, [r7, #4]
 8101f44:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8101f48:	b2db      	uxtb	r3, r3
 8101f4a:	2b00      	cmp	r3, #0
 8101f4c:	d105      	bne.n	8101f5a <HAL_MMC_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hmmc->Lock = HAL_UNLOCKED;
 8101f4e:	687b      	ldr	r3, [r7, #4]
 8101f50:	2200      	movs	r2, #0
 8101f52:	761a      	strb	r2, [r3, #24]

    /* Init the low level hardware */
    hmmc->MspInitCallback(hmmc);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_MMC_MspInit(hmmc);
 8101f54:	6878      	ldr	r0, [r7, #4]
 8101f56:	f7ff fab5 	bl	81014c4 <HAL_MMC_MspInit>
#endif /* USE_HAL_MMC_REGISTER_CALLBACKS */
  }

  hmmc->State = HAL_MMC_STATE_BUSY;
 8101f5a:	687b      	ldr	r3, [r7, #4]
 8101f5c:	2203      	movs	r2, #3
 8101f5e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Initialize the Card parameters */
  if (HAL_MMC_InitCard(hmmc) == HAL_ERROR)
 8101f62:	6878      	ldr	r0, [r7, #4]
 8101f64:	f000 f824 	bl	8101fb0 <HAL_MMC_InitCard>
 8101f68:	4603      	mov	r3, r0
 8101f6a:	2b01      	cmp	r3, #1
 8101f6c:	d101      	bne.n	8101f72 <HAL_MMC_Init+0x42>
  {
    return HAL_ERROR;
 8101f6e:	2301      	movs	r3, #1
 8101f70:	e019      	b.n	8101fa6 <HAL_MMC_Init+0x76>
  }

  /* Initialize the error code */
  hmmc->ErrorCode = HAL_DMA_ERROR_NONE;
 8101f72:	687b      	ldr	r3, [r7, #4]
 8101f74:	2200      	movs	r2, #0
 8101f76:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Initialize the MMC operation */
  hmmc->Context = MMC_CONTEXT_NONE;
 8101f78:	687b      	ldr	r3, [r7, #4]
 8101f7a:	2200      	movs	r2, #0
 8101f7c:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Initialize the MMC state */
  hmmc->State = HAL_MMC_STATE_READY;
 8101f7e:	687b      	ldr	r3, [r7, #4]
 8101f80:	2201      	movs	r2, #1
 8101f82:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Configure bus width */
  if (hmmc->Init.BusWide != SDMMC_BUS_WIDE_1B)
 8101f86:	687b      	ldr	r3, [r7, #4]
 8101f88:	68db      	ldr	r3, [r3, #12]
 8101f8a:	2b00      	cmp	r3, #0
 8101f8c:	d00a      	beq.n	8101fa4 <HAL_MMC_Init+0x74>
  {
    if (HAL_MMC_ConfigWideBusOperation(hmmc, hmmc->Init.BusWide) != HAL_OK)
 8101f8e:	687b      	ldr	r3, [r7, #4]
 8101f90:	68db      	ldr	r3, [r3, #12]
 8101f92:	4619      	mov	r1, r3
 8101f94:	6878      	ldr	r0, [r7, #4]
 8101f96:	f000 fd15 	bl	81029c4 <HAL_MMC_ConfigWideBusOperation>
 8101f9a:	4603      	mov	r3, r0
 8101f9c:	2b00      	cmp	r3, #0
 8101f9e:	d001      	beq.n	8101fa4 <HAL_MMC_Init+0x74>
    {
      return HAL_ERROR;
 8101fa0:	2301      	movs	r3, #1
 8101fa2:	e000      	b.n	8101fa6 <HAL_MMC_Init+0x76>
    }
  }

  return HAL_OK;
 8101fa4:	2300      	movs	r3, #0
}
 8101fa6:	4618      	mov	r0, r3
 8101fa8:	3708      	adds	r7, #8
 8101faa:	46bd      	mov	sp, r7
 8101fac:	bd80      	pop	{r7, pc}
	...

08101fb0 <HAL_MMC_InitCard>:
  * @note   This function initializes the MMC card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_InitCard(MMC_HandleTypeDef *hmmc)
{
 8101fb0:	b590      	push	{r4, r7, lr}
 8101fb2:	b08d      	sub	sp, #52	@ 0x34
 8101fb4:	af02      	add	r7, sp, #8
 8101fb6:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  MMC_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for MMC card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8101fb8:	2300      	movs	r3, #0
 8101fba:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 8101fbc:	2300      	movs	r3, #0
 8101fbe:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 8101fc0:	2300      	movs	r3, #0
 8101fc2:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 8101fc4:	2300      	movs	r3, #0
 8101fc6:	61bb      	str	r3, [r7, #24]

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
 8101fc8:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
 8101fcc:	f04f 0100 	mov.w	r1, #0
 8101fd0:	f004 f8a4 	bl	810611c <HAL_RCCEx_GetPeriphCLKFreq>
 8101fd4:	6278      	str	r0, [r7, #36]	@ 0x24
  if (sdmmc_clk == 0U)
 8101fd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8101fd8:	2b00      	cmp	r3, #0
 8101fda:	d109      	bne.n	8101ff0 <HAL_MMC_InitCard+0x40>
  {
    hmmc->State = HAL_MMC_STATE_READY;
 8101fdc:	687b      	ldr	r3, [r7, #4]
 8101fde:	2201      	movs	r2, #1
 8101fe0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hmmc->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
 8101fe4:	687b      	ldr	r3, [r7, #4]
 8101fe6:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8101fea:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8101fec:	2301      	movs	r3, #1
 8101fee:	e070      	b.n	81020d2 <HAL_MMC_InitCard+0x122>
  }
  Init.ClockDiv = sdmmc_clk / (2U * MMC_INIT_FREQ);
 8101ff0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8101ff2:	0a1b      	lsrs	r3, r3, #8
 8101ff4:	4a39      	ldr	r2, [pc, #228]	@ (81020dc <HAL_MMC_InitCard+0x12c>)
 8101ff6:	fba2 2303 	umull	r2, r3, r2, r3
 8101ffa:	091b      	lsrs	r3, r3, #4
 8101ffc:	61fb      	str	r3, [r7, #28]
#if (USE_SD_TRANSCEIVER != 0U)
  Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
#endif /* USE_SD_TRANSCEIVER */

  /* Initialize SDMMC peripheral interface with default configuration */
  (void)SDMMC_Init(hmmc->Instance, Init);
 8101ffe:	687b      	ldr	r3, [r7, #4]
 8102000:	681c      	ldr	r4, [r3, #0]
 8102002:	466a      	mov	r2, sp
 8102004:	f107 0318 	add.w	r3, r7, #24
 8102008:	e893 0003 	ldmia.w	r3, {r0, r1}
 810200c:	e882 0003 	stmia.w	r2, {r0, r1}
 8102010:	f107 030c 	add.w	r3, r7, #12
 8102014:	cb0e      	ldmia	r3, {r1, r2, r3}
 8102016:	4620      	mov	r0, r4
 8102018:	f006 fe26 	bl	8108c68 <SDMMC_Init>

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hmmc->Instance);
 810201c:	687b      	ldr	r3, [r7, #4]
 810201e:	681b      	ldr	r3, [r3, #0]
 8102020:	4618      	mov	r0, r3
 8102022:	f006 fe69 	bl	8108cf8 <SDMMC_PowerState_ON>

  /* wait 74 Cycles: required power up waiting time before starting
     the MMC initialization sequence */
  if (Init.ClockDiv != 0U)
 8102026:	69fb      	ldr	r3, [r7, #28]
 8102028:	2b00      	cmp	r3, #0
 810202a:	d005      	beq.n	8102038 <HAL_MMC_InitCard+0x88>
  {
    sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
 810202c:	69fb      	ldr	r3, [r7, #28]
 810202e:	005b      	lsls	r3, r3, #1
 8102030:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8102032:	fbb2 f3f3 	udiv	r3, r2, r3
 8102036:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (sdmmc_clk != 0U)
 8102038:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810203a:	2b00      	cmp	r3, #0
 810203c:	d007      	beq.n	810204e <HAL_MMC_InitCard+0x9e>
  {
    HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
 810203e:	4a28      	ldr	r2, [pc, #160]	@ (81020e0 <HAL_MMC_InitCard+0x130>)
 8102040:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8102042:	fbb2 f3f3 	udiv	r3, r2, r3
 8102046:	3301      	adds	r3, #1
 8102048:	4618      	mov	r0, r3
 810204a:	f7ff fc99 	bl	8101980 <HAL_Delay>
  }

  /* Identify card operating voltage */
  errorstate = MMC_PowerON(hmmc);
 810204e:	6878      	ldr	r0, [r7, #4]
 8102050:	f000 fe82 	bl	8102d58 <MMC_PowerON>
 8102054:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102056:	6a3b      	ldr	r3, [r7, #32]
 8102058:	2b00      	cmp	r3, #0
 810205a:	d00b      	beq.n	8102074 <HAL_MMC_InitCard+0xc4>
  {
    hmmc->State = HAL_MMC_STATE_READY;
 810205c:	687b      	ldr	r3, [r7, #4]
 810205e:	2201      	movs	r2, #1
 8102060:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hmmc->ErrorCode |= errorstate;
 8102064:	687b      	ldr	r3, [r7, #4]
 8102066:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102068:	6a3b      	ldr	r3, [r7, #32]
 810206a:	431a      	orrs	r2, r3
 810206c:	687b      	ldr	r3, [r7, #4]
 810206e:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8102070:	2301      	movs	r3, #1
 8102072:	e02e      	b.n	81020d2 <HAL_MMC_InitCard+0x122>
  }

  /* Card initialization */
  errorstate = MMC_InitCard(hmmc);
 8102074:	6878      	ldr	r0, [r7, #4]
 8102076:	f000 fd71 	bl	8102b5c <MMC_InitCard>
 810207a:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
 810207c:	6a3b      	ldr	r3, [r7, #32]
 810207e:	2b00      	cmp	r3, #0
 8102080:	d00b      	beq.n	810209a <HAL_MMC_InitCard+0xea>
  {
    hmmc->State = HAL_MMC_STATE_READY;
 8102082:	687b      	ldr	r3, [r7, #4]
 8102084:	2201      	movs	r2, #1
 8102086:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hmmc->ErrorCode |= errorstate;
 810208a:	687b      	ldr	r3, [r7, #4]
 810208c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 810208e:	6a3b      	ldr	r3, [r7, #32]
 8102090:	431a      	orrs	r2, r3
 8102092:	687b      	ldr	r3, [r7, #4]
 8102094:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8102096:	2301      	movs	r3, #1
 8102098:	e01b      	b.n	81020d2 <HAL_MMC_InitCard+0x122>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hmmc->Instance, MMC_BLOCKSIZE);
 810209a:	687b      	ldr	r3, [r7, #4]
 810209c:	681b      	ldr	r3, [r3, #0]
 810209e:	f44f 7100 	mov.w	r1, #512	@ 0x200
 81020a2:	4618      	mov	r0, r3
 81020a4:	f006 febe 	bl	8108e24 <SDMMC_CmdBlockLength>
 81020a8:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
 81020aa:	6a3b      	ldr	r3, [r7, #32]
 81020ac:	2b00      	cmp	r3, #0
 81020ae:	d00f      	beq.n	81020d0 <HAL_MMC_InitCard+0x120>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 81020b0:	687b      	ldr	r3, [r7, #4]
 81020b2:	681b      	ldr	r3, [r3, #0]
 81020b4:	4a0b      	ldr	r2, [pc, #44]	@ (81020e4 <HAL_MMC_InitCard+0x134>)
 81020b6:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= errorstate;
 81020b8:	687b      	ldr	r3, [r7, #4]
 81020ba:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 81020bc:	6a3b      	ldr	r3, [r7, #32]
 81020be:	431a      	orrs	r2, r3
 81020c0:	687b      	ldr	r3, [r7, #4]
 81020c2:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 81020c4:	687b      	ldr	r3, [r7, #4]
 81020c6:	2201      	movs	r2, #1
 81020c8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 81020cc:	2301      	movs	r3, #1
 81020ce:	e000      	b.n	81020d2 <HAL_MMC_InitCard+0x122>
  }

  return HAL_OK;
 81020d0:	2300      	movs	r3, #0
}
 81020d2:	4618      	mov	r0, r3
 81020d4:	372c      	adds	r7, #44	@ 0x2c
 81020d6:	46bd      	mov	sp, r7
 81020d8:	bd90      	pop	{r4, r7, pc}
 81020da:	bf00      	nop
 81020dc:	014f8b59 	.word	0x014f8b59
 81020e0:	00012110 	.word	0x00012110
 81020e4:	1fe00fff 	.word	0x1fe00fff

081020e8 <HAL_MMC_IRQHandler>:
  * @brief  This function handles MMC card interrupt request.
  * @param  hmmc: Pointer to MMC handle
  * @retval None
  */
void HAL_MMC_IRQHandler(MMC_HandleTypeDef *hmmc)
{
 81020e8:	b580      	push	{r7, lr}
 81020ea:	b084      	sub	sp, #16
 81020ec:	af00      	add	r7, sp, #0
 81020ee:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  uint32_t context = hmmc->Context;
 81020f0:	687b      	ldr	r3, [r7, #4]
 81020f2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81020f4:	60fb      	str	r3, [r7, #12]

  /* Check for SDMMC interrupt flags */
  if ((__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & MMC_CONTEXT_IT) != 0U))
 81020f6:	687b      	ldr	r3, [r7, #4]
 81020f8:	681b      	ldr	r3, [r3, #0]
 81020fa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81020fc:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8102100:	2b00      	cmp	r3, #0
 8102102:	d008      	beq.n	8102116 <HAL_MMC_IRQHandler+0x2e>
 8102104:	68fb      	ldr	r3, [r7, #12]
 8102106:	f003 0308 	and.w	r3, r3, #8
 810210a:	2b00      	cmp	r3, #0
 810210c:	d003      	beq.n	8102116 <HAL_MMC_IRQHandler+0x2e>
  {
    MMC_Read_IT(hmmc);
 810210e:	6878      	ldr	r0, [r7, #4]
 8102110:	f000 ff66 	bl	8102fe0 <MMC_Read_IT>
 8102114:	e194      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
  }

  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DATAEND) != RESET)
 8102116:	687b      	ldr	r3, [r7, #4]
 8102118:	681b      	ldr	r3, [r3, #0]
 810211a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810211c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8102120:	2b00      	cmp	r3, #0
 8102122:	f000 80ac 	beq.w	810227e <HAL_MMC_IRQHandler+0x196>
  {
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_FLAG_DATAEND);
 8102126:	687b      	ldr	r3, [r7, #4]
 8102128:	681b      	ldr	r3, [r3, #0]
 810212a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 810212e:	639a      	str	r2, [r3, #56]	@ 0x38

    __HAL_MMC_DISABLE_IT(hmmc, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
 8102130:	687b      	ldr	r3, [r7, #4]
 8102132:	681b      	ldr	r3, [r3, #0]
 8102134:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8102136:	687a      	ldr	r2, [r7, #4]
 8102138:	6812      	ldr	r2, [r2, #0]
 810213a:	f423 4341 	bic.w	r3, r3, #49408	@ 0xc100
 810213e:	f023 033a 	bic.w	r3, r3, #58	@ 0x3a
 8102142:	63d3      	str	r3, [r2, #60]	@ 0x3c
                         SDMMC_IT_TXUNDERR | SDMMC_IT_RXOVERR  | SDMMC_IT_TXFIFOHE | \
                         SDMMC_IT_RXFIFOHF);

    __HAL_MMC_DISABLE_IT(hmmc, SDMMC_IT_IDMABTC);
 8102144:	687b      	ldr	r3, [r7, #4]
 8102146:	681b      	ldr	r3, [r3, #0]
 8102148:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 810214a:	687b      	ldr	r3, [r7, #4]
 810214c:	681b      	ldr	r3, [r3, #0]
 810214e:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 8102152:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
 8102154:	687b      	ldr	r3, [r7, #4]
 8102156:	681b      	ldr	r3, [r3, #0]
 8102158:	68da      	ldr	r2, [r3, #12]
 810215a:	687b      	ldr	r3, [r7, #4]
 810215c:	681b      	ldr	r3, [r3, #0]
 810215e:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8102162:	60da      	str	r2, [r3, #12]

    if ((context & MMC_CONTEXT_DMA) != 0U)
 8102164:	68fb      	ldr	r3, [r7, #12]
 8102166:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810216a:	2b00      	cmp	r3, #0
 810216c:	d04b      	beq.n	8102206 <HAL_MMC_IRQHandler+0x11e>
    {
      hmmc->Instance->DLEN = 0;
 810216e:	687b      	ldr	r3, [r7, #4]
 8102170:	681b      	ldr	r3, [r3, #0]
 8102172:	2200      	movs	r2, #0
 8102174:	629a      	str	r2, [r3, #40]	@ 0x28
      hmmc->Instance->DCTRL = 0;
 8102176:	687b      	ldr	r3, [r7, #4]
 8102178:	681b      	ldr	r3, [r3, #0]
 810217a:	2200      	movs	r2, #0
 810217c:	62da      	str	r2, [r3, #44]	@ 0x2c
      hmmc->Instance->IDMACTRL = SDMMC_DISABLE_IDMA ;
 810217e:	687b      	ldr	r3, [r7, #4]
 8102180:	681b      	ldr	r3, [r3, #0]
 8102182:	2200      	movs	r2, #0
 8102184:	651a      	str	r2, [r3, #80]	@ 0x50

      /* Stop Transfer for Write Multi blocks or Read Multi blocks */
      if (((context & MMC_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & MMC_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8102186:	68fb      	ldr	r3, [r7, #12]
 8102188:	f003 0302 	and.w	r3, r3, #2
 810218c:	2b00      	cmp	r3, #0
 810218e:	d104      	bne.n	810219a <HAL_MMC_IRQHandler+0xb2>
 8102190:	68fb      	ldr	r3, [r7, #12]
 8102192:	f003 0320 	and.w	r3, r3, #32
 8102196:	2b00      	cmp	r3, #0
 8102198:	d011      	beq.n	81021be <HAL_MMC_IRQHandler+0xd6>
      {
        errorstate = SDMMC_CmdStopTransfer(hmmc->Instance);
 810219a:	687b      	ldr	r3, [r7, #4]
 810219c:	681b      	ldr	r3, [r3, #0]
 810219e:	4618      	mov	r0, r3
 81021a0:	f006 fe64 	bl	8108e6c <SDMMC_CmdStopTransfer>
 81021a4:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_MMC_ERROR_NONE)
 81021a6:	68bb      	ldr	r3, [r7, #8]
 81021a8:	2b00      	cmp	r3, #0
 81021aa:	d008      	beq.n	81021be <HAL_MMC_IRQHandler+0xd6>
        {
          hmmc->ErrorCode |= errorstate;
 81021ac:	687b      	ldr	r3, [r7, #4]
 81021ae:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 81021b0:	68bb      	ldr	r3, [r7, #8]
 81021b2:	431a      	orrs	r2, r3
 81021b4:	687b      	ldr	r3, [r7, #4]
 81021b6:	635a      	str	r2, [r3, #52]	@ 0x34
#if defined (USE_HAL_MMC_REGISTER_CALLBACKS) && (USE_HAL_MMC_REGISTER_CALLBACKS == 1U)
          hmmc->ErrorCallback(hmmc);
#else
          HAL_MMC_ErrorCallback(hmmc);
 81021b8:	6878      	ldr	r0, [r7, #4]
 81021ba:	f000 f959 	bl	8102470 <HAL_MMC_ErrorCallback>
#endif /* USE_HAL_MMC_REGISTER_CALLBACKS */
        }
      }

      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
 81021be:	687b      	ldr	r3, [r7, #4]
 81021c0:	681b      	ldr	r3, [r3, #0]
 81021c2:	4a9c      	ldr	r2, [pc, #624]	@ (8102434 <HAL_MMC_IRQHandler+0x34c>)
 81021c4:	639a      	str	r2, [r3, #56]	@ 0x38

      hmmc->State = HAL_MMC_STATE_READY;
 81021c6:	687b      	ldr	r3, [r7, #4]
 81021c8:	2201      	movs	r2, #1
 81021ca:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      if (((context & MMC_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & MMC_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 81021ce:	68fb      	ldr	r3, [r7, #12]
 81021d0:	f003 0310 	and.w	r3, r3, #16
 81021d4:	2b00      	cmp	r3, #0
 81021d6:	d104      	bne.n	81021e2 <HAL_MMC_IRQHandler+0xfa>
 81021d8:	68fb      	ldr	r3, [r7, #12]
 81021da:	f003 0320 	and.w	r3, r3, #32
 81021de:	2b00      	cmp	r3, #0
 81021e0:	d002      	beq.n	81021e8 <HAL_MMC_IRQHandler+0x100>
      {
#if defined (USE_HAL_MMC_REGISTER_CALLBACKS) && (USE_HAL_MMC_REGISTER_CALLBACKS == 1U)
        hmmc->TxCpltCallback(hmmc);
#else
        HAL_MMC_TxCpltCallback(hmmc);
 81021e2:	6878      	ldr	r0, [r7, #4]
 81021e4:	f000 f930 	bl	8102448 <HAL_MMC_TxCpltCallback>
#endif /* USE_HAL_MMC_REGISTER_CALLBACKS */
      }
      if (((context & MMC_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & MMC_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 81021e8:	68fb      	ldr	r3, [r7, #12]
 81021ea:	f003 0301 	and.w	r3, r3, #1
 81021ee:	2b00      	cmp	r3, #0
 81021f0:	d105      	bne.n	81021fe <HAL_MMC_IRQHandler+0x116>
 81021f2:	68fb      	ldr	r3, [r7, #12]
 81021f4:	f003 0302 	and.w	r3, r3, #2
 81021f8:	2b00      	cmp	r3, #0
 81021fa:	f000 8121 	beq.w	8102440 <HAL_MMC_IRQHandler+0x358>
      {
#if defined (USE_HAL_MMC_REGISTER_CALLBACKS) && (USE_HAL_MMC_REGISTER_CALLBACKS == 1U)
        hmmc->RxCpltCallback(hmmc);
#else
        HAL_MMC_RxCpltCallback(hmmc);
 81021fe:	6878      	ldr	r0, [r7, #4]
 8102200:	f000 f92c 	bl	810245c <HAL_MMC_RxCpltCallback>

  else
  {
    /* Nothing to do */
  }
}
 8102204:	e11c      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
    else if ((context & MMC_CONTEXT_IT) != 0U)
 8102206:	68fb      	ldr	r3, [r7, #12]
 8102208:	f003 0308 	and.w	r3, r3, #8
 810220c:	2b00      	cmp	r3, #0
 810220e:	f000 8117 	beq.w	8102440 <HAL_MMC_IRQHandler+0x358>
      if (((context & MMC_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & MMC_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8102212:	68fb      	ldr	r3, [r7, #12]
 8102214:	f003 0302 	and.w	r3, r3, #2
 8102218:	2b00      	cmp	r3, #0
 810221a:	d104      	bne.n	8102226 <HAL_MMC_IRQHandler+0x13e>
 810221c:	68fb      	ldr	r3, [r7, #12]
 810221e:	f003 0320 	and.w	r3, r3, #32
 8102222:	2b00      	cmp	r3, #0
 8102224:	d011      	beq.n	810224a <HAL_MMC_IRQHandler+0x162>
        errorstate = SDMMC_CmdStopTransfer(hmmc->Instance);
 8102226:	687b      	ldr	r3, [r7, #4]
 8102228:	681b      	ldr	r3, [r3, #0]
 810222a:	4618      	mov	r0, r3
 810222c:	f006 fe1e 	bl	8108e6c <SDMMC_CmdStopTransfer>
 8102230:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_MMC_ERROR_NONE)
 8102232:	68bb      	ldr	r3, [r7, #8]
 8102234:	2b00      	cmp	r3, #0
 8102236:	d008      	beq.n	810224a <HAL_MMC_IRQHandler+0x162>
          hmmc->ErrorCode |= errorstate;
 8102238:	687b      	ldr	r3, [r7, #4]
 810223a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 810223c:	68bb      	ldr	r3, [r7, #8]
 810223e:	431a      	orrs	r2, r3
 8102240:	687b      	ldr	r3, [r7, #4]
 8102242:	635a      	str	r2, [r3, #52]	@ 0x34
          HAL_MMC_ErrorCallback(hmmc);
 8102244:	6878      	ldr	r0, [r7, #4]
 8102246:	f000 f913 	bl	8102470 <HAL_MMC_ErrorCallback>
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
 810224a:	687b      	ldr	r3, [r7, #4]
 810224c:	681b      	ldr	r3, [r3, #0]
 810224e:	4a79      	ldr	r2, [pc, #484]	@ (8102434 <HAL_MMC_IRQHandler+0x34c>)
 8102250:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->State = HAL_MMC_STATE_READY;
 8102252:	687b      	ldr	r3, [r7, #4]
 8102254:	2201      	movs	r2, #1
 8102256:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      if (((context & MMC_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & MMC_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 810225a:	68fb      	ldr	r3, [r7, #12]
 810225c:	f003 0301 	and.w	r3, r3, #1
 8102260:	2b00      	cmp	r3, #0
 8102262:	d104      	bne.n	810226e <HAL_MMC_IRQHandler+0x186>
 8102264:	68fb      	ldr	r3, [r7, #12]
 8102266:	f003 0302 	and.w	r3, r3, #2
 810226a:	2b00      	cmp	r3, #0
 810226c:	d003      	beq.n	8102276 <HAL_MMC_IRQHandler+0x18e>
        HAL_MMC_RxCpltCallback(hmmc);
 810226e:	6878      	ldr	r0, [r7, #4]
 8102270:	f000 f8f4 	bl	810245c <HAL_MMC_RxCpltCallback>
 8102274:	e0e4      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
        HAL_MMC_TxCpltCallback(hmmc);
 8102276:	6878      	ldr	r0, [r7, #4]
 8102278:	f000 f8e6 	bl	8102448 <HAL_MMC_TxCpltCallback>
}
 810227c:	e0e0      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
  else if ((__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & MMC_CONTEXT_IT) != 0U))
 810227e:	687b      	ldr	r3, [r7, #4]
 8102280:	681b      	ldr	r3, [r3, #0]
 8102282:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102284:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8102288:	2b00      	cmp	r3, #0
 810228a:	d008      	beq.n	810229e <HAL_MMC_IRQHandler+0x1b6>
 810228c:	68fb      	ldr	r3, [r7, #12]
 810228e:	f003 0308 	and.w	r3, r3, #8
 8102292:	2b00      	cmp	r3, #0
 8102294:	d003      	beq.n	810229e <HAL_MMC_IRQHandler+0x1b6>
    MMC_Write_IT(hmmc);
 8102296:	6878      	ldr	r0, [r7, #4]
 8102298:	f000 fee8 	bl	810306c <MMC_Write_IT>
 810229c:	e0d0      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL |
 810229e:	687b      	ldr	r3, [r7, #4]
 81022a0:	681b      	ldr	r3, [r3, #0]
 81022a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022a4:	f003 033a 	and.w	r3, r3, #58	@ 0x3a
 81022a8:	2b00      	cmp	r3, #0
 81022aa:	f000 809a 	beq.w	81023e2 <HAL_MMC_IRQHandler+0x2fa>
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_DCRCFAIL) != RESET)
 81022ae:	687b      	ldr	r3, [r7, #4]
 81022b0:	681b      	ldr	r3, [r3, #0]
 81022b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022b4:	f003 0302 	and.w	r3, r3, #2
 81022b8:	2b00      	cmp	r3, #0
 81022ba:	d005      	beq.n	81022c8 <HAL_MMC_IRQHandler+0x1e0>
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
 81022bc:	687b      	ldr	r3, [r7, #4]
 81022be:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022c0:	f043 0202 	orr.w	r2, r3, #2
 81022c4:	687b      	ldr	r3, [r7, #4]
 81022c6:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_DTIMEOUT) != RESET)
 81022c8:	687b      	ldr	r3, [r7, #4]
 81022ca:	681b      	ldr	r3, [r3, #0]
 81022cc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022ce:	f003 0308 	and.w	r3, r3, #8
 81022d2:	2b00      	cmp	r3, #0
 81022d4:	d005      	beq.n	81022e2 <HAL_MMC_IRQHandler+0x1fa>
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
 81022d6:	687b      	ldr	r3, [r7, #4]
 81022d8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022da:	f043 0208 	orr.w	r2, r3, #8
 81022de:	687b      	ldr	r3, [r7, #4]
 81022e0:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_RXOVERR) != RESET)
 81022e2:	687b      	ldr	r3, [r7, #4]
 81022e4:	681b      	ldr	r3, [r3, #0]
 81022e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022e8:	f003 0320 	and.w	r3, r3, #32
 81022ec:	2b00      	cmp	r3, #0
 81022ee:	d005      	beq.n	81022fc <HAL_MMC_IRQHandler+0x214>
      hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
 81022f0:	687b      	ldr	r3, [r7, #4]
 81022f2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81022f4:	f043 0220 	orr.w	r2, r3, #32
 81022f8:	687b      	ldr	r3, [r7, #4]
 81022fa:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_TXUNDERR) != RESET)
 81022fc:	687b      	ldr	r3, [r7, #4]
 81022fe:	681b      	ldr	r3, [r3, #0]
 8102300:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102302:	f003 0310 	and.w	r3, r3, #16
 8102306:	2b00      	cmp	r3, #0
 8102308:	d005      	beq.n	8102316 <HAL_MMC_IRQHandler+0x22e>
      hmmc->ErrorCode |= HAL_MMC_ERROR_TX_UNDERRUN;
 810230a:	687b      	ldr	r3, [r7, #4]
 810230c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810230e:	f043 0210 	orr.w	r2, r3, #16
 8102312:	687b      	ldr	r3, [r7, #4]
 8102314:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
 8102316:	687b      	ldr	r3, [r7, #4]
 8102318:	681b      	ldr	r3, [r3, #0]
 810231a:	4a46      	ldr	r2, [pc, #280]	@ (8102434 <HAL_MMC_IRQHandler+0x34c>)
 810231c:	639a      	str	r2, [r3, #56]	@ 0x38
    __HAL_MMC_DISABLE_IT(hmmc, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
 810231e:	687b      	ldr	r3, [r7, #4]
 8102320:	681b      	ldr	r3, [r3, #0]
 8102322:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8102324:	687b      	ldr	r3, [r7, #4]
 8102326:	681b      	ldr	r3, [r3, #0]
 8102328:	f422 729d 	bic.w	r2, r2, #314	@ 0x13a
 810232c:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
 810232e:	687b      	ldr	r3, [r7, #4]
 8102330:	681b      	ldr	r3, [r3, #0]
 8102332:	68da      	ldr	r2, [r3, #12]
 8102334:	687b      	ldr	r3, [r7, #4]
 8102336:	681b      	ldr	r3, [r3, #0]
 8102338:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 810233c:	60da      	str	r2, [r3, #12]
    hmmc->Instance->DCTRL |= SDMMC_DCTRL_FIFORST;
 810233e:	687b      	ldr	r3, [r7, #4]
 8102340:	681b      	ldr	r3, [r3, #0]
 8102342:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8102344:	687b      	ldr	r3, [r7, #4]
 8102346:	681b      	ldr	r3, [r3, #0]
 8102348:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 810234c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hmmc->Instance->CMD |= SDMMC_CMD_CMDSTOP;
 810234e:	687b      	ldr	r3, [r7, #4]
 8102350:	681b      	ldr	r3, [r3, #0]
 8102352:	68da      	ldr	r2, [r3, #12]
 8102354:	687b      	ldr	r3, [r7, #4]
 8102356:	681b      	ldr	r3, [r3, #0]
 8102358:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 810235c:	60da      	str	r2, [r3, #12]
    hmmc->ErrorCode |= SDMMC_CmdStopTransfer(hmmc->Instance);
 810235e:	687b      	ldr	r3, [r7, #4]
 8102360:	681b      	ldr	r3, [r3, #0]
 8102362:	4618      	mov	r0, r3
 8102364:	f006 fd82 	bl	8108e6c <SDMMC_CmdStopTransfer>
 8102368:	4602      	mov	r2, r0
 810236a:	687b      	ldr	r3, [r7, #4]
 810236c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810236e:	431a      	orrs	r2, r3
 8102370:	687b      	ldr	r3, [r7, #4]
 8102372:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
 8102374:	687b      	ldr	r3, [r7, #4]
 8102376:	681b      	ldr	r3, [r3, #0]
 8102378:	68da      	ldr	r2, [r3, #12]
 810237a:	687b      	ldr	r3, [r7, #4]
 810237c:	681b      	ldr	r3, [r3, #0]
 810237e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8102382:	60da      	str	r2, [r3, #12]
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_FLAG_DABORT);
 8102384:	687b      	ldr	r3, [r7, #4]
 8102386:	681b      	ldr	r3, [r3, #0]
 8102388:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 810238c:	639a      	str	r2, [r3, #56]	@ 0x38
    if ((context & MMC_CONTEXT_IT) != 0U)
 810238e:	68fb      	ldr	r3, [r7, #12]
 8102390:	f003 0308 	and.w	r3, r3, #8
 8102394:	2b00      	cmp	r3, #0
 8102396:	d007      	beq.n	81023a8 <HAL_MMC_IRQHandler+0x2c0>
      hmmc->State = HAL_MMC_STATE_READY;
 8102398:	687b      	ldr	r3, [r7, #4]
 810239a:	2201      	movs	r2, #1
 810239c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      HAL_MMC_ErrorCallback(hmmc);
 81023a0:	6878      	ldr	r0, [r7, #4]
 81023a2:	f000 f865 	bl	8102470 <HAL_MMC_ErrorCallback>
}
 81023a6:	e04b      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
    else if ((context & MMC_CONTEXT_DMA) != 0U)
 81023a8:	68fb      	ldr	r3, [r7, #12]
 81023aa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 81023ae:	2b00      	cmp	r3, #0
 81023b0:	d046      	beq.n	8102440 <HAL_MMC_IRQHandler+0x358>
      if (hmmc->ErrorCode != HAL_MMC_ERROR_NONE)
 81023b2:	687b      	ldr	r3, [r7, #4]
 81023b4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81023b6:	2b00      	cmp	r3, #0
 81023b8:	d042      	beq.n	8102440 <HAL_MMC_IRQHandler+0x358>
        __HAL_MMC_DISABLE_IT(hmmc, SDMMC_IT_IDMABTC);
 81023ba:	687b      	ldr	r3, [r7, #4]
 81023bc:	681b      	ldr	r3, [r3, #0]
 81023be:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 81023c0:	687b      	ldr	r3, [r7, #4]
 81023c2:	681b      	ldr	r3, [r3, #0]
 81023c4:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 81023c8:	63da      	str	r2, [r3, #60]	@ 0x3c
        hmmc->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
 81023ca:	687b      	ldr	r3, [r7, #4]
 81023cc:	681b      	ldr	r3, [r3, #0]
 81023ce:	2200      	movs	r2, #0
 81023d0:	651a      	str	r2, [r3, #80]	@ 0x50
        hmmc->State = HAL_MMC_STATE_READY;
 81023d2:	687b      	ldr	r3, [r7, #4]
 81023d4:	2201      	movs	r2, #1
 81023d6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        HAL_MMC_ErrorCallback(hmmc);
 81023da:	6878      	ldr	r0, [r7, #4]
 81023dc:	f000 f848 	bl	8102470 <HAL_MMC_ErrorCallback>
}
 81023e0:	e02e      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_IDMABTC) != RESET)
 81023e2:	687b      	ldr	r3, [r7, #4]
 81023e4:	681b      	ldr	r3, [r3, #0]
 81023e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81023e8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 81023ec:	2b00      	cmp	r3, #0
 81023ee:	d027      	beq.n	8102440 <HAL_MMC_IRQHandler+0x358>
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_IT_IDMABTC);
 81023f0:	687b      	ldr	r3, [r7, #4]
 81023f2:	681b      	ldr	r3, [r3, #0]
 81023f4:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 81023f8:	639a      	str	r2, [r3, #56]	@ 0x38
    if (READ_BIT(hmmc->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
 81023fa:	687b      	ldr	r3, [r7, #4]
 81023fc:	681b      	ldr	r3, [r3, #0]
 81023fe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8102400:	f003 0304 	and.w	r3, r3, #4
 8102404:	2b00      	cmp	r3, #0
 8102406:	d10c      	bne.n	8102422 <HAL_MMC_IRQHandler+0x33a>
      if ((context & MMC_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 8102408:	68fb      	ldr	r3, [r7, #12]
 810240a:	f003 0320 	and.w	r3, r3, #32
 810240e:	2b00      	cmp	r3, #0
 8102410:	d003      	beq.n	810241a <HAL_MMC_IRQHandler+0x332>
        HAL_MMCEx_Write_DMADoubleBuf1CpltCallback(hmmc);
 8102412:	6878      	ldr	r0, [r7, #4]
 8102414:	f000 ff32 	bl	810327c <HAL_MMCEx_Write_DMADoubleBuf1CpltCallback>
}
 8102418:	e012      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
        HAL_MMCEx_Read_DMADoubleBuf1CpltCallback(hmmc);
 810241a:	6878      	ldr	r0, [r7, #4]
 810241c:	f000 ff1a 	bl	8103254 <HAL_MMCEx_Read_DMADoubleBuf1CpltCallback>
}
 8102420:	e00e      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
      if ((context & MMC_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 8102422:	68fb      	ldr	r3, [r7, #12]
 8102424:	f003 0320 	and.w	r3, r3, #32
 8102428:	2b00      	cmp	r3, #0
 810242a:	d005      	beq.n	8102438 <HAL_MMC_IRQHandler+0x350>
        HAL_MMCEx_Write_DMADoubleBuf0CpltCallback(hmmc);
 810242c:	6878      	ldr	r0, [r7, #4]
 810242e:	f000 ff1b 	bl	8103268 <HAL_MMCEx_Write_DMADoubleBuf0CpltCallback>
}
 8102432:	e005      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
 8102434:	18000f3a 	.word	0x18000f3a
        HAL_MMCEx_Read_DMADoubleBuf0CpltCallback(hmmc);
 8102438:	6878      	ldr	r0, [r7, #4]
 810243a:	f000 ff01 	bl	8103240 <HAL_MMCEx_Read_DMADoubleBuf0CpltCallback>
}
 810243e:	e7ff      	b.n	8102440 <HAL_MMC_IRQHandler+0x358>
 8102440:	bf00      	nop
 8102442:	3710      	adds	r7, #16
 8102444:	46bd      	mov	sp, r7
 8102446:	bd80      	pop	{r7, pc}

08102448 <HAL_MMC_TxCpltCallback>:
  * @brief Tx Transfer completed callbacks
  * @param hmmc: Pointer to MMC handle
  * @retval None
  */
__weak void HAL_MMC_TxCpltCallback(MMC_HandleTypeDef *hmmc)
{
 8102448:	b480      	push	{r7}
 810244a:	b083      	sub	sp, #12
 810244c:	af00      	add	r7, sp, #0
 810244e:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMC_TxCpltCallback can be implemented in the user file
   */
}
 8102450:	bf00      	nop
 8102452:	370c      	adds	r7, #12
 8102454:	46bd      	mov	sp, r7
 8102456:	f85d 7b04 	ldr.w	r7, [sp], #4
 810245a:	4770      	bx	lr

0810245c <HAL_MMC_RxCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param hmmc: Pointer MMC handle
  * @retval None
  */
__weak void HAL_MMC_RxCpltCallback(MMC_HandleTypeDef *hmmc)
{
 810245c:	b480      	push	{r7}
 810245e:	b083      	sub	sp, #12
 8102460:	af00      	add	r7, sp, #0
 8102462:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMC_RxCpltCallback can be implemented in the user file
   */
}
 8102464:	bf00      	nop
 8102466:	370c      	adds	r7, #12
 8102468:	46bd      	mov	sp, r7
 810246a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810246e:	4770      	bx	lr

08102470 <HAL_MMC_ErrorCallback>:
  * @brief MMC error callbacks
  * @param hmmc: Pointer MMC handle
  * @retval None
  */
__weak void HAL_MMC_ErrorCallback(MMC_HandleTypeDef *hmmc)
{
 8102470:	b480      	push	{r7}
 8102472:	b083      	sub	sp, #12
 8102474:	af00      	add	r7, sp, #0
 8102476:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMC_ErrorCallback can be implemented in the user file
   */
}
 8102478:	bf00      	nop
 810247a:	370c      	adds	r7, #12
 810247c:	46bd      	mov	sp, r7
 810247e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102482:	4770      	bx	lr

08102484 <HAL_MMC_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_MMC_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_GetCardCSD(MMC_HandleTypeDef *hmmc, HAL_MMC_CardCSDTypeDef *pCSD)
{
 8102484:	b580      	push	{r7, lr}
 8102486:	b084      	sub	sp, #16
 8102488:	af00      	add	r7, sp, #0
 810248a:	6078      	str	r0, [r7, #4]
 810248c:	6039      	str	r1, [r7, #0]
  uint32_t block_nbr = 0;
 810248e:	2300      	movs	r3, #0
 8102490:	60fb      	str	r3, [r7, #12]

  pCSD->CSDStruct = (uint8_t)((hmmc->CSD[0] & 0xC0000000U) >> 30U);
 8102492:	687b      	ldr	r3, [r7, #4]
 8102494:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8102496:	0f9b      	lsrs	r3, r3, #30
 8102498:	b2da      	uxtb	r2, r3
 810249a:	683b      	ldr	r3, [r7, #0]
 810249c:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hmmc->CSD[0] & 0x3C000000U) >> 26U);
 810249e:	687b      	ldr	r3, [r7, #4]
 81024a0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024a2:	0e9b      	lsrs	r3, r3, #26
 81024a4:	b2db      	uxtb	r3, r3
 81024a6:	f003 030f 	and.w	r3, r3, #15
 81024aa:	b2da      	uxtb	r2, r3
 81024ac:	683b      	ldr	r3, [r7, #0]
 81024ae:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hmmc->CSD[0] & 0x03000000U) >> 24U);
 81024b0:	687b      	ldr	r3, [r7, #4]
 81024b2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024b4:	0e1b      	lsrs	r3, r3, #24
 81024b6:	b2db      	uxtb	r3, r3
 81024b8:	f003 0303 	and.w	r3, r3, #3
 81024bc:	b2da      	uxtb	r2, r3
 81024be:	683b      	ldr	r3, [r7, #0]
 81024c0:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hmmc->CSD[0] & 0x00FF0000U) >> 16U);
 81024c2:	687b      	ldr	r3, [r7, #4]
 81024c4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024c6:	0c1b      	lsrs	r3, r3, #16
 81024c8:	b2da      	uxtb	r2, r3
 81024ca:	683b      	ldr	r3, [r7, #0]
 81024cc:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hmmc->CSD[0] & 0x0000FF00U) >> 8U);
 81024ce:	687b      	ldr	r3, [r7, #4]
 81024d0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024d2:	0a1b      	lsrs	r3, r3, #8
 81024d4:	b2da      	uxtb	r2, r3
 81024d6:	683b      	ldr	r3, [r7, #0]
 81024d8:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hmmc->CSD[0] & 0x000000FFU);
 81024da:	687b      	ldr	r3, [r7, #4]
 81024dc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024de:	b2da      	uxtb	r2, r3
 81024e0:	683b      	ldr	r3, [r7, #0]
 81024e2:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hmmc->CSD[1] & 0xFFF00000U) >> 20U);
 81024e4:	687b      	ldr	r3, [r7, #4]
 81024e6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 81024e8:	0d1b      	lsrs	r3, r3, #20
 81024ea:	b29a      	uxth	r2, r3
 81024ec:	683b      	ldr	r3, [r7, #0]
 81024ee:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hmmc->CSD[1] & 0x000F0000U) >> 16U);
 81024f0:	687b      	ldr	r3, [r7, #4]
 81024f2:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 81024f4:	0c1b      	lsrs	r3, r3, #16
 81024f6:	b2db      	uxtb	r3, r3
 81024f8:	f003 030f 	and.w	r3, r3, #15
 81024fc:	b2da      	uxtb	r2, r3
 81024fe:	683b      	ldr	r3, [r7, #0]
 8102500:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hmmc->CSD[1] & 0x00008000U) >> 15U);
 8102502:	687b      	ldr	r3, [r7, #4]
 8102504:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8102506:	0bdb      	lsrs	r3, r3, #15
 8102508:	b2db      	uxtb	r3, r3
 810250a:	f003 0301 	and.w	r3, r3, #1
 810250e:	b2da      	uxtb	r2, r3
 8102510:	683b      	ldr	r3, [r7, #0]
 8102512:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hmmc->CSD[1] & 0x00004000U) >> 14U);
 8102514:	687b      	ldr	r3, [r7, #4]
 8102516:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8102518:	0b9b      	lsrs	r3, r3, #14
 810251a:	b2db      	uxtb	r3, r3
 810251c:	f003 0301 	and.w	r3, r3, #1
 8102520:	b2da      	uxtb	r2, r3
 8102522:	683b      	ldr	r3, [r7, #0]
 8102524:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hmmc->CSD[1] & 0x00002000U) >> 13U);
 8102526:	687b      	ldr	r3, [r7, #4]
 8102528:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810252a:	0b5b      	lsrs	r3, r3, #13
 810252c:	b2db      	uxtb	r3, r3
 810252e:	f003 0301 	and.w	r3, r3, #1
 8102532:	b2da      	uxtb	r2, r3
 8102534:	683b      	ldr	r3, [r7, #0]
 8102536:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hmmc->CSD[1] & 0x00001000U) >> 12U);
 8102538:	687b      	ldr	r3, [r7, #4]
 810253a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810253c:	0b1b      	lsrs	r3, r3, #12
 810253e:	b2db      	uxtb	r3, r3
 8102540:	f003 0301 	and.w	r3, r3, #1
 8102544:	b2da      	uxtb	r2, r3
 8102546:	683b      	ldr	r3, [r7, #0]
 8102548:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 810254a:	683b      	ldr	r3, [r7, #0]
 810254c:	2200      	movs	r2, #0
 810254e:	735a      	strb	r2, [r3, #13]

  if (MMC_ReadExtCSD(hmmc, &block_nbr, 212, 0x0FFFFFFFU) != HAL_OK) /* Field SEC_COUNT [215:212] */
 8102550:	f107 010c 	add.w	r1, r7, #12
 8102554:	f06f 4370 	mvn.w	r3, #4026531840	@ 0xf0000000
 8102558:	22d4      	movs	r2, #212	@ 0xd4
 810255a:	6878      	ldr	r0, [r7, #4]
 810255c:	f000 fc4c 	bl	8102df8 <MMC_ReadExtCSD>
 8102560:	4603      	mov	r3, r0
 8102562:	2b00      	cmp	r3, #0
 8102564:	d001      	beq.n	810256a <HAL_MMC_GetCardCSD+0xe6>
  {
    return HAL_ERROR;
 8102566:	2301      	movs	r3, #1
 8102568:	e129      	b.n	81027be <HAL_MMC_GetCardCSD+0x33a>
  }

  if (hmmc->MmcCard.CardType == MMC_LOW_CAPACITY_CARD)
 810256a:	687b      	ldr	r3, [r7, #4]
 810256c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810256e:	2b00      	cmp	r3, #0
 8102570:	d163      	bne.n	810263a <HAL_MMC_GetCardCSD+0x1b6>
  {
    pCSD->DeviceSize = (((hmmc->CSD[1] & 0x000003FFU) << 2U) | ((hmmc->CSD[2] & 0xC0000000U) >> 30U));
 8102572:	687b      	ldr	r3, [r7, #4]
 8102574:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8102576:	009a      	lsls	r2, r3, #2
 8102578:	f640 73fc 	movw	r3, #4092	@ 0xffc
 810257c:	4013      	ands	r3, r2
 810257e:	687a      	ldr	r2, [r7, #4]
 8102580:	6e12      	ldr	r2, [r2, #96]	@ 0x60
 8102582:	0f92      	lsrs	r2, r2, #30
 8102584:	431a      	orrs	r2, r3
 8102586:	683b      	ldr	r3, [r7, #0]
 8102588:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hmmc->CSD[2] & 0x38000000U) >> 27U);
 810258a:	687b      	ldr	r3, [r7, #4]
 810258c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 810258e:	0edb      	lsrs	r3, r3, #27
 8102590:	b2db      	uxtb	r3, r3
 8102592:	f003 0307 	and.w	r3, r3, #7
 8102596:	b2da      	uxtb	r2, r3
 8102598:	683b      	ldr	r3, [r7, #0]
 810259a:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hmmc->CSD[2] & 0x07000000U) >> 24U);
 810259c:	687b      	ldr	r3, [r7, #4]
 810259e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81025a0:	0e1b      	lsrs	r3, r3, #24
 81025a2:	b2db      	uxtb	r3, r3
 81025a4:	f003 0307 	and.w	r3, r3, #7
 81025a8:	b2da      	uxtb	r2, r3
 81025aa:	683b      	ldr	r3, [r7, #0]
 81025ac:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hmmc->CSD[2] & 0x00E00000U) >> 21U);
 81025ae:	687b      	ldr	r3, [r7, #4]
 81025b0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81025b2:	0d5b      	lsrs	r3, r3, #21
 81025b4:	b2db      	uxtb	r3, r3
 81025b6:	f003 0307 	and.w	r3, r3, #7
 81025ba:	b2da      	uxtb	r2, r3
 81025bc:	683b      	ldr	r3, [r7, #0]
 81025be:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hmmc->CSD[2] & 0x001C0000U) >> 18U);
 81025c0:	687b      	ldr	r3, [r7, #4]
 81025c2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81025c4:	0c9b      	lsrs	r3, r3, #18
 81025c6:	b2db      	uxtb	r3, r3
 81025c8:	f003 0307 	and.w	r3, r3, #7
 81025cc:	b2da      	uxtb	r2, r3
 81025ce:	683b      	ldr	r3, [r7, #0]
 81025d0:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hmmc->CSD[2] & 0x00038000U) >> 15U);
 81025d2:	687b      	ldr	r3, [r7, #4]
 81025d4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81025d6:	0bdb      	lsrs	r3, r3, #15
 81025d8:	b2db      	uxtb	r3, r3
 81025da:	f003 0307 	and.w	r3, r3, #7
 81025de:	b2da      	uxtb	r2, r3
 81025e0:	683b      	ldr	r3, [r7, #0]
 81025e2:	761a      	strb	r2, [r3, #24]

    hmmc->MmcCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 81025e4:	683b      	ldr	r3, [r7, #0]
 81025e6:	691b      	ldr	r3, [r3, #16]
 81025e8:	1c5a      	adds	r2, r3, #1
 81025ea:	687b      	ldr	r3, [r7, #4]
 81025ec:	649a      	str	r2, [r3, #72]	@ 0x48
    hmmc->MmcCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 81025ee:	683b      	ldr	r3, [r7, #0]
 81025f0:	7e1b      	ldrb	r3, [r3, #24]
 81025f2:	b2db      	uxtb	r3, r3
 81025f4:	f003 0307 	and.w	r3, r3, #7
 81025f8:	3302      	adds	r3, #2
 81025fa:	2201      	movs	r2, #1
 81025fc:	fa02 f303 	lsl.w	r3, r2, r3
 8102600:	687a      	ldr	r2, [r7, #4]
 8102602:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8102604:	fb03 f202 	mul.w	r2, r3, r2
 8102608:	687b      	ldr	r3, [r7, #4]
 810260a:	649a      	str	r2, [r3, #72]	@ 0x48
    hmmc->MmcCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 810260c:	683b      	ldr	r3, [r7, #0]
 810260e:	7a1b      	ldrb	r3, [r3, #8]
 8102610:	b2db      	uxtb	r3, r3
 8102612:	f003 030f 	and.w	r3, r3, #15
 8102616:	2201      	movs	r2, #1
 8102618:	409a      	lsls	r2, r3
 810261a:	687b      	ldr	r3, [r7, #4]
 810261c:	64da      	str	r2, [r3, #76]	@ 0x4c

    hmmc->MmcCard.LogBlockNbr = (hmmc->MmcCard.BlockNbr) * ((hmmc->MmcCard.BlockSize) / MMC_BLOCKSIZE);
 810261e:	687b      	ldr	r3, [r7, #4]
 8102620:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8102622:	687a      	ldr	r2, [r7, #4]
 8102624:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 8102626:	0a52      	lsrs	r2, r2, #9
 8102628:	fb03 f202 	mul.w	r2, r3, r2
 810262c:	687b      	ldr	r3, [r7, #4]
 810262e:	651a      	str	r2, [r3, #80]	@ 0x50
    hmmc->MmcCard.LogBlockSize = MMC_BLOCKSIZE;
 8102630:	687b      	ldr	r3, [r7, #4]
 8102632:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8102636:	655a      	str	r2, [r3, #84]	@ 0x54
 8102638:	e023      	b.n	8102682 <HAL_MMC_GetCardCSD+0x1fe>
  }
  else if (hmmc->MmcCard.CardType == MMC_HIGH_CAPACITY_CARD)
 810263a:	687b      	ldr	r3, [r7, #4]
 810263c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810263e:	2b01      	cmp	r3, #1
 8102640:	d10f      	bne.n	8102662 <HAL_MMC_GetCardCSD+0x1de>
  {
    hmmc->MmcCard.BlockNbr = block_nbr;
 8102642:	68fa      	ldr	r2, [r7, #12]
 8102644:	687b      	ldr	r3, [r7, #4]
 8102646:	649a      	str	r2, [r3, #72]	@ 0x48
    hmmc->MmcCard.LogBlockNbr = hmmc->MmcCard.BlockNbr;
 8102648:	687b      	ldr	r3, [r7, #4]
 810264a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 810264c:	687b      	ldr	r3, [r7, #4]
 810264e:	651a      	str	r2, [r3, #80]	@ 0x50
    hmmc->MmcCard.BlockSize = MMC_BLOCKSIZE;
 8102650:	687b      	ldr	r3, [r7, #4]
 8102652:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8102656:	64da      	str	r2, [r3, #76]	@ 0x4c
    hmmc->MmcCard.LogBlockSize = hmmc->MmcCard.BlockSize;
 8102658:	687b      	ldr	r3, [r7, #4]
 810265a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 810265c:	687b      	ldr	r3, [r7, #4]
 810265e:	655a      	str	r2, [r3, #84]	@ 0x54
 8102660:	e00f      	b.n	8102682 <HAL_MMC_GetCardCSD+0x1fe>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102662:	687b      	ldr	r3, [r7, #4]
 8102664:	681b      	ldr	r3, [r3, #0]
 8102666:	4a58      	ldr	r2, [pc, #352]	@ (81027c8 <HAL_MMC_GetCardCSD+0x344>)
 8102668:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_UNSUPPORTED_FEATURE;
 810266a:	687b      	ldr	r3, [r7, #4]
 810266c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810266e:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8102672:	687b      	ldr	r3, [r7, #4]
 8102674:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 8102676:	687b      	ldr	r3, [r7, #4]
 8102678:	2201      	movs	r2, #1
 810267a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 810267e:	2301      	movs	r3, #1
 8102680:	e09d      	b.n	81027be <HAL_MMC_GetCardCSD+0x33a>
  }

  pCSD->EraseGrSize = (uint8_t)((hmmc->CSD[2] & 0x00004000U) >> 14U);
 8102682:	687b      	ldr	r3, [r7, #4]
 8102684:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8102686:	0b9b      	lsrs	r3, r3, #14
 8102688:	b2db      	uxtb	r3, r3
 810268a:	f003 0301 	and.w	r3, r3, #1
 810268e:	b2da      	uxtb	r2, r3
 8102690:	683b      	ldr	r3, [r7, #0]
 8102692:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hmmc->CSD[2] & 0x00003F80U) >> 7U);
 8102694:	687b      	ldr	r3, [r7, #4]
 8102696:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8102698:	09db      	lsrs	r3, r3, #7
 810269a:	b2db      	uxtb	r3, r3
 810269c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81026a0:	b2da      	uxtb	r2, r3
 81026a2:	683b      	ldr	r3, [r7, #0]
 81026a4:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hmmc->CSD[2] & 0x0000007FU);
 81026a6:	687b      	ldr	r3, [r7, #4]
 81026a8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81026aa:	b2db      	uxtb	r3, r3
 81026ac:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81026b0:	b2da      	uxtb	r2, r3
 81026b2:	683b      	ldr	r3, [r7, #0]
 81026b4:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hmmc->CSD[3] & 0x80000000U) >> 31U);
 81026b6:	687b      	ldr	r3, [r7, #4]
 81026b8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81026ba:	0fdb      	lsrs	r3, r3, #31
 81026bc:	b2da      	uxtb	r2, r3
 81026be:	683b      	ldr	r3, [r7, #0]
 81026c0:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hmmc->CSD[3] & 0x60000000U) >> 29U);
 81026c2:	687b      	ldr	r3, [r7, #4]
 81026c4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81026c6:	0f5b      	lsrs	r3, r3, #29
 81026c8:	b2db      	uxtb	r3, r3
 81026ca:	f003 0303 	and.w	r3, r3, #3
 81026ce:	b2da      	uxtb	r2, r3
 81026d0:	683b      	ldr	r3, [r7, #0]
 81026d2:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hmmc->CSD[3] & 0x1C000000U) >> 26U);
 81026d4:	687b      	ldr	r3, [r7, #4]
 81026d6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81026d8:	0e9b      	lsrs	r3, r3, #26
 81026da:	b2db      	uxtb	r3, r3
 81026dc:	f003 0307 	and.w	r3, r3, #7
 81026e0:	b2da      	uxtb	r2, r3
 81026e2:	683b      	ldr	r3, [r7, #0]
 81026e4:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen = (uint8_t)((hmmc->CSD[3] & 0x03C00000U) >> 22U);
 81026e6:	687b      	ldr	r3, [r7, #4]
 81026e8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81026ea:	0d9b      	lsrs	r3, r3, #22
 81026ec:	b2db      	uxtb	r3, r3
 81026ee:	f003 030f 	and.w	r3, r3, #15
 81026f2:	b2da      	uxtb	r2, r3
 81026f4:	683b      	ldr	r3, [r7, #0]
 81026f6:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hmmc->CSD[3] & 0x00200000U) >> 21U);
 81026f8:	687b      	ldr	r3, [r7, #4]
 81026fa:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81026fc:	0d5b      	lsrs	r3, r3, #21
 81026fe:	b2db      	uxtb	r3, r3
 8102700:	f003 0301 	and.w	r3, r3, #1
 8102704:	b2da      	uxtb	r2, r3
 8102706:	683b      	ldr	r3, [r7, #0]
 8102708:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
 810270c:	683b      	ldr	r3, [r7, #0]
 810270e:	2200      	movs	r2, #0
 8102710:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hmmc->CSD[3] & 0x00010000U) >> 16U);
 8102714:	687b      	ldr	r3, [r7, #4]
 8102716:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102718:	0c1b      	lsrs	r3, r3, #16
 810271a:	b2db      	uxtb	r3, r3
 810271c:	f003 0301 	and.w	r3, r3, #1
 8102720:	b2da      	uxtb	r2, r3
 8102722:	683b      	ldr	r3, [r7, #0]
 8102724:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

  pCSD->FileFormatGroup = (uint8_t)((hmmc->CSD[3] & 0x00008000U) >> 15U);
 8102728:	687b      	ldr	r3, [r7, #4]
 810272a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810272c:	0bdb      	lsrs	r3, r3, #15
 810272e:	b2db      	uxtb	r3, r3
 8102730:	f003 0301 	and.w	r3, r3, #1
 8102734:	b2da      	uxtb	r2, r3
 8102736:	683b      	ldr	r3, [r7, #0]
 8102738:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pCSD->CopyFlag = (uint8_t)((hmmc->CSD[3] & 0x00004000U) >> 14U);
 810273c:	687b      	ldr	r3, [r7, #4]
 810273e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102740:	0b9b      	lsrs	r3, r3, #14
 8102742:	b2db      	uxtb	r3, r3
 8102744:	f003 0301 	and.w	r3, r3, #1
 8102748:	b2da      	uxtb	r2, r3
 810274a:	683b      	ldr	r3, [r7, #0]
 810274c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  pCSD->PermWrProtect = (uint8_t)((hmmc->CSD[3] & 0x00002000U) >> 13U);
 8102750:	687b      	ldr	r3, [r7, #4]
 8102752:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102754:	0b5b      	lsrs	r3, r3, #13
 8102756:	b2db      	uxtb	r3, r3
 8102758:	f003 0301 	and.w	r3, r3, #1
 810275c:	b2da      	uxtb	r2, r3
 810275e:	683b      	ldr	r3, [r7, #0]
 8102760:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  pCSD->TempWrProtect = (uint8_t)((hmmc->CSD[3] & 0x00001000U) >> 12U);
 8102764:	687b      	ldr	r3, [r7, #4]
 8102766:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102768:	0b1b      	lsrs	r3, r3, #12
 810276a:	b2db      	uxtb	r3, r3
 810276c:	f003 0301 	and.w	r3, r3, #1
 8102770:	b2da      	uxtb	r2, r3
 8102772:	683b      	ldr	r3, [r7, #0]
 8102774:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  pCSD->FileFormat = (uint8_t)((hmmc->CSD[3] & 0x00000C00U) >> 10U);
 8102778:	687b      	ldr	r3, [r7, #4]
 810277a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810277c:	0a9b      	lsrs	r3, r3, #10
 810277e:	b2db      	uxtb	r3, r3
 8102780:	f003 0303 	and.w	r3, r3, #3
 8102784:	b2da      	uxtb	r2, r3
 8102786:	683b      	ldr	r3, [r7, #0]
 8102788:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27

  pCSD->ECC = (uint8_t)((hmmc->CSD[3] & 0x00000300U) >> 8U);
 810278c:	687b      	ldr	r3, [r7, #4]
 810278e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102790:	0a1b      	lsrs	r3, r3, #8
 8102792:	b2db      	uxtb	r3, r3
 8102794:	f003 0303 	and.w	r3, r3, #3
 8102798:	b2da      	uxtb	r2, r3
 810279a:	683b      	ldr	r3, [r7, #0]
 810279c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

  pCSD->CSD_CRC = (uint8_t)((hmmc->CSD[3] & 0x000000FEU) >> 1U);
 81027a0:	687b      	ldr	r3, [r7, #4]
 81027a2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81027a4:	085b      	lsrs	r3, r3, #1
 81027a6:	b2db      	uxtb	r3, r3
 81027a8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81027ac:	b2da      	uxtb	r2, r3
 81027ae:	683b      	ldr	r3, [r7, #0]
 81027b0:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29

  pCSD->Reserved4 = 1;
 81027b4:	683b      	ldr	r3, [r7, #0]
 81027b6:	2201      	movs	r2, #1
 81027b8:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  return HAL_OK;
 81027bc:	2300      	movs	r3, #0
}
 81027be:	4618      	mov	r0, r3
 81027c0:	3710      	adds	r7, #16
 81027c2:	46bd      	mov	sp, r7
 81027c4:	bd80      	pop	{r7, pc}
 81027c6:	bf00      	nop
 81027c8:	1fe00fff 	.word	0x1fe00fff

081027cc <HAL_MMC_GetCardExtCSD>:
  *         Extended CSD register parameters
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_GetCardExtCSD(MMC_HandleTypeDef *hmmc, uint32_t *pExtCSD, uint32_t Timeout)
{
 81027cc:	b580      	push	{r7, lr}
 81027ce:	b08e      	sub	sp, #56	@ 0x38
 81027d0:	af00      	add	r7, sp, #0
 81027d2:	60f8      	str	r0, [r7, #12]
 81027d4:	60b9      	str	r1, [r7, #8]
 81027d6:	607a      	str	r2, [r7, #4]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 81027d8:	f7ff f8c6 	bl	8101968 <HAL_GetTick>
 81027dc:	62f8      	str	r0, [r7, #44]	@ 0x2c
  uint32_t count;
  uint32_t *tmp_buf;

  if (NULL == pExtCSD)
 81027de:	68bb      	ldr	r3, [r7, #8]
 81027e0:	2b00      	cmp	r3, #0
 81027e2:	d107      	bne.n	81027f4 <HAL_MMC_GetCardExtCSD+0x28>
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_PARAM;
 81027e4:	68fb      	ldr	r3, [r7, #12]
 81027e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81027e8:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 81027ec:	68fb      	ldr	r3, [r7, #12]
 81027ee:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 81027f0:	2301      	movs	r3, #1
 81027f2:	e0de      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>
  }

  if (hmmc->State == HAL_MMC_STATE_READY)
 81027f4:	68fb      	ldr	r3, [r7, #12]
 81027f6:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 81027fa:	b2db      	uxtb	r3, r3
 81027fc:	2b01      	cmp	r3, #1
 81027fe:	f040 80d7 	bne.w	81029b0 <HAL_MMC_GetCardExtCSD+0x1e4>
  {
    hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
 8102802:	68fb      	ldr	r3, [r7, #12]
 8102804:	2200      	movs	r2, #0
 8102806:	635a      	str	r2, [r3, #52]	@ 0x34

    hmmc->State = HAL_MMC_STATE_BUSY;
 8102808:	68fb      	ldr	r3, [r7, #12]
 810280a:	2203      	movs	r2, #3
 810280c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hmmc->Instance->DCTRL = 0;
 8102810:	68fb      	ldr	r3, [r7, #12]
 8102812:	681b      	ldr	r3, [r3, #0]
 8102814:	2200      	movs	r2, #0
 8102816:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Initiaize the destination pointer */
    tmp_buf = pExtCSD;
 8102818:	68bb      	ldr	r3, [r7, #8]
 810281a:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Configure the MMC DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 810281c:	f04f 33ff 	mov.w	r3, #4294967295
 8102820:	613b      	str	r3, [r7, #16]
    config.DataLength    = MMC_BLOCKSIZE;
 8102822:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8102826:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8102828:	2390      	movs	r3, #144	@ 0x90
 810282a:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 810282c:	2302      	movs	r3, #2
 810282e:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8102830:	2300      	movs	r3, #0
 8102832:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 8102834:	2300      	movs	r3, #0
 8102836:	627b      	str	r3, [r7, #36]	@ 0x24
    (void)SDMMC_ConfigData(hmmc->Instance, &config);
 8102838:	68fb      	ldr	r3, [r7, #12]
 810283a:	681b      	ldr	r3, [r3, #0]
 810283c:	f107 0210 	add.w	r2, r7, #16
 8102840:	4611      	mov	r1, r2
 8102842:	4618      	mov	r0, r3
 8102844:	f006 fac2 	bl	8108dcc <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hmmc->Instance);
 8102848:	68fb      	ldr	r3, [r7, #12]
 810284a:	681b      	ldr	r3, [r3, #0]
 810284c:	68da      	ldr	r2, [r3, #12]
 810284e:	68fb      	ldr	r3, [r7, #12]
 8102850:	681b      	ldr	r3, [r3, #0]
 8102852:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8102856:	60da      	str	r2, [r3, #12]

    /* Send ExtCSD Read command to Card */
    errorstate = SDMMC_CmdSendEXTCSD(hmmc->Instance, 0);
 8102858:	68fb      	ldr	r3, [r7, #12]
 810285a:	681b      	ldr	r3, [r3, #0]
 810285c:	2100      	movs	r1, #0
 810285e:	4618      	mov	r0, r3
 8102860:	f006 fc4b 	bl	81090fa <SDMMC_CmdSendEXTCSD>
 8102864:	62b8      	str	r0, [r7, #40]	@ 0x28
    if (errorstate != HAL_MMC_ERROR_NONE)
 8102866:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8102868:	2b00      	cmp	r3, #0
 810286a:	d045      	beq.n	81028f8 <HAL_MMC_GetCardExtCSD+0x12c>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 810286c:	68fb      	ldr	r3, [r7, #12]
 810286e:	681b      	ldr	r3, [r3, #0]
 8102870:	4a52      	ldr	r2, [pc, #328]	@ (81029bc <HAL_MMC_GetCardExtCSD+0x1f0>)
 8102872:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->ErrorCode |= errorstate;
 8102874:	68fb      	ldr	r3, [r7, #12]
 8102876:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102878:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810287a:	431a      	orrs	r2, r3
 810287c:	68fb      	ldr	r3, [r7, #12]
 810287e:	635a      	str	r2, [r3, #52]	@ 0x34
      hmmc->State = HAL_MMC_STATE_READY;
 8102880:	68fb      	ldr	r3, [r7, #12]
 8102882:	2201      	movs	r2, #1
 8102884:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 8102888:	2301      	movs	r3, #1
 810288a:	e092      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>

    /* Poll on SDMMC flags */
    while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR |
                               SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF))
 810288c:	68fb      	ldr	r3, [r7, #12]
 810288e:	681b      	ldr	r3, [r3, #0]
 8102890:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102892:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8102896:	2b00      	cmp	r3, #0
 8102898:	d013      	beq.n	81028c2 <HAL_MMC_GetCardExtCSD+0xf6>
      {
        /* Read data from SDMMC Rx FIFO */
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 810289a:	2300      	movs	r3, #0
 810289c:	637b      	str	r3, [r7, #52]	@ 0x34
 810289e:	e00d      	b.n	81028bc <HAL_MMC_GetCardExtCSD+0xf0>
        {
          *tmp_buf = SDMMC_ReadFIFO(hmmc->Instance);
 81028a0:	68fb      	ldr	r3, [r7, #12]
 81028a2:	681b      	ldr	r3, [r3, #0]
 81028a4:	4618      	mov	r0, r3
 81028a6:	f006 fa09 	bl	8108cbc <SDMMC_ReadFIFO>
 81028aa:	4602      	mov	r2, r0
 81028ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81028ae:	601a      	str	r2, [r3, #0]
          tmp_buf++;
 81028b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81028b2:	3304      	adds	r3, #4
 81028b4:	633b      	str	r3, [r7, #48]	@ 0x30
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 81028b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81028b8:	3301      	adds	r3, #1
 81028ba:	637b      	str	r3, [r7, #52]	@ 0x34
 81028bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81028be:	2b07      	cmp	r3, #7
 81028c0:	d9ee      	bls.n	81028a0 <HAL_MMC_GetCardExtCSD+0xd4>
        }
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
 81028c2:	f7ff f851 	bl	8101968 <HAL_GetTick>
 81028c6:	4602      	mov	r2, r0
 81028c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 81028ca:	1ad3      	subs	r3, r2, r3
 81028cc:	687a      	ldr	r2, [r7, #4]
 81028ce:	429a      	cmp	r2, r3
 81028d0:	d902      	bls.n	81028d8 <HAL_MMC_GetCardExtCSD+0x10c>
 81028d2:	687b      	ldr	r3, [r7, #4]
 81028d4:	2b00      	cmp	r3, #0
 81028d6:	d10f      	bne.n	81028f8 <HAL_MMC_GetCardExtCSD+0x12c>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 81028d8:	68fb      	ldr	r3, [r7, #12]
 81028da:	681b      	ldr	r3, [r3, #0]
 81028dc:	4a37      	ldr	r2, [pc, #220]	@ (81029bc <HAL_MMC_GetCardExtCSD+0x1f0>)
 81028de:	639a      	str	r2, [r3, #56]	@ 0x38
        hmmc->ErrorCode |= HAL_MMC_ERROR_TIMEOUT;
 81028e0:	68fb      	ldr	r3, [r7, #12]
 81028e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81028e4:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
 81028e8:	68fb      	ldr	r3, [r7, #12]
 81028ea:	635a      	str	r2, [r3, #52]	@ 0x34
        hmmc->State = HAL_MMC_STATE_READY;
 81028ec:	68fb      	ldr	r3, [r7, #12]
 81028ee:	2201      	movs	r2, #1
 81028f0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        return HAL_TIMEOUT;
 81028f4:	2303      	movs	r3, #3
 81028f6:	e05c      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>
    while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR |
 81028f8:	68fb      	ldr	r3, [r7, #12]
 81028fa:	681b      	ldr	r3, [r3, #0]
 81028fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81028fe:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
 8102902:	2b00      	cmp	r3, #0
 8102904:	d0c2      	beq.n	810288c <HAL_MMC_GetCardExtCSD+0xc0>
      }
    }

    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
 8102906:	68fb      	ldr	r3, [r7, #12]
 8102908:	681b      	ldr	r3, [r3, #0]
 810290a:	68da      	ldr	r2, [r3, #12]
 810290c:	68fb      	ldr	r3, [r7, #12]
 810290e:	681b      	ldr	r3, [r3, #0]
 8102910:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8102914:	60da      	str	r2, [r3, #12]

    /* Get error state */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
 8102916:	68fb      	ldr	r3, [r7, #12]
 8102918:	681b      	ldr	r3, [r3, #0]
 810291a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810291c:	f003 0308 	and.w	r3, r3, #8
 8102920:	2b00      	cmp	r3, #0
 8102922:	d00f      	beq.n	8102944 <HAL_MMC_GetCardExtCSD+0x178>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102924:	68fb      	ldr	r3, [r7, #12]
 8102926:	681b      	ldr	r3, [r3, #0]
 8102928:	4a24      	ldr	r2, [pc, #144]	@ (81029bc <HAL_MMC_GetCardExtCSD+0x1f0>)
 810292a:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
 810292c:	68fb      	ldr	r3, [r7, #12]
 810292e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102930:	f043 0208 	orr.w	r2, r3, #8
 8102934:	68fb      	ldr	r3, [r7, #12]
 8102936:	635a      	str	r2, [r3, #52]	@ 0x34
      hmmc->State = HAL_MMC_STATE_READY;
 8102938:	68fb      	ldr	r3, [r7, #12]
 810293a:	2201      	movs	r2, #1
 810293c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 8102940:	2301      	movs	r3, #1
 8102942:	e036      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
 8102944:	68fb      	ldr	r3, [r7, #12]
 8102946:	681b      	ldr	r3, [r3, #0]
 8102948:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810294a:	f003 0302 	and.w	r3, r3, #2
 810294e:	2b00      	cmp	r3, #0
 8102950:	d00f      	beq.n	8102972 <HAL_MMC_GetCardExtCSD+0x1a6>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102952:	68fb      	ldr	r3, [r7, #12]
 8102954:	681b      	ldr	r3, [r3, #0]
 8102956:	4a19      	ldr	r2, [pc, #100]	@ (81029bc <HAL_MMC_GetCardExtCSD+0x1f0>)
 8102958:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
 810295a:	68fb      	ldr	r3, [r7, #12]
 810295c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810295e:	f043 0202 	orr.w	r2, r3, #2
 8102962:	68fb      	ldr	r3, [r7, #12]
 8102964:	635a      	str	r2, [r3, #52]	@ 0x34
      hmmc->State = HAL_MMC_STATE_READY;
 8102966:	68fb      	ldr	r3, [r7, #12]
 8102968:	2201      	movs	r2, #1
 810296a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 810296e:	2301      	movs	r3, #1
 8102970:	e01f      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR))
 8102972:	68fb      	ldr	r3, [r7, #12]
 8102974:	681b      	ldr	r3, [r3, #0]
 8102976:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102978:	f003 0320 	and.w	r3, r3, #32
 810297c:	2b00      	cmp	r3, #0
 810297e:	d00f      	beq.n	81029a0 <HAL_MMC_GetCardExtCSD+0x1d4>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102980:	68fb      	ldr	r3, [r7, #12]
 8102982:	681b      	ldr	r3, [r3, #0]
 8102984:	4a0d      	ldr	r2, [pc, #52]	@ (81029bc <HAL_MMC_GetCardExtCSD+0x1f0>)
 8102986:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
 8102988:	68fb      	ldr	r3, [r7, #12]
 810298a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810298c:	f043 0220 	orr.w	r2, r3, #32
 8102990:	68fb      	ldr	r3, [r7, #12]
 8102992:	635a      	str	r2, [r3, #52]	@ 0x34
      hmmc->State = HAL_MMC_STATE_READY;
 8102994:	68fb      	ldr	r3, [r7, #12]
 8102996:	2201      	movs	r2, #1
 8102998:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 810299c:	2301      	movs	r3, #1
 810299e:	e008      	b.n	81029b2 <HAL_MMC_GetCardExtCSD+0x1e6>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
 81029a0:	68fb      	ldr	r3, [r7, #12]
 81029a2:	681b      	ldr	r3, [r3, #0]
 81029a4:	4a06      	ldr	r2, [pc, #24]	@ (81029c0 <HAL_MMC_GetCardExtCSD+0x1f4>)
 81029a6:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->State = HAL_MMC_STATE_READY;
 81029a8:	68fb      	ldr	r3, [r7, #12]
 81029aa:	2201      	movs	r2, #1
 81029ac:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
  }

  return HAL_OK;
 81029b0:	2300      	movs	r3, #0
}
 81029b2:	4618      	mov	r0, r3
 81029b4:	3738      	adds	r7, #56	@ 0x38
 81029b6:	46bd      	mov	sp, r7
 81029b8:	bd80      	pop	{r7, pc}
 81029ba:	bf00      	nop
 81029bc:	1fe00fff 	.word	0x1fe00fff
 81029c0:	18000f3a 	.word	0x18000f3a

081029c4 <HAL_MMC_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_ConfigWideBusOperation(MMC_HandleTypeDef *hmmc, uint32_t WideMode)
{
 81029c4:	b5b0      	push	{r4, r5, r7, lr}
 81029c6:	b08c      	sub	sp, #48	@ 0x30
 81029c8:	af02      	add	r7, sp, #8
 81029ca:	6078      	str	r0, [r7, #4]
 81029cc:	6039      	str	r1, [r7, #0]
  uint32_t count;
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t response = 0U;
 81029ce:	2300      	movs	r3, #0
 81029d0:	61fb      	str	r3, [r7, #28]

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hmmc->State = HAL_MMC_STATE_BUSY;
 81029d2:	687b      	ldr	r3, [r7, #4]
 81029d4:	2203      	movs	r2, #3
 81029d6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Check and update the power class if needed */
  if ((hmmc->Instance->CLKCR & SDMMC_CLKCR_BUSSPEED) != 0U)
 81029da:	687b      	ldr	r3, [r7, #4]
 81029dc:	681b      	ldr	r3, [r3, #0]
 81029de:	685b      	ldr	r3, [r3, #4]
 81029e0:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 81029e4:	2b00      	cmp	r3, #0
 81029e6:	d014      	beq.n	8102a12 <HAL_MMC_ConfigWideBusOperation+0x4e>
  {
    if ((hmmc->Instance->CLKCR & SDMMC_CLKCR_DDR) != 0U)
 81029e8:	687b      	ldr	r3, [r7, #4]
 81029ea:	681b      	ldr	r3, [r3, #0]
 81029ec:	685b      	ldr	r3, [r3, #4]
 81029ee:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 81029f2:	2b00      	cmp	r3, #0
 81029f4:	d006      	beq.n	8102a04 <HAL_MMC_ConfigWideBusOperation+0x40>
    {
      errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_DDR);
 81029f6:	2204      	movs	r2, #4
 81029f8:	6839      	ldr	r1, [r7, #0]
 81029fa:	6878      	ldr	r0, [r7, #4]
 81029fc:	f000 fb80 	bl	8103100 <MMC_PwrClassUpdate>
 8102a00:	6238      	str	r0, [r7, #32]
 8102a02:	e00c      	b.n	8102a1e <HAL_MMC_ConfigWideBusOperation+0x5a>
    }
    else
    {
      errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_HIGH);
 8102a04:	2202      	movs	r2, #2
 8102a06:	6839      	ldr	r1, [r7, #0]
 8102a08:	6878      	ldr	r0, [r7, #4]
 8102a0a:	f000 fb79 	bl	8103100 <MMC_PwrClassUpdate>
 8102a0e:	6238      	str	r0, [r7, #32]
 8102a10:	e005      	b.n	8102a1e <HAL_MMC_ConfigWideBusOperation+0x5a>
    }
  }
  else
  {
    errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_DEFAULT);
 8102a12:	2201      	movs	r2, #1
 8102a14:	6839      	ldr	r1, [r7, #0]
 8102a16:	6878      	ldr	r0, [r7, #4]
 8102a18:	f000 fb72 	bl	8103100 <MMC_PwrClassUpdate>
 8102a1c:	6238      	str	r0, [r7, #32]
  }

  if (errorstate == HAL_MMC_ERROR_NONE)
 8102a1e:	6a3b      	ldr	r3, [r7, #32]
 8102a20:	2b00      	cmp	r3, #0
 8102a22:	d17b      	bne.n	8102b1c <HAL_MMC_ConfigWideBusOperation+0x158>
  {
    if (WideMode == SDMMC_BUS_WIDE_8B)
 8102a24:	683b      	ldr	r3, [r7, #0]
 8102a26:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8102a2a:	d107      	bne.n	8102a3c <HAL_MMC_ConfigWideBusOperation+0x78>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70200U);
 8102a2c:	687b      	ldr	r3, [r7, #4]
 8102a2e:	681b      	ldr	r3, [r3, #0]
 8102a30:	4946      	ldr	r1, [pc, #280]	@ (8102b4c <HAL_MMC_ConfigWideBusOperation+0x188>)
 8102a32:	4618      	mov	r0, r3
 8102a34:	f006 fb3e 	bl	81090b4 <SDMMC_CmdSwitch>
 8102a38:	6238      	str	r0, [r7, #32]
 8102a3a:	e019      	b.n	8102a70 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else if (WideMode == SDMMC_BUS_WIDE_4B)
 8102a3c:	683b      	ldr	r3, [r7, #0]
 8102a3e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8102a42:	d107      	bne.n	8102a54 <HAL_MMC_ConfigWideBusOperation+0x90>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70100U);
 8102a44:	687b      	ldr	r3, [r7, #4]
 8102a46:	681b      	ldr	r3, [r3, #0]
 8102a48:	4941      	ldr	r1, [pc, #260]	@ (8102b50 <HAL_MMC_ConfigWideBusOperation+0x18c>)
 8102a4a:	4618      	mov	r0, r3
 8102a4c:	f006 fb32 	bl	81090b4 <SDMMC_CmdSwitch>
 8102a50:	6238      	str	r0, [r7, #32]
 8102a52:	e00d      	b.n	8102a70 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else if (WideMode == SDMMC_BUS_WIDE_1B)
 8102a54:	683b      	ldr	r3, [r7, #0]
 8102a56:	2b00      	cmp	r3, #0
 8102a58:	d107      	bne.n	8102a6a <HAL_MMC_ConfigWideBusOperation+0xa6>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70000U);
 8102a5a:	687b      	ldr	r3, [r7, #4]
 8102a5c:	681b      	ldr	r3, [r3, #0]
 8102a5e:	493d      	ldr	r1, [pc, #244]	@ (8102b54 <HAL_MMC_ConfigWideBusOperation+0x190>)
 8102a60:	4618      	mov	r0, r3
 8102a62:	f006 fb27 	bl	81090b4 <SDMMC_CmdSwitch>
 8102a66:	6238      	str	r0, [r7, #32]
 8102a68:	e002      	b.n	8102a70 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else
    {
      /* WideMode is not a valid argument*/
      errorstate = HAL_MMC_ERROR_PARAM;
 8102a6a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8102a6e:	623b      	str	r3, [r7, #32]
    }

    /* Check for switch error and violation of the trial number of sending CMD 13 */
    if (errorstate == HAL_MMC_ERROR_NONE)
 8102a70:	6a3b      	ldr	r3, [r7, #32]
 8102a72:	2b00      	cmp	r3, #0
 8102a74:	d152      	bne.n	8102b1c <HAL_MMC_ConfigWideBusOperation+0x158>
    {
      /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
      count = SDMMC_MAX_TRIAL;
 8102a76:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8102a7a:	627b      	str	r3, [r7, #36]	@ 0x24
      do
      {
        errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
 8102a7c:	687b      	ldr	r3, [r7, #4]
 8102a7e:	681a      	ldr	r2, [r3, #0]
 8102a80:	687b      	ldr	r3, [r7, #4]
 8102a82:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102a84:	041b      	lsls	r3, r3, #16
 8102a86:	4619      	mov	r1, r3
 8102a88:	4610      	mov	r0, r2
 8102a8a:	f006 fad0 	bl	810902e <SDMMC_CmdSendStatus>
 8102a8e:	6238      	str	r0, [r7, #32]
        if (errorstate != HAL_MMC_ERROR_NONE)
 8102a90:	6a3b      	ldr	r3, [r7, #32]
 8102a92:	2b00      	cmp	r3, #0
 8102a94:	d112      	bne.n	8102abc <HAL_MMC_ConfigWideBusOperation+0xf8>
        {
          break;
        }

        /* Get command response */
        response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
 8102a96:	687b      	ldr	r3, [r7, #4]
 8102a98:	681b      	ldr	r3, [r3, #0]
 8102a9a:	2100      	movs	r1, #0
 8102a9c:	4618      	mov	r0, r3
 8102a9e:	f006 f982 	bl	8108da6 <SDMMC_GetResponse>
 8102aa2:	61f8      	str	r0, [r7, #28]
        count--;
 8102aa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8102aa6:	3b01      	subs	r3, #1
 8102aa8:	627b      	str	r3, [r7, #36]	@ 0x24
      } while (((response & 0x100U) == 0U) && (count != 0U));
 8102aaa:	69fb      	ldr	r3, [r7, #28]
 8102aac:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8102ab0:	2b00      	cmp	r3, #0
 8102ab2:	d104      	bne.n	8102abe <HAL_MMC_ConfigWideBusOperation+0xfa>
 8102ab4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8102ab6:	2b00      	cmp	r3, #0
 8102ab8:	d1e0      	bne.n	8102a7c <HAL_MMC_ConfigWideBusOperation+0xb8>
 8102aba:	e000      	b.n	8102abe <HAL_MMC_ConfigWideBusOperation+0xfa>
          break;
 8102abc:	bf00      	nop

      /* Check the status after the switch command execution */
      if ((count != 0U) && (errorstate == HAL_MMC_ERROR_NONE))
 8102abe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8102ac0:	2b00      	cmp	r3, #0
 8102ac2:	d025      	beq.n	8102b10 <HAL_MMC_ConfigWideBusOperation+0x14c>
 8102ac4:	6a3b      	ldr	r3, [r7, #32]
 8102ac6:	2b00      	cmp	r3, #0
 8102ac8:	d122      	bne.n	8102b10 <HAL_MMC_ConfigWideBusOperation+0x14c>
      {
        /* Check the bit SWITCH_ERROR of the device status */
        if ((response & 0x80U) != 0U)
 8102aca:	69fb      	ldr	r3, [r7, #28]
 8102acc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8102ad0:	2b00      	cmp	r3, #0
 8102ad2:	d003      	beq.n	8102adc <HAL_MMC_ConfigWideBusOperation+0x118>
        {
          errorstate = SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8102ad4:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8102ad8:	623b      	str	r3, [r7, #32]
        if ((response & 0x80U) != 0U)
 8102ada:	e01f      	b.n	8102b1c <HAL_MMC_ConfigWideBusOperation+0x158>
        }
        else
        {
          /* Configure the SDMMC peripheral */
          Init = hmmc->Init;
 8102adc:	687b      	ldr	r3, [r7, #4]
 8102ade:	f107 0408 	add.w	r4, r7, #8
 8102ae2:	1d1d      	adds	r5, r3, #4
 8102ae4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8102ae6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8102ae8:	682b      	ldr	r3, [r5, #0]
 8102aea:	6023      	str	r3, [r4, #0]
          Init.BusWide = WideMode;
 8102aec:	683b      	ldr	r3, [r7, #0]
 8102aee:	613b      	str	r3, [r7, #16]
          (void)SDMMC_Init(hmmc->Instance, Init);
 8102af0:	687b      	ldr	r3, [r7, #4]
 8102af2:	681c      	ldr	r4, [r3, #0]
 8102af4:	466a      	mov	r2, sp
 8102af6:	f107 0314 	add.w	r3, r7, #20
 8102afa:	e893 0003 	ldmia.w	r3, {r0, r1}
 8102afe:	e882 0003 	stmia.w	r2, {r0, r1}
 8102b02:	f107 0308 	add.w	r3, r7, #8
 8102b06:	cb0e      	ldmia	r3, {r1, r2, r3}
 8102b08:	4620      	mov	r0, r4
 8102b0a:	f006 f8ad 	bl	8108c68 <SDMMC_Init>
        if ((response & 0x80U) != 0U)
 8102b0e:	e005      	b.n	8102b1c <HAL_MMC_ConfigWideBusOperation+0x158>
        }
      }
      else if (count == 0U)
 8102b10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8102b12:	2b00      	cmp	r3, #0
 8102b14:	d102      	bne.n	8102b1c <HAL_MMC_ConfigWideBusOperation+0x158>
      {
        errorstate = SDMMC_ERROR_TIMEOUT;
 8102b16:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8102b1a:	623b      	str	r3, [r7, #32]
      }
    }
  }

  /* Change State */
  hmmc->State = HAL_MMC_STATE_READY;
 8102b1c:	687b      	ldr	r3, [r7, #4]
 8102b1e:	2201      	movs	r2, #1
 8102b20:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  if (errorstate != HAL_MMC_ERROR_NONE)
 8102b24:	6a3b      	ldr	r3, [r7, #32]
 8102b26:	2b00      	cmp	r3, #0
 8102b28:	d00b      	beq.n	8102b42 <HAL_MMC_ConfigWideBusOperation+0x17e>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102b2a:	687b      	ldr	r3, [r7, #4]
 8102b2c:	681b      	ldr	r3, [r3, #0]
 8102b2e:	4a0a      	ldr	r2, [pc, #40]	@ (8102b58 <HAL_MMC_ConfigWideBusOperation+0x194>)
 8102b30:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= errorstate;
 8102b32:	687b      	ldr	r3, [r7, #4]
 8102b34:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102b36:	6a3b      	ldr	r3, [r7, #32]
 8102b38:	431a      	orrs	r2, r3
 8102b3a:	687b      	ldr	r3, [r7, #4]
 8102b3c:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8102b3e:	2301      	movs	r3, #1
 8102b40:	e000      	b.n	8102b44 <HAL_MMC_ConfigWideBusOperation+0x180>
  }

  return HAL_OK;
 8102b42:	2300      	movs	r3, #0
}
 8102b44:	4618      	mov	r0, r3
 8102b46:	3728      	adds	r7, #40	@ 0x28
 8102b48:	46bd      	mov	sp, r7
 8102b4a:	bdb0      	pop	{r4, r5, r7, pc}
 8102b4c:	03b70200 	.word	0x03b70200
 8102b50:	03b70100 	.word	0x03b70100
 8102b54:	03b70000 	.word	0x03b70000
 8102b58:	1fe00fff 	.word	0x1fe00fff

08102b5c <MMC_InitCard>:
  * @brief  Initializes the mmc card.
  * @param  hmmc: Pointer to MMC handle
  * @retval MMC Card error state
  */
static uint32_t MMC_InitCard(MMC_HandleTypeDef *hmmc)
{
 8102b5c:	b5b0      	push	{r4, r5, r7, lr}
 8102b5e:	b096      	sub	sp, #88	@ 0x58
 8102b60:	af02      	add	r7, sp, #8
 8102b62:	6078      	str	r0, [r7, #4]
  HAL_MMC_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t mmc_rca = 2U;
 8102b64:	2302      	movs	r3, #2
 8102b66:	f8a7 304e 	strh.w	r3, [r7, #78]	@ 0x4e
  MMC_InitTypeDef Init;

  /* Check the power State */
  if (SDMMC_GetPowerState(hmmc->Instance) == 0U)
 8102b6a:	687b      	ldr	r3, [r7, #4]
 8102b6c:	681b      	ldr	r3, [r3, #0]
 8102b6e:	4618      	mov	r0, r3
 8102b70:	f006 f8d3 	bl	8108d1a <SDMMC_GetPowerState>
 8102b74:	4603      	mov	r3, r0
 8102b76:	2b00      	cmp	r3, #0
 8102b78:	d102      	bne.n	8102b80 <MMC_InitCard+0x24>
  {
    /* Power off */
    return HAL_MMC_ERROR_REQUEST_NOT_APPLICABLE;
 8102b7a:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8102b7e:	e0e6      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }

  /* Send CMD2 ALL_SEND_CID */
  errorstate = SDMMC_CmdSendCID(hmmc->Instance);
 8102b80:	687b      	ldr	r3, [r7, #4]
 8102b82:	681b      	ldr	r3, [r3, #0]
 8102b84:	4618      	mov	r0, r3
 8102b86:	f006 f9ee 	bl	8108f66 <SDMMC_CmdSendCID>
 8102b8a:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102b8c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102b8e:	2b00      	cmp	r3, #0
 8102b90:	d001      	beq.n	8102b96 <MMC_InitCard+0x3a>
  {
    return errorstate;
 8102b92:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102b94:	e0db      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }
  else
  {
    /* Get Card identification number data */
    hmmc->CID[0U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
 8102b96:	687b      	ldr	r3, [r7, #4]
 8102b98:	681b      	ldr	r3, [r3, #0]
 8102b9a:	2100      	movs	r1, #0
 8102b9c:	4618      	mov	r0, r3
 8102b9e:	f006 f902 	bl	8108da6 <SDMMC_GetResponse>
 8102ba2:	4602      	mov	r2, r0
 8102ba4:	687b      	ldr	r3, [r7, #4]
 8102ba6:	669a      	str	r2, [r3, #104]	@ 0x68
    hmmc->CID[1U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2);
 8102ba8:	687b      	ldr	r3, [r7, #4]
 8102baa:	681b      	ldr	r3, [r3, #0]
 8102bac:	2104      	movs	r1, #4
 8102bae:	4618      	mov	r0, r3
 8102bb0:	f006 f8f9 	bl	8108da6 <SDMMC_GetResponse>
 8102bb4:	4602      	mov	r2, r0
 8102bb6:	687b      	ldr	r3, [r7, #4]
 8102bb8:	66da      	str	r2, [r3, #108]	@ 0x6c
    hmmc->CID[2U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP3);
 8102bba:	687b      	ldr	r3, [r7, #4]
 8102bbc:	681b      	ldr	r3, [r3, #0]
 8102bbe:	2108      	movs	r1, #8
 8102bc0:	4618      	mov	r0, r3
 8102bc2:	f006 f8f0 	bl	8108da6 <SDMMC_GetResponse>
 8102bc6:	4602      	mov	r2, r0
 8102bc8:	687b      	ldr	r3, [r7, #4]
 8102bca:	671a      	str	r2, [r3, #112]	@ 0x70
    hmmc->CID[3U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP4);
 8102bcc:	687b      	ldr	r3, [r7, #4]
 8102bce:	681b      	ldr	r3, [r3, #0]
 8102bd0:	210c      	movs	r1, #12
 8102bd2:	4618      	mov	r0, r3
 8102bd4:	f006 f8e7 	bl	8108da6 <SDMMC_GetResponse>
 8102bd8:	4602      	mov	r2, r0
 8102bda:	687b      	ldr	r3, [r7, #4]
 8102bdc:	675a      	str	r2, [r3, #116]	@ 0x74
  }

  /* Send CMD3 SET_REL_ADDR with RCA = 2 (should be greater than 1) */
  /* MMC Card publishes its RCA. */
  errorstate = SDMMC_CmdSetRelAddMmc(hmmc->Instance, mmc_rca);
 8102bde:	687b      	ldr	r3, [r7, #4]
 8102be0:	681b      	ldr	r3, [r3, #0]
 8102be2:	f8b7 204e 	ldrh.w	r2, [r7, #78]	@ 0x4e
 8102be6:	4611      	mov	r1, r2
 8102be8:	4618      	mov	r0, r3
 8102bea:	f006 f9fb 	bl	8108fe4 <SDMMC_CmdSetRelAddMmc>
 8102bee:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102bf0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102bf2:	2b00      	cmp	r3, #0
 8102bf4:	d001      	beq.n	8102bfa <MMC_InitCard+0x9e>
  {
    return errorstate;
 8102bf6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102bf8:	e0a9      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }

  /* Get the MMC card RCA */
  hmmc->MmcCard.RelCardAdd = mmc_rca;
 8102bfa:	f8b7 204e 	ldrh.w	r2, [r7, #78]	@ 0x4e
 8102bfe:	687b      	ldr	r3, [r7, #4]
 8102c00:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Send CMD9 SEND_CSD with argument as card's RCA */
  errorstate = SDMMC_CmdSendCSD(hmmc->Instance, (uint32_t)(hmmc->MmcCard.RelCardAdd << 16U));
 8102c02:	687b      	ldr	r3, [r7, #4]
 8102c04:	681a      	ldr	r2, [r3, #0]
 8102c06:	687b      	ldr	r3, [r7, #4]
 8102c08:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102c0a:	041b      	lsls	r3, r3, #16
 8102c0c:	4619      	mov	r1, r3
 8102c0e:	4610      	mov	r0, r2
 8102c10:	f006 f9c8 	bl	8108fa4 <SDMMC_CmdSendCSD>
 8102c14:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102c16:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102c18:	2b00      	cmp	r3, #0
 8102c1a:	d001      	beq.n	8102c20 <MMC_InitCard+0xc4>
  {
    return errorstate;
 8102c1c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102c1e:	e096      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }
  else
  {
    /* Get Card Specific Data */
    hmmc->CSD[0U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
 8102c20:	687b      	ldr	r3, [r7, #4]
 8102c22:	681b      	ldr	r3, [r3, #0]
 8102c24:	2100      	movs	r1, #0
 8102c26:	4618      	mov	r0, r3
 8102c28:	f006 f8bd 	bl	8108da6 <SDMMC_GetResponse>
 8102c2c:	4602      	mov	r2, r0
 8102c2e:	687b      	ldr	r3, [r7, #4]
 8102c30:	659a      	str	r2, [r3, #88]	@ 0x58
    hmmc->CSD[1U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2);
 8102c32:	687b      	ldr	r3, [r7, #4]
 8102c34:	681b      	ldr	r3, [r3, #0]
 8102c36:	2104      	movs	r1, #4
 8102c38:	4618      	mov	r0, r3
 8102c3a:	f006 f8b4 	bl	8108da6 <SDMMC_GetResponse>
 8102c3e:	4602      	mov	r2, r0
 8102c40:	687b      	ldr	r3, [r7, #4]
 8102c42:	65da      	str	r2, [r3, #92]	@ 0x5c
    hmmc->CSD[2U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP3);
 8102c44:	687b      	ldr	r3, [r7, #4]
 8102c46:	681b      	ldr	r3, [r3, #0]
 8102c48:	2108      	movs	r1, #8
 8102c4a:	4618      	mov	r0, r3
 8102c4c:	f006 f8ab 	bl	8108da6 <SDMMC_GetResponse>
 8102c50:	4602      	mov	r2, r0
 8102c52:	687b      	ldr	r3, [r7, #4]
 8102c54:	661a      	str	r2, [r3, #96]	@ 0x60
    hmmc->CSD[3U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP4);
 8102c56:	687b      	ldr	r3, [r7, #4]
 8102c58:	681b      	ldr	r3, [r3, #0]
 8102c5a:	210c      	movs	r1, #12
 8102c5c:	4618      	mov	r0, r3
 8102c5e:	f006 f8a2 	bl	8108da6 <SDMMC_GetResponse>
 8102c62:	4602      	mov	r2, r0
 8102c64:	687b      	ldr	r3, [r7, #4]
 8102c66:	665a      	str	r2, [r3, #100]	@ 0x64
  }

  /* Get the Card Class */
  hmmc->MmcCard.Class = (SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2) >> 20U);
 8102c68:	687b      	ldr	r3, [r7, #4]
 8102c6a:	681b      	ldr	r3, [r3, #0]
 8102c6c:	2104      	movs	r1, #4
 8102c6e:	4618      	mov	r0, r3
 8102c70:	f006 f899 	bl	8108da6 <SDMMC_GetResponse>
 8102c74:	4603      	mov	r3, r0
 8102c76:	0d1a      	lsrs	r2, r3, #20
 8102c78:	687b      	ldr	r3, [r7, #4]
 8102c7a:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
 8102c7c:	687b      	ldr	r3, [r7, #4]
 8102c7e:	681a      	ldr	r2, [r3, #0]
 8102c80:	687b      	ldr	r3, [r7, #4]
 8102c82:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102c84:	041b      	lsls	r3, r3, #16
 8102c86:	4619      	mov	r1, r3
 8102c88:	4610      	mov	r0, r2
 8102c8a:	f006 f92b 	bl	8108ee4 <SDMMC_CmdSelDesel>
 8102c8e:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102c90:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102c92:	2b00      	cmp	r3, #0
 8102c94:	d001      	beq.n	8102c9a <MMC_InitCard+0x13e>
  {
    return errorstate;
 8102c96:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102c98:	e059      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }

  /* Get CSD parameters */
  if (HAL_MMC_GetCardCSD(hmmc, &CSD) != HAL_OK)
 8102c9a:	f107 031c 	add.w	r3, r7, #28
 8102c9e:	4619      	mov	r1, r3
 8102ca0:	6878      	ldr	r0, [r7, #4]
 8102ca2:	f7ff fbef 	bl	8102484 <HAL_MMC_GetCardCSD>
 8102ca6:	4603      	mov	r3, r0
 8102ca8:	2b00      	cmp	r3, #0
 8102caa:	d002      	beq.n	8102cb2 <MMC_InitCard+0x156>
  {
    return hmmc->ErrorCode;
 8102cac:	687b      	ldr	r3, [r7, #4]
 8102cae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102cb0:	e04d      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
 8102cb2:	687b      	ldr	r3, [r7, #4]
 8102cb4:	681a      	ldr	r2, [r3, #0]
 8102cb6:	687b      	ldr	r3, [r7, #4]
 8102cb8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102cba:	041b      	lsls	r3, r3, #16
 8102cbc:	4619      	mov	r1, r3
 8102cbe:	4610      	mov	r0, r2
 8102cc0:	f006 f9b5 	bl	810902e <SDMMC_CmdSendStatus>
 8102cc4:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102cc6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102cc8:	2b00      	cmp	r3, #0
 8102cca:	d005      	beq.n	8102cd8 <MMC_InitCard+0x17c>
  {
    hmmc->ErrorCode |= errorstate;
 8102ccc:	687b      	ldr	r3, [r7, #4]
 8102cce:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102cd0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102cd2:	431a      	orrs	r2, r3
 8102cd4:	687b      	ldr	r3, [r7, #4]
 8102cd6:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  /* Get Extended CSD parameters */
  if (HAL_MMC_GetCardExtCSD(hmmc, hmmc->Ext_CSD, SDMMC_DATATIMEOUT) != HAL_OK)
 8102cd8:	687b      	ldr	r3, [r7, #4]
 8102cda:	3378      	adds	r3, #120	@ 0x78
 8102cdc:	f04f 32ff 	mov.w	r2, #4294967295
 8102ce0:	4619      	mov	r1, r3
 8102ce2:	6878      	ldr	r0, [r7, #4]
 8102ce4:	f7ff fd72 	bl	81027cc <HAL_MMC_GetCardExtCSD>
 8102ce8:	4603      	mov	r3, r0
 8102cea:	2b00      	cmp	r3, #0
 8102cec:	d002      	beq.n	8102cf4 <MMC_InitCard+0x198>
  {
    return hmmc->ErrorCode;
 8102cee:	687b      	ldr	r3, [r7, #4]
 8102cf0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102cf2:	e02c      	b.n	8102d4e <MMC_InitCard+0x1f2>
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
 8102cf4:	687b      	ldr	r3, [r7, #4]
 8102cf6:	681a      	ldr	r2, [r3, #0]
 8102cf8:	687b      	ldr	r3, [r7, #4]
 8102cfa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102cfc:	041b      	lsls	r3, r3, #16
 8102cfe:	4619      	mov	r1, r3
 8102d00:	4610      	mov	r0, r2
 8102d02:	f006 f994 	bl	810902e <SDMMC_CmdSendStatus>
 8102d06:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102d08:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102d0a:	2b00      	cmp	r3, #0
 8102d0c:	d005      	beq.n	8102d1a <MMC_InitCard+0x1be>
  {
    hmmc->ErrorCode |= errorstate;
 8102d0e:	687b      	ldr	r3, [r7, #4]
 8102d10:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102d12:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8102d14:	431a      	orrs	r2, r3
 8102d16:	687b      	ldr	r3, [r7, #4]
 8102d18:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  /* Configure the SDMMC peripheral */
  Init = hmmc->Init;
 8102d1a:	687b      	ldr	r3, [r7, #4]
 8102d1c:	f107 0408 	add.w	r4, r7, #8
 8102d20:	1d1d      	adds	r5, r3, #4
 8102d22:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8102d24:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8102d26:	682b      	ldr	r3, [r5, #0]
 8102d28:	6023      	str	r3, [r4, #0]
  Init.BusWide = SDMMC_BUS_WIDE_1B;
 8102d2a:	2300      	movs	r3, #0
 8102d2c:	613b      	str	r3, [r7, #16]
  (void)SDMMC_Init(hmmc->Instance, Init);
 8102d2e:	687b      	ldr	r3, [r7, #4]
 8102d30:	681c      	ldr	r4, [r3, #0]
 8102d32:	466a      	mov	r2, sp
 8102d34:	f107 0314 	add.w	r3, r7, #20
 8102d38:	e893 0003 	ldmia.w	r3, {r0, r1}
 8102d3c:	e882 0003 	stmia.w	r2, {r0, r1}
 8102d40:	f107 0308 	add.w	r3, r7, #8
 8102d44:	cb0e      	ldmia	r3, {r1, r2, r3}
 8102d46:	4620      	mov	r0, r4
 8102d48:	f005 ff8e 	bl	8108c68 <SDMMC_Init>

  /* All cards are initialized */
  return HAL_MMC_ERROR_NONE;
 8102d4c:	2300      	movs	r3, #0
}
 8102d4e:	4618      	mov	r0, r3
 8102d50:	3750      	adds	r7, #80	@ 0x50
 8102d52:	46bd      	mov	sp, r7
 8102d54:	bdb0      	pop	{r4, r5, r7, pc}
	...

08102d58 <MMC_PowerON>:
  *         in the MMC handle.
  * @param  hmmc: Pointer to MMC handle
  * @retval error state
  */
static uint32_t MMC_PowerON(MMC_HandleTypeDef *hmmc)
{
 8102d58:	b580      	push	{r7, lr}
 8102d5a:	b086      	sub	sp, #24
 8102d5c:	af00      	add	r7, sp, #0
 8102d5e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8102d60:	2300      	movs	r3, #0
 8102d62:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U;
 8102d64:	2300      	movs	r3, #0
 8102d66:	617b      	str	r3, [r7, #20]
  uint32_t validvoltage = 0U;
 8102d68:	2300      	movs	r3, #0
 8102d6a:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hmmc->Instance);
 8102d6c:	687b      	ldr	r3, [r7, #4]
 8102d6e:	681b      	ldr	r3, [r3, #0]
 8102d70:	4618      	mov	r0, r3
 8102d72:	f006 f8da 	bl	8108f2a <SDMMC_CmdGoIdleState>
 8102d76:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102d78:	68fb      	ldr	r3, [r7, #12]
 8102d7a:	2b00      	cmp	r3, #0
 8102d7c:	d027      	beq.n	8102dce <MMC_PowerON+0x76>
  {
    return errorstate;
 8102d7e:	68fb      	ldr	r3, [r7, #12]
 8102d80:	e034      	b.n	8102dec <MMC_PowerON+0x94>
  }

  while (validvoltage == 0U)
  {
    if (count++ == SDMMC_MAX_VOLT_TRIAL)
 8102d82:	68bb      	ldr	r3, [r7, #8]
 8102d84:	1c5a      	adds	r2, r3, #1
 8102d86:	60ba      	str	r2, [r7, #8]
 8102d88:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8102d8c:	4293      	cmp	r3, r2
 8102d8e:	d102      	bne.n	8102d96 <MMC_PowerON+0x3e>
    {
      return HAL_MMC_ERROR_INVALID_VOLTRANGE;
 8102d90:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8102d94:	e02a      	b.n	8102dec <MMC_PowerON+0x94>
    }

    /* SEND CMD1 APP_CMD with voltage range as argument */
    errorstate = SDMMC_CmdOpCondition(hmmc->Instance, MMC_VOLTAGE_RANGE);
 8102d96:	687b      	ldr	r3, [r7, #4]
 8102d98:	681b      	ldr	r3, [r3, #0]
 8102d9a:	4916      	ldr	r1, [pc, #88]	@ (8102df4 <MMC_PowerON+0x9c>)
 8102d9c:	4618      	mov	r0, r3
 8102d9e:	f006 f969 	bl	8109074 <SDMMC_CmdOpCondition>
 8102da2:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_MMC_ERROR_NONE)
 8102da4:	68fb      	ldr	r3, [r7, #12]
 8102da6:	2b00      	cmp	r3, #0
 8102da8:	d002      	beq.n	8102db0 <MMC_PowerON+0x58>
    {
      return HAL_MMC_ERROR_UNSUPPORTED_FEATURE;
 8102daa:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8102dae:	e01d      	b.n	8102dec <MMC_PowerON+0x94>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
 8102db0:	687b      	ldr	r3, [r7, #4]
 8102db2:	681b      	ldr	r3, [r3, #0]
 8102db4:	2100      	movs	r1, #0
 8102db6:	4618      	mov	r0, r3
 8102db8:	f005 fff5 	bl	8108da6 <SDMMC_GetResponse>
 8102dbc:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8102dbe:	697b      	ldr	r3, [r7, #20]
 8102dc0:	0fdb      	lsrs	r3, r3, #31
 8102dc2:	2b01      	cmp	r3, #1
 8102dc4:	d101      	bne.n	8102dca <MMC_PowerON+0x72>
 8102dc6:	2301      	movs	r3, #1
 8102dc8:	e000      	b.n	8102dcc <MMC_PowerON+0x74>
 8102dca:	2300      	movs	r3, #0
 8102dcc:	613b      	str	r3, [r7, #16]
  while (validvoltage == 0U)
 8102dce:	693b      	ldr	r3, [r7, #16]
 8102dd0:	2b00      	cmp	r3, #0
 8102dd2:	d0d6      	beq.n	8102d82 <MMC_PowerON+0x2a>
  }

  /* When power routine is finished and command returns valid voltage */
  if (((response & (0xFF000000U)) >> 24) == 0xC0U)
 8102dd4:	697b      	ldr	r3, [r7, #20]
 8102dd6:	0e1b      	lsrs	r3, r3, #24
 8102dd8:	2bc0      	cmp	r3, #192	@ 0xc0
 8102dda:	d103      	bne.n	8102de4 <MMC_PowerON+0x8c>
  {
    hmmc->MmcCard.CardType = MMC_HIGH_CAPACITY_CARD;
 8102ddc:	687b      	ldr	r3, [r7, #4]
 8102dde:	2201      	movs	r2, #1
 8102de0:	63da      	str	r2, [r3, #60]	@ 0x3c
 8102de2:	e002      	b.n	8102dea <MMC_PowerON+0x92>
  }
  else
  {
    hmmc->MmcCard.CardType = MMC_LOW_CAPACITY_CARD;
 8102de4:	687b      	ldr	r3, [r7, #4]
 8102de6:	2200      	movs	r2, #0
 8102de8:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  return HAL_MMC_ERROR_NONE;
 8102dea:	2300      	movs	r3, #0
}
 8102dec:	4618      	mov	r0, r3
 8102dee:	3718      	adds	r7, #24
 8102df0:	46bd      	mov	sp, r7
 8102df2:	bd80      	pop	{r7, pc}
 8102df4:	c0ff8000 	.word	0xc0ff8000

08102df8 <MMC_ReadExtCSD>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
static HAL_StatusTypeDef MMC_ReadExtCSD(MMC_HandleTypeDef *hmmc, uint32_t *pFieldData,
                                        uint16_t FieldIndex, uint32_t Timeout)
{
 8102df8:	b580      	push	{r7, lr}
 8102dfa:	b090      	sub	sp, #64	@ 0x40
 8102dfc:	af00      	add	r7, sp, #0
 8102dfe:	60f8      	str	r0, [r7, #12]
 8102e00:	60b9      	str	r1, [r7, #8]
 8102e02:	603b      	str	r3, [r7, #0]
 8102e04:	4613      	mov	r3, r2
 8102e06:	80fb      	strh	r3, [r7, #6]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8102e08:	f7fe fdae 	bl	8101968 <HAL_GetTick>
 8102e0c:	6378      	str	r0, [r7, #52]	@ 0x34
  uint32_t count;
  uint32_t i = 0;
 8102e0e:	2300      	movs	r3, #0
 8102e10:	63bb      	str	r3, [r7, #56]	@ 0x38
  uint32_t tmp_data;

  hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
 8102e12:	68fb      	ldr	r3, [r7, #12]
 8102e14:	2200      	movs	r2, #0
 8102e16:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Initialize data control register */
  hmmc->Instance->DCTRL = 0;
 8102e18:	68fb      	ldr	r3, [r7, #12]
 8102e1a:	681b      	ldr	r3, [r3, #0]
 8102e1c:	2200      	movs	r2, #0
 8102e1e:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Configure the MMC DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8102e20:	f04f 33ff 	mov.w	r3, #4294967295
 8102e24:	617b      	str	r3, [r7, #20]
  config.DataLength    = MMC_BLOCKSIZE;
 8102e26:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8102e2a:	61bb      	str	r3, [r7, #24]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8102e2c:	2390      	movs	r3, #144	@ 0x90
 8102e2e:	61fb      	str	r3, [r7, #28]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8102e30:	2302      	movs	r3, #2
 8102e32:	623b      	str	r3, [r7, #32]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8102e34:	2300      	movs	r3, #0
 8102e36:	627b      	str	r3, [r7, #36]	@ 0x24
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8102e38:	2301      	movs	r3, #1
 8102e3a:	62bb      	str	r3, [r7, #40]	@ 0x28
  (void)SDMMC_ConfigData(hmmc->Instance, &config);
 8102e3c:	68fb      	ldr	r3, [r7, #12]
 8102e3e:	681b      	ldr	r3, [r3, #0]
 8102e40:	f107 0214 	add.w	r2, r7, #20
 8102e44:	4611      	mov	r1, r2
 8102e46:	4618      	mov	r0, r3
 8102e48:	f005 ffc0 	bl	8108dcc <SDMMC_ConfigData>

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdSendEXTCSD(hmmc->Instance, 0);
 8102e4c:	68fb      	ldr	r3, [r7, #12]
 8102e4e:	681b      	ldr	r3, [r3, #0]
 8102e50:	2100      	movs	r1, #0
 8102e52:	4618      	mov	r0, r3
 8102e54:	f006 f951 	bl	81090fa <SDMMC_CmdSendEXTCSD>
 8102e58:	6338      	str	r0, [r7, #48]	@ 0x30
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102e5a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8102e5c:	2b00      	cmp	r3, #0
 8102e5e:	d04e      	beq.n	8102efe <MMC_ReadExtCSD+0x106>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102e60:	68fb      	ldr	r3, [r7, #12]
 8102e62:	681b      	ldr	r3, [r3, #0]
 8102e64:	4a5c      	ldr	r2, [pc, #368]	@ (8102fd8 <MMC_ReadExtCSD+0x1e0>)
 8102e66:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= errorstate;
 8102e68:	68fb      	ldr	r3, [r7, #12]
 8102e6a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102e6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8102e6e:	431a      	orrs	r2, r3
 8102e70:	68fb      	ldr	r3, [r7, #12]
 8102e72:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 8102e74:	68fb      	ldr	r3, [r7, #12]
 8102e76:	2201      	movs	r2, #1
 8102e78:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 8102e7c:	2301      	movs	r3, #1
 8102e7e:	e0a6      	b.n	8102fce <MMC_ReadExtCSD+0x1d6>

  /* Poll on SDMMC flags */
  while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
                             SDMMC_FLAG_DATAEND))
  {
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF))
 8102e80:	68fb      	ldr	r3, [r7, #12]
 8102e82:	681b      	ldr	r3, [r3, #0]
 8102e84:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102e86:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8102e8a:	2b00      	cmp	r3, #0
 8102e8c:	d01c      	beq.n	8102ec8 <MMC_ReadExtCSD+0xd0>
    {
      /* Read data from SDMMC Rx FIFO */
      for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8102e8e:	2300      	movs	r3, #0
 8102e90:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8102e92:	e013      	b.n	8102ebc <MMC_ReadExtCSD+0xc4>
      {
        tmp_data = SDMMC_ReadFIFO(hmmc->Instance);
 8102e94:	68fb      	ldr	r3, [r7, #12]
 8102e96:	681b      	ldr	r3, [r3, #0]
 8102e98:	4618      	mov	r0, r3
 8102e9a:	f005 ff0f 	bl	8108cbc <SDMMC_ReadFIFO>
 8102e9e:	62f8      	str	r0, [r7, #44]	@ 0x2c
        /* eg : SEC_COUNT   : FieldIndex = 212 => i+count = 53 */
        /*      DEVICE_TYPE : FieldIndex = 196 => i+count = 49 */
        if ((i + count) == ((uint32_t)FieldIndex / 4U))
 8102ea0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8102ea2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8102ea4:	4413      	add	r3, r2
 8102ea6:	88fa      	ldrh	r2, [r7, #6]
 8102ea8:	0892      	lsrs	r2, r2, #2
 8102eaa:	b292      	uxth	r2, r2
 8102eac:	4293      	cmp	r3, r2
 8102eae:	d102      	bne.n	8102eb6 <MMC_ReadExtCSD+0xbe>
        {
          *pFieldData = tmp_data;
 8102eb0:	68bb      	ldr	r3, [r7, #8]
 8102eb2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8102eb4:	601a      	str	r2, [r3, #0]
      for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8102eb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8102eb8:	3301      	adds	r3, #1
 8102eba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8102ebc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8102ebe:	2b07      	cmp	r3, #7
 8102ec0:	d9e8      	bls.n	8102e94 <MMC_ReadExtCSD+0x9c>
        }
      }
      i += 8U;
 8102ec2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8102ec4:	3308      	adds	r3, #8
 8102ec6:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
 8102ec8:	f7fe fd4e 	bl	8101968 <HAL_GetTick>
 8102ecc:	4602      	mov	r2, r0
 8102ece:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8102ed0:	1ad3      	subs	r3, r2, r3
 8102ed2:	683a      	ldr	r2, [r7, #0]
 8102ed4:	429a      	cmp	r2, r3
 8102ed6:	d902      	bls.n	8102ede <MMC_ReadExtCSD+0xe6>
 8102ed8:	683b      	ldr	r3, [r7, #0]
 8102eda:	2b00      	cmp	r3, #0
 8102edc:	d10f      	bne.n	8102efe <MMC_ReadExtCSD+0x106>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102ede:	68fb      	ldr	r3, [r7, #12]
 8102ee0:	681b      	ldr	r3, [r3, #0]
 8102ee2:	4a3d      	ldr	r2, [pc, #244]	@ (8102fd8 <MMC_ReadExtCSD+0x1e0>)
 8102ee4:	639a      	str	r2, [r3, #56]	@ 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_TIMEOUT;
 8102ee6:	68fb      	ldr	r3, [r7, #12]
 8102ee8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102eea:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
 8102eee:	68fb      	ldr	r3, [r7, #12]
 8102ef0:	635a      	str	r2, [r3, #52]	@ 0x34
      hmmc->State = HAL_MMC_STATE_READY;
 8102ef2:	68fb      	ldr	r3, [r7, #12]
 8102ef4:	2201      	movs	r2, #1
 8102ef6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_TIMEOUT;
 8102efa:	2303      	movs	r3, #3
 8102efc:	e067      	b.n	8102fce <MMC_ReadExtCSD+0x1d6>
  while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
 8102efe:	68fb      	ldr	r3, [r7, #12]
 8102f00:	681b      	ldr	r3, [r3, #0]
 8102f02:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f04:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
 8102f08:	2b00      	cmp	r3, #0
 8102f0a:	d0b9      	beq.n	8102e80 <MMC_ReadExtCSD+0x88>
    }
  }

  /* Get error state */
  if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
 8102f0c:	68fb      	ldr	r3, [r7, #12]
 8102f0e:	681b      	ldr	r3, [r3, #0]
 8102f10:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f12:	f003 0308 	and.w	r3, r3, #8
 8102f16:	2b00      	cmp	r3, #0
 8102f18:	d00f      	beq.n	8102f3a <MMC_ReadExtCSD+0x142>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102f1a:	68fb      	ldr	r3, [r7, #12]
 8102f1c:	681b      	ldr	r3, [r3, #0]
 8102f1e:	4a2e      	ldr	r2, [pc, #184]	@ (8102fd8 <MMC_ReadExtCSD+0x1e0>)
 8102f20:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
 8102f22:	68fb      	ldr	r3, [r7, #12]
 8102f24:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f26:	f043 0208 	orr.w	r2, r3, #8
 8102f2a:	68fb      	ldr	r3, [r7, #12]
 8102f2c:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 8102f2e:	68fb      	ldr	r3, [r7, #12]
 8102f30:	2201      	movs	r2, #1
 8102f32:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 8102f36:	2301      	movs	r3, #1
 8102f38:	e049      	b.n	8102fce <MMC_ReadExtCSD+0x1d6>
  }
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
 8102f3a:	68fb      	ldr	r3, [r7, #12]
 8102f3c:	681b      	ldr	r3, [r3, #0]
 8102f3e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f40:	f003 0302 	and.w	r3, r3, #2
 8102f44:	2b00      	cmp	r3, #0
 8102f46:	d00f      	beq.n	8102f68 <MMC_ReadExtCSD+0x170>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102f48:	68fb      	ldr	r3, [r7, #12]
 8102f4a:	681b      	ldr	r3, [r3, #0]
 8102f4c:	4a22      	ldr	r2, [pc, #136]	@ (8102fd8 <MMC_ReadExtCSD+0x1e0>)
 8102f4e:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
 8102f50:	68fb      	ldr	r3, [r7, #12]
 8102f52:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f54:	f043 0202 	orr.w	r2, r3, #2
 8102f58:	68fb      	ldr	r3, [r7, #12]
 8102f5a:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 8102f5c:	68fb      	ldr	r3, [r7, #12]
 8102f5e:	2201      	movs	r2, #1
 8102f60:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 8102f64:	2301      	movs	r3, #1
 8102f66:	e032      	b.n	8102fce <MMC_ReadExtCSD+0x1d6>
  }
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR))
 8102f68:	68fb      	ldr	r3, [r7, #12]
 8102f6a:	681b      	ldr	r3, [r3, #0]
 8102f6c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f6e:	f003 0320 	and.w	r3, r3, #32
 8102f72:	2b00      	cmp	r3, #0
 8102f74:	d00f      	beq.n	8102f96 <MMC_ReadExtCSD+0x19e>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
 8102f76:	68fb      	ldr	r3, [r7, #12]
 8102f78:	681b      	ldr	r3, [r3, #0]
 8102f7a:	4a17      	ldr	r2, [pc, #92]	@ (8102fd8 <MMC_ReadExtCSD+0x1e0>)
 8102f7c:	639a      	str	r2, [r3, #56]	@ 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
 8102f7e:	68fb      	ldr	r3, [r7, #12]
 8102f80:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102f82:	f043 0220 	orr.w	r2, r3, #32
 8102f86:	68fb      	ldr	r3, [r7, #12]
 8102f88:	635a      	str	r2, [r3, #52]	@ 0x34
    hmmc->State = HAL_MMC_STATE_READY;
 8102f8a:	68fb      	ldr	r3, [r7, #12]
 8102f8c:	2201      	movs	r2, #1
 8102f8e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 8102f92:	2301      	movs	r3, #1
 8102f94:	e01b      	b.n	8102fce <MMC_ReadExtCSD+0x1d6>
  {
    /* Nothing to do */
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16));
 8102f96:	68fb      	ldr	r3, [r7, #12]
 8102f98:	681a      	ldr	r2, [r3, #0]
 8102f9a:	68fb      	ldr	r3, [r7, #12]
 8102f9c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8102f9e:	041b      	lsls	r3, r3, #16
 8102fa0:	4619      	mov	r1, r3
 8102fa2:	4610      	mov	r0, r2
 8102fa4:	f006 f843 	bl	810902e <SDMMC_CmdSendStatus>
 8102fa8:	6338      	str	r0, [r7, #48]	@ 0x30
  if (errorstate != HAL_MMC_ERROR_NONE)
 8102faa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8102fac:	2b00      	cmp	r3, #0
 8102fae:	d005      	beq.n	8102fbc <MMC_ReadExtCSD+0x1c4>
  {
    hmmc->ErrorCode |= errorstate;
 8102fb0:	68fb      	ldr	r3, [r7, #12]
 8102fb2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8102fb4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8102fb6:	431a      	orrs	r2, r3
 8102fb8:	68fb      	ldr	r3, [r7, #12]
 8102fba:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  /* Clear all the static flags */
  __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
 8102fbc:	68fb      	ldr	r3, [r7, #12]
 8102fbe:	681b      	ldr	r3, [r3, #0]
 8102fc0:	4a06      	ldr	r2, [pc, #24]	@ (8102fdc <MMC_ReadExtCSD+0x1e4>)
 8102fc2:	639a      	str	r2, [r3, #56]	@ 0x38

  hmmc->State = HAL_MMC_STATE_READY;
 8102fc4:	68fb      	ldr	r3, [r7, #12]
 8102fc6:	2201      	movs	r2, #1
 8102fc8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return HAL_OK;
 8102fcc:	2300      	movs	r3, #0
}
 8102fce:	4618      	mov	r0, r3
 8102fd0:	3740      	adds	r7, #64	@ 0x40
 8102fd2:	46bd      	mov	sp, r7
 8102fd4:	bd80      	pop	{r7, pc}
 8102fd6:	bf00      	nop
 8102fd8:	1fe00fff 	.word	0x1fe00fff
 8102fdc:	18000f3a 	.word	0x18000f3a

08102fe0 <MMC_Read_IT>:
  * @param  hmmc: pointer to a MMC_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void MMC_Read_IT(MMC_HandleTypeDef *hmmc)
{
 8102fe0:	b580      	push	{r7, lr}
 8102fe2:	b086      	sub	sp, #24
 8102fe4:	af00      	add	r7, sp, #0
 8102fe6:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  uint8_t *tmp;

  tmp = hmmc->pRxBuffPtr;
 8102fe8:	687b      	ldr	r3, [r7, #4]
 8102fea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8102fec:	613b      	str	r3, [r7, #16]

  if (hmmc->RxXferSize >= SDMMC_FIFO_SIZE)
 8102fee:	687b      	ldr	r3, [r7, #4]
 8102ff0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8102ff2:	2b1f      	cmp	r3, #31
 8102ff4:	d936      	bls.n	8103064 <MMC_Read_IT+0x84>
  {
    /* Read data from SDMMC Rx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8102ff6:	2300      	movs	r3, #0
 8102ff8:	617b      	str	r3, [r7, #20]
 8102ffa:	e027      	b.n	810304c <MMC_Read_IT+0x6c>
    {
      data = SDMMC_ReadFIFO(hmmc->Instance);
 8102ffc:	687b      	ldr	r3, [r7, #4]
 8102ffe:	681b      	ldr	r3, [r3, #0]
 8103000:	4618      	mov	r0, r3
 8103002:	f005 fe5b 	bl	8108cbc <SDMMC_ReadFIFO>
 8103006:	60f8      	str	r0, [r7, #12]
      *tmp = (uint8_t)(data & 0xFFU);
 8103008:	68fb      	ldr	r3, [r7, #12]
 810300a:	b2da      	uxtb	r2, r3
 810300c:	693b      	ldr	r3, [r7, #16]
 810300e:	701a      	strb	r2, [r3, #0]
      tmp++;
 8103010:	693b      	ldr	r3, [r7, #16]
 8103012:	3301      	adds	r3, #1
 8103014:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8103016:	68fb      	ldr	r3, [r7, #12]
 8103018:	0a1b      	lsrs	r3, r3, #8
 810301a:	b2da      	uxtb	r2, r3
 810301c:	693b      	ldr	r3, [r7, #16]
 810301e:	701a      	strb	r2, [r3, #0]
      tmp++;
 8103020:	693b      	ldr	r3, [r7, #16]
 8103022:	3301      	adds	r3, #1
 8103024:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8103026:	68fb      	ldr	r3, [r7, #12]
 8103028:	0c1b      	lsrs	r3, r3, #16
 810302a:	b2da      	uxtb	r2, r3
 810302c:	693b      	ldr	r3, [r7, #16]
 810302e:	701a      	strb	r2, [r3, #0]
      tmp++;
 8103030:	693b      	ldr	r3, [r7, #16]
 8103032:	3301      	adds	r3, #1
 8103034:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 8103036:	68fb      	ldr	r3, [r7, #12]
 8103038:	0e1b      	lsrs	r3, r3, #24
 810303a:	b2da      	uxtb	r2, r3
 810303c:	693b      	ldr	r3, [r7, #16]
 810303e:	701a      	strb	r2, [r3, #0]
      tmp++;
 8103040:	693b      	ldr	r3, [r7, #16]
 8103042:	3301      	adds	r3, #1
 8103044:	613b      	str	r3, [r7, #16]
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8103046:	697b      	ldr	r3, [r7, #20]
 8103048:	3301      	adds	r3, #1
 810304a:	617b      	str	r3, [r7, #20]
 810304c:	697b      	ldr	r3, [r7, #20]
 810304e:	2b07      	cmp	r3, #7
 8103050:	d9d4      	bls.n	8102ffc <MMC_Read_IT+0x1c>
    }

    hmmc->pRxBuffPtr = tmp;
 8103052:	687b      	ldr	r3, [r7, #4]
 8103054:	693a      	ldr	r2, [r7, #16]
 8103056:	625a      	str	r2, [r3, #36]	@ 0x24
    hmmc->RxXferSize -= SDMMC_FIFO_SIZE;
 8103058:	687b      	ldr	r3, [r7, #4]
 810305a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810305c:	f1a3 0220 	sub.w	r2, r3, #32
 8103060:	687b      	ldr	r3, [r7, #4]
 8103062:	629a      	str	r2, [r3, #40]	@ 0x28
  }
}
 8103064:	bf00      	nop
 8103066:	3718      	adds	r7, #24
 8103068:	46bd      	mov	sp, r7
 810306a:	bd80      	pop	{r7, pc}

0810306c <MMC_Write_IT>:
  * @param  hmmc: pointer to a MMC_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void MMC_Write_IT(MMC_HandleTypeDef *hmmc)
{
 810306c:	b580      	push	{r7, lr}
 810306e:	b086      	sub	sp, #24
 8103070:	af00      	add	r7, sp, #0
 8103072:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  const uint8_t *tmp;

  tmp = hmmc->pTxBuffPtr;
 8103074:	687b      	ldr	r3, [r7, #4]
 8103076:	69db      	ldr	r3, [r3, #28]
 8103078:	613b      	str	r3, [r7, #16]

  if (hmmc->TxXferSize >= SDMMC_FIFO_SIZE)
 810307a:	687b      	ldr	r3, [r7, #4]
 810307c:	6a1b      	ldr	r3, [r3, #32]
 810307e:	2b1f      	cmp	r3, #31
 8103080:	d93a      	bls.n	81030f8 <MMC_Write_IT+0x8c>
  {
    /* Write data to SDMMC Tx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8103082:	2300      	movs	r3, #0
 8103084:	617b      	str	r3, [r7, #20]
 8103086:	e02b      	b.n	81030e0 <MMC_Write_IT+0x74>
    {
      data = (uint32_t)(*tmp);
 8103088:	693b      	ldr	r3, [r7, #16]
 810308a:	781b      	ldrb	r3, [r3, #0]
 810308c:	60fb      	str	r3, [r7, #12]
      tmp++;
 810308e:	693b      	ldr	r3, [r7, #16]
 8103090:	3301      	adds	r3, #1
 8103092:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 8U);
 8103094:	693b      	ldr	r3, [r7, #16]
 8103096:	781b      	ldrb	r3, [r3, #0]
 8103098:	021a      	lsls	r2, r3, #8
 810309a:	68fb      	ldr	r3, [r7, #12]
 810309c:	4313      	orrs	r3, r2
 810309e:	60fb      	str	r3, [r7, #12]
      tmp++;
 81030a0:	693b      	ldr	r3, [r7, #16]
 81030a2:	3301      	adds	r3, #1
 81030a4:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 16U);
 81030a6:	693b      	ldr	r3, [r7, #16]
 81030a8:	781b      	ldrb	r3, [r3, #0]
 81030aa:	041a      	lsls	r2, r3, #16
 81030ac:	68fb      	ldr	r3, [r7, #12]
 81030ae:	4313      	orrs	r3, r2
 81030b0:	60fb      	str	r3, [r7, #12]
      tmp++;
 81030b2:	693b      	ldr	r3, [r7, #16]
 81030b4:	3301      	adds	r3, #1
 81030b6:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 24U);
 81030b8:	693b      	ldr	r3, [r7, #16]
 81030ba:	781b      	ldrb	r3, [r3, #0]
 81030bc:	061a      	lsls	r2, r3, #24
 81030be:	68fb      	ldr	r3, [r7, #12]
 81030c0:	4313      	orrs	r3, r2
 81030c2:	60fb      	str	r3, [r7, #12]
      tmp++;
 81030c4:	693b      	ldr	r3, [r7, #16]
 81030c6:	3301      	adds	r3, #1
 81030c8:	613b      	str	r3, [r7, #16]
      (void)SDMMC_WriteFIFO(hmmc->Instance, &data);
 81030ca:	687b      	ldr	r3, [r7, #4]
 81030cc:	681b      	ldr	r3, [r3, #0]
 81030ce:	f107 020c 	add.w	r2, r7, #12
 81030d2:	4611      	mov	r1, r2
 81030d4:	4618      	mov	r0, r3
 81030d6:	f005 fdfe 	bl	8108cd6 <SDMMC_WriteFIFO>
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 81030da:	697b      	ldr	r3, [r7, #20]
 81030dc:	3301      	adds	r3, #1
 81030de:	617b      	str	r3, [r7, #20]
 81030e0:	697b      	ldr	r3, [r7, #20]
 81030e2:	2b07      	cmp	r3, #7
 81030e4:	d9d0      	bls.n	8103088 <MMC_Write_IT+0x1c>
    }

    hmmc->pTxBuffPtr = tmp;
 81030e6:	687b      	ldr	r3, [r7, #4]
 81030e8:	693a      	ldr	r2, [r7, #16]
 81030ea:	61da      	str	r2, [r3, #28]
    hmmc->TxXferSize -= SDMMC_FIFO_SIZE;
 81030ec:	687b      	ldr	r3, [r7, #4]
 81030ee:	6a1b      	ldr	r3, [r3, #32]
 81030f0:	f1a3 0220 	sub.w	r2, r3, #32
 81030f4:	687b      	ldr	r3, [r7, #4]
 81030f6:	621a      	str	r2, [r3, #32]
  }
}
 81030f8:	bf00      	nop
 81030fa:	3718      	adds	r7, #24
 81030fc:	46bd      	mov	sp, r7
 81030fe:	bd80      	pop	{r7, pc}

08103100 <MMC_PwrClassUpdate>:
  * @param  Wide Wide of MMC bus
  * @param  Speed Speed of the MMC bus
  * @retval MMC Card error state
  */
static uint32_t MMC_PwrClassUpdate(MMC_HandleTypeDef *hmmc, uint32_t Wide, uint32_t Speed)
{
 8103100:	b580      	push	{r7, lr}
 8103102:	b08a      	sub	sp, #40	@ 0x28
 8103104:	af00      	add	r7, sp, #0
 8103106:	60f8      	str	r0, [r7, #12]
 8103108:	60b9      	str	r1, [r7, #8]
 810310a:	607a      	str	r2, [r7, #4]
  uint32_t count;
  uint32_t response = 0U;
 810310c:	2300      	movs	r3, #0
 810310e:	623b      	str	r3, [r7, #32]
  uint32_t errorstate = HAL_MMC_ERROR_NONE;
 8103110:	2300      	movs	r3, #0
 8103112:	61fb      	str	r3, [r7, #28]
  uint32_t power_class;
  uint32_t supported_pwr_class;

  if ((Wide == SDMMC_BUS_WIDE_8B) || (Wide == SDMMC_BUS_WIDE_4B))
 8103114:	68bb      	ldr	r3, [r7, #8]
 8103116:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 810311a:	d004      	beq.n	8103126 <MMC_PwrClassUpdate+0x26>
 810311c:	68bb      	ldr	r3, [r7, #8]
 810311e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8103122:	f040 8088 	bne.w	8103236 <MMC_PwrClassUpdate+0x136>
  {
    power_class = 0U; /* Default value after power-on or software reset */
 8103126:	2300      	movs	r3, #0
 8103128:	617b      	str	r3, [r7, #20]

    /* Read the PowerClass field of the Extended CSD register */
    if (MMC_ReadExtCSD(hmmc, &power_class, 187, SDMMC_DATATIMEOUT) != HAL_OK) /* Field POWER_CLASS [187] */
 810312a:	f107 0114 	add.w	r1, r7, #20
 810312e:	f04f 33ff 	mov.w	r3, #4294967295
 8103132:	22bb      	movs	r2, #187	@ 0xbb
 8103134:	68f8      	ldr	r0, [r7, #12]
 8103136:	f7ff fe5f 	bl	8102df8 <MMC_ReadExtCSD>
 810313a:	4603      	mov	r3, r0
 810313c:	2b00      	cmp	r3, #0
 810313e:	d003      	beq.n	8103148 <MMC_PwrClassUpdate+0x48>
    {
      errorstate = SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8103140:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8103144:	61fb      	str	r3, [r7, #28]
 8103146:	e002      	b.n	810314e <MMC_PwrClassUpdate+0x4e>
    }
    else
    {
      power_class = ((power_class >> 24U) & 0x000000FFU);
 8103148:	697b      	ldr	r3, [r7, #20]
 810314a:	0e1b      	lsrs	r3, r3, #24
 810314c:	617b      	str	r3, [r7, #20]
    }

    /* Get the supported PowerClass field of the Extended CSD register */
    if (Speed == SDMMC_SPEED_MODE_DDR)
 810314e:	687b      	ldr	r3, [r7, #4]
 8103150:	2b04      	cmp	r3, #4
 8103152:	d105      	bne.n	8103160 <MMC_PwrClassUpdate+0x60>
    {
      /* Field PWR_CL_DDR_52_xxx [238 or 239] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_DDR_52_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_DDR_52_POS) &
 8103154:	68fb      	ldr	r3, [r7, #12]
 8103156:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 810315a:	0e1b      	lsrs	r3, r3, #24
 810315c:	61bb      	str	r3, [r7, #24]
 810315e:	e00e      	b.n	810317e <MMC_PwrClassUpdate+0x7e>
                             0x000000FFU);
    }
    else if (Speed == SDMMC_SPEED_MODE_HIGH)
 8103160:	687b      	ldr	r3, [r7, #4]
 8103162:	2b02      	cmp	r3, #2
 8103164:	d106      	bne.n	8103174 <MMC_PwrClassUpdate+0x74>
    {
      /* Field PWR_CL_52_xxx [200 or 202] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_52_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_52_POS) &
 8103166:	68fb      	ldr	r3, [r7, #12]
 8103168:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 810316c:	0c1b      	lsrs	r3, r3, #16
 810316e:	b2db      	uxtb	r3, r3
 8103170:	61bb      	str	r3, [r7, #24]
 8103172:	e004      	b.n	810317e <MMC_PwrClassUpdate+0x7e>
                             0x000000FFU);
    }
    else
    {
      /* Field PWR_CL_26_xxx [201 or 203] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_26_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_26_POS) &
 8103174:	68fb      	ldr	r3, [r7, #12]
 8103176:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 810317a:	0e1b      	lsrs	r3, r3, #24
 810317c:	61bb      	str	r3, [r7, #24]
                             0x000000FFU);
    }

    if (errorstate == HAL_MMC_ERROR_NONE)
 810317e:	69fb      	ldr	r3, [r7, #28]
 8103180:	2b00      	cmp	r3, #0
 8103182:	d158      	bne.n	8103236 <MMC_PwrClassUpdate+0x136>
    {
      if (Wide == SDMMC_BUS_WIDE_8B)
 8103184:	68bb      	ldr	r3, [r7, #8]
 8103186:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 810318a:	d102      	bne.n	8103192 <MMC_PwrClassUpdate+0x92>
      {
        /* Bit [7:4]: power class for 8-bits bus configuration - Bit [3:0]: power class for 4-bits bus configuration */
        supported_pwr_class = (supported_pwr_class >> 4U);
 810318c:	69bb      	ldr	r3, [r7, #24]
 810318e:	091b      	lsrs	r3, r3, #4
 8103190:	61bb      	str	r3, [r7, #24]
      }

      if ((power_class & 0x0FU) != (supported_pwr_class & 0x0FU))
 8103192:	697a      	ldr	r2, [r7, #20]
 8103194:	69bb      	ldr	r3, [r7, #24]
 8103196:	4053      	eors	r3, r2
 8103198:	f003 030f 	and.w	r3, r3, #15
 810319c:	2b00      	cmp	r3, #0
 810319e:	d04a      	beq.n	8103236 <MMC_PwrClassUpdate+0x136>
      {
        /* Need to change current power class */
        errorstate = SDMMC_CmdSwitch(hmmc->Instance, (0x03BB0000U | ((supported_pwr_class & 0x0FU) << 8U)));
 81031a0:	68fb      	ldr	r3, [r7, #12]
 81031a2:	681a      	ldr	r2, [r3, #0]
 81031a4:	69bb      	ldr	r3, [r7, #24]
 81031a6:	021b      	lsls	r3, r3, #8
 81031a8:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
 81031ac:	f043 736e 	orr.w	r3, r3, #62390272	@ 0x3b80000
 81031b0:	f443 3340 	orr.w	r3, r3, #196608	@ 0x30000
 81031b4:	4619      	mov	r1, r3
 81031b6:	4610      	mov	r0, r2
 81031b8:	f005 ff7c 	bl	81090b4 <SDMMC_CmdSwitch>
 81031bc:	61f8      	str	r0, [r7, #28]

        if (errorstate == HAL_MMC_ERROR_NONE)
 81031be:	69fb      	ldr	r3, [r7, #28]
 81031c0:	2b00      	cmp	r3, #0
 81031c2:	d138      	bne.n	8103236 <MMC_PwrClassUpdate+0x136>
        {
          /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
          count = SDMMC_MAX_TRIAL;
 81031c4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 81031c8:	627b      	str	r3, [r7, #36]	@ 0x24
          do
          {
            errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
 81031ca:	68fb      	ldr	r3, [r7, #12]
 81031cc:	681a      	ldr	r2, [r3, #0]
 81031ce:	68fb      	ldr	r3, [r7, #12]
 81031d0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 81031d2:	041b      	lsls	r3, r3, #16
 81031d4:	4619      	mov	r1, r3
 81031d6:	4610      	mov	r0, r2
 81031d8:	f005 ff29 	bl	810902e <SDMMC_CmdSendStatus>
 81031dc:	61f8      	str	r0, [r7, #28]
            if (errorstate != HAL_MMC_ERROR_NONE)
 81031de:	69fb      	ldr	r3, [r7, #28]
 81031e0:	2b00      	cmp	r3, #0
 81031e2:	d112      	bne.n	810320a <MMC_PwrClassUpdate+0x10a>
            {
              break;
            }

            /* Get command response */
            response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
 81031e4:	68fb      	ldr	r3, [r7, #12]
 81031e6:	681b      	ldr	r3, [r3, #0]
 81031e8:	2100      	movs	r1, #0
 81031ea:	4618      	mov	r0, r3
 81031ec:	f005 fddb 	bl	8108da6 <SDMMC_GetResponse>
 81031f0:	6238      	str	r0, [r7, #32]
            count--;
 81031f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81031f4:	3b01      	subs	r3, #1
 81031f6:	627b      	str	r3, [r7, #36]	@ 0x24
          } while (((response & 0x100U) == 0U) && (count != 0U));
 81031f8:	6a3b      	ldr	r3, [r7, #32]
 81031fa:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 81031fe:	2b00      	cmp	r3, #0
 8103200:	d104      	bne.n	810320c <MMC_PwrClassUpdate+0x10c>
 8103202:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103204:	2b00      	cmp	r3, #0
 8103206:	d1e0      	bne.n	81031ca <MMC_PwrClassUpdate+0xca>
 8103208:	e000      	b.n	810320c <MMC_PwrClassUpdate+0x10c>
              break;
 810320a:	bf00      	nop

          /* Check the status after the switch command execution */
          if ((count != 0U) && (errorstate == HAL_MMC_ERROR_NONE))
 810320c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810320e:	2b00      	cmp	r3, #0
 8103210:	d00b      	beq.n	810322a <MMC_PwrClassUpdate+0x12a>
 8103212:	69fb      	ldr	r3, [r7, #28]
 8103214:	2b00      	cmp	r3, #0
 8103216:	d108      	bne.n	810322a <MMC_PwrClassUpdate+0x12a>
          {
            /* Check the bit SWITCH_ERROR of the device status */
            if ((response & 0x80U) != 0U)
 8103218:	6a3b      	ldr	r3, [r7, #32]
 810321a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810321e:	2b00      	cmp	r3, #0
 8103220:	d009      	beq.n	8103236 <MMC_PwrClassUpdate+0x136>
            {
              errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
 8103222:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8103226:	61fb      	str	r3, [r7, #28]
            if ((response & 0x80U) != 0U)
 8103228:	e005      	b.n	8103236 <MMC_PwrClassUpdate+0x136>
            }
          }
          else if (count == 0U)
 810322a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810322c:	2b00      	cmp	r3, #0
 810322e:	d102      	bne.n	8103236 <MMC_PwrClassUpdate+0x136>
          {
            errorstate = SDMMC_ERROR_TIMEOUT;
 8103230:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8103234:	61fb      	str	r3, [r7, #28]
        }
      }
    }
  }

  return errorstate;
 8103236:	69fb      	ldr	r3, [r7, #28]
}
 8103238:	4618      	mov	r0, r3
 810323a:	3728      	adds	r7, #40	@ 0x28
 810323c:	46bd      	mov	sp, r7
 810323e:	bd80      	pop	{r7, pc}

08103240 <HAL_MMCEx_Read_DMADoubleBuf0CpltCallback>:
  * @brief Read DMA Buffer 0 Transfer completed callbacks
  * @param hmmc: MMC handle
  * @retval None
  */
__weak void HAL_MMCEx_Read_DMADoubleBuf0CpltCallback(MMC_HandleTypeDef *hmmc)
{
 8103240:	b480      	push	{r7}
 8103242:	b083      	sub	sp, #12
 8103244:	af00      	add	r7, sp, #0
 8103246:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMCEx_Read_DMADoubleBuf0CpltCallback can be implemented in the user file
   */
}
 8103248:	bf00      	nop
 810324a:	370c      	adds	r7, #12
 810324c:	46bd      	mov	sp, r7
 810324e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103252:	4770      	bx	lr

08103254 <HAL_MMCEx_Read_DMADoubleBuf1CpltCallback>:
  * @brief Read DMA Buffer 1 Transfer completed callbacks
  * @param hmmc: MMC handle
  * @retval None
  */
__weak void HAL_MMCEx_Read_DMADoubleBuf1CpltCallback(MMC_HandleTypeDef *hmmc)
{
 8103254:	b480      	push	{r7}
 8103256:	b083      	sub	sp, #12
 8103258:	af00      	add	r7, sp, #0
 810325a:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMCEx_Read_DMADoubleBuf1CpltCallback can be implemented in the user file
   */
}
 810325c:	bf00      	nop
 810325e:	370c      	adds	r7, #12
 8103260:	46bd      	mov	sp, r7
 8103262:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103266:	4770      	bx	lr

08103268 <HAL_MMCEx_Write_DMADoubleBuf0CpltCallback>:
  * @brief Write DMA Buffer 0 Transfer completed callbacks
  * @param hmmc: MMC handle
  * @retval None
  */
__weak void HAL_MMCEx_Write_DMADoubleBuf0CpltCallback(MMC_HandleTypeDef *hmmc)
{
 8103268:	b480      	push	{r7}
 810326a:	b083      	sub	sp, #12
 810326c:	af00      	add	r7, sp, #0
 810326e:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMCEx_Write_DMADoubleBuf0CpltCallback can be implemented in the user file
   */
}
 8103270:	bf00      	nop
 8103272:	370c      	adds	r7, #12
 8103274:	46bd      	mov	sp, r7
 8103276:	f85d 7b04 	ldr.w	r7, [sp], #4
 810327a:	4770      	bx	lr

0810327c <HAL_MMCEx_Write_DMADoubleBuf1CpltCallback>:
  * @brief Write DMA Buffer 1 Transfer completed callbacks
  * @param hmmc: MMC handle
  * @retval None
  */
__weak void HAL_MMCEx_Write_DMADoubleBuf1CpltCallback(MMC_HandleTypeDef *hmmc)
{
 810327c:	b480      	push	{r7}
 810327e:	b083      	sub	sp, #12
 8103280:	af00      	add	r7, sp, #0
 8103282:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MMCEx_Write_DMADoubleBuf1CpltCallback can be implemented in the user file
   */
}
 8103284:	bf00      	nop
 8103286:	370c      	adds	r7, #12
 8103288:	46bd      	mov	sp, r7
 810328a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810328e:	4770      	bx	lr

08103290 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8103290:	b580      	push	{r7, lr}
 8103292:	b086      	sub	sp, #24
 8103294:	af02      	add	r7, sp, #8
 8103296:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8103298:	687b      	ldr	r3, [r7, #4]
 810329a:	2b00      	cmp	r3, #0
 810329c:	d101      	bne.n	81032a2 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 810329e:	2301      	movs	r3, #1
 81032a0:	e0fe      	b.n	81034a0 <HAL_PCD_Init+0x210>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 81032a2:	687b      	ldr	r3, [r7, #4]
 81032a4:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 81032a8:	b2db      	uxtb	r3, r3
 81032aa:	2b00      	cmp	r3, #0
 81032ac:	d106      	bne.n	81032bc <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 81032ae:	687b      	ldr	r3, [r7, #4]
 81032b0:	2200      	movs	r2, #0
 81032b2:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 81032b6:	6878      	ldr	r0, [r7, #4]
 81032b8:	f009 fff0 	bl	810d29c <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 81032bc:	687b      	ldr	r3, [r7, #4]
 81032be:	2203      	movs	r2, #3
 81032c0:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 81032c4:	687b      	ldr	r3, [r7, #4]
 81032c6:	681b      	ldr	r3, [r3, #0]
 81032c8:	4618      	mov	r0, r3
 81032ca:	f006 fc1e 	bl	8109b0a <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 81032ce:	687b      	ldr	r3, [r7, #4]
 81032d0:	6818      	ldr	r0, [r3, #0]
 81032d2:	687b      	ldr	r3, [r7, #4]
 81032d4:	7c1a      	ldrb	r2, [r3, #16]
 81032d6:	f88d 2000 	strb.w	r2, [sp]
 81032da:	3304      	adds	r3, #4
 81032dc:	cb0e      	ldmia	r3, {r1, r2, r3}
 81032de:	f006 faef 	bl	81098c0 <USB_CoreInit>
 81032e2:	4603      	mov	r3, r0
 81032e4:	2b00      	cmp	r3, #0
 81032e6:	d005      	beq.n	81032f4 <HAL_PCD_Init+0x64>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 81032e8:	687b      	ldr	r3, [r7, #4]
 81032ea:	2202      	movs	r2, #2
 81032ec:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 81032f0:	2301      	movs	r3, #1
 81032f2:	e0d5      	b.n	81034a0 <HAL_PCD_Init+0x210>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 81032f4:	687b      	ldr	r3, [r7, #4]
 81032f6:	681b      	ldr	r3, [r3, #0]
 81032f8:	2100      	movs	r1, #0
 81032fa:	4618      	mov	r0, r3
 81032fc:	f006 fc16 	bl	8109b2c <USB_SetCurrentMode>
 8103300:	4603      	mov	r3, r0
 8103302:	2b00      	cmp	r3, #0
 8103304:	d005      	beq.n	8103312 <HAL_PCD_Init+0x82>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8103306:	687b      	ldr	r3, [r7, #4]
 8103308:	2202      	movs	r2, #2
 810330a:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 810330e:	2301      	movs	r3, #1
 8103310:	e0c6      	b.n	81034a0 <HAL_PCD_Init+0x210>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8103312:	2300      	movs	r3, #0
 8103314:	73fb      	strb	r3, [r7, #15]
 8103316:	e04a      	b.n	81033ae <HAL_PCD_Init+0x11e>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8103318:	7bfa      	ldrb	r2, [r7, #15]
 810331a:	6879      	ldr	r1, [r7, #4]
 810331c:	4613      	mov	r3, r2
 810331e:	00db      	lsls	r3, r3, #3
 8103320:	4413      	add	r3, r2
 8103322:	009b      	lsls	r3, r3, #2
 8103324:	440b      	add	r3, r1
 8103326:	3315      	adds	r3, #21
 8103328:	2201      	movs	r2, #1
 810332a:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 810332c:	7bfa      	ldrb	r2, [r7, #15]
 810332e:	6879      	ldr	r1, [r7, #4]
 8103330:	4613      	mov	r3, r2
 8103332:	00db      	lsls	r3, r3, #3
 8103334:	4413      	add	r3, r2
 8103336:	009b      	lsls	r3, r3, #2
 8103338:	440b      	add	r3, r1
 810333a:	3314      	adds	r3, #20
 810333c:	7bfa      	ldrb	r2, [r7, #15]
 810333e:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 8103340:	7bfa      	ldrb	r2, [r7, #15]
 8103342:	7bfb      	ldrb	r3, [r7, #15]
 8103344:	b298      	uxth	r0, r3
 8103346:	6879      	ldr	r1, [r7, #4]
 8103348:	4613      	mov	r3, r2
 810334a:	00db      	lsls	r3, r3, #3
 810334c:	4413      	add	r3, r2
 810334e:	009b      	lsls	r3, r3, #2
 8103350:	440b      	add	r3, r1
 8103352:	332e      	adds	r3, #46	@ 0x2e
 8103354:	4602      	mov	r2, r0
 8103356:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8103358:	7bfa      	ldrb	r2, [r7, #15]
 810335a:	6879      	ldr	r1, [r7, #4]
 810335c:	4613      	mov	r3, r2
 810335e:	00db      	lsls	r3, r3, #3
 8103360:	4413      	add	r3, r2
 8103362:	009b      	lsls	r3, r3, #2
 8103364:	440b      	add	r3, r1
 8103366:	3318      	adds	r3, #24
 8103368:	2200      	movs	r2, #0
 810336a:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 810336c:	7bfa      	ldrb	r2, [r7, #15]
 810336e:	6879      	ldr	r1, [r7, #4]
 8103370:	4613      	mov	r3, r2
 8103372:	00db      	lsls	r3, r3, #3
 8103374:	4413      	add	r3, r2
 8103376:	009b      	lsls	r3, r3, #2
 8103378:	440b      	add	r3, r1
 810337a:	331c      	adds	r3, #28
 810337c:	2200      	movs	r2, #0
 810337e:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 8103380:	7bfa      	ldrb	r2, [r7, #15]
 8103382:	6879      	ldr	r1, [r7, #4]
 8103384:	4613      	mov	r3, r2
 8103386:	00db      	lsls	r3, r3, #3
 8103388:	4413      	add	r3, r2
 810338a:	009b      	lsls	r3, r3, #2
 810338c:	440b      	add	r3, r1
 810338e:	3320      	adds	r3, #32
 8103390:	2200      	movs	r2, #0
 8103392:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 8103394:	7bfa      	ldrb	r2, [r7, #15]
 8103396:	6879      	ldr	r1, [r7, #4]
 8103398:	4613      	mov	r3, r2
 810339a:	00db      	lsls	r3, r3, #3
 810339c:	4413      	add	r3, r2
 810339e:	009b      	lsls	r3, r3, #2
 81033a0:	440b      	add	r3, r1
 81033a2:	3324      	adds	r3, #36	@ 0x24
 81033a4:	2200      	movs	r2, #0
 81033a6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 81033a8:	7bfb      	ldrb	r3, [r7, #15]
 81033aa:	3301      	adds	r3, #1
 81033ac:	73fb      	strb	r3, [r7, #15]
 81033ae:	687b      	ldr	r3, [r7, #4]
 81033b0:	791b      	ldrb	r3, [r3, #4]
 81033b2:	7bfa      	ldrb	r2, [r7, #15]
 81033b4:	429a      	cmp	r2, r3
 81033b6:	d3af      	bcc.n	8103318 <HAL_PCD_Init+0x88>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 81033b8:	2300      	movs	r3, #0
 81033ba:	73fb      	strb	r3, [r7, #15]
 81033bc:	e044      	b.n	8103448 <HAL_PCD_Init+0x1b8>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 81033be:	7bfa      	ldrb	r2, [r7, #15]
 81033c0:	6879      	ldr	r1, [r7, #4]
 81033c2:	4613      	mov	r3, r2
 81033c4:	00db      	lsls	r3, r3, #3
 81033c6:	4413      	add	r3, r2
 81033c8:	009b      	lsls	r3, r3, #2
 81033ca:	440b      	add	r3, r1
 81033cc:	f203 2355 	addw	r3, r3, #597	@ 0x255
 81033d0:	2200      	movs	r2, #0
 81033d2:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 81033d4:	7bfa      	ldrb	r2, [r7, #15]
 81033d6:	6879      	ldr	r1, [r7, #4]
 81033d8:	4613      	mov	r3, r2
 81033da:	00db      	lsls	r3, r3, #3
 81033dc:	4413      	add	r3, r2
 81033de:	009b      	lsls	r3, r3, #2
 81033e0:	440b      	add	r3, r1
 81033e2:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 81033e6:	7bfa      	ldrb	r2, [r7, #15]
 81033e8:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 81033ea:	7bfa      	ldrb	r2, [r7, #15]
 81033ec:	6879      	ldr	r1, [r7, #4]
 81033ee:	4613      	mov	r3, r2
 81033f0:	00db      	lsls	r3, r3, #3
 81033f2:	4413      	add	r3, r2
 81033f4:	009b      	lsls	r3, r3, #2
 81033f6:	440b      	add	r3, r1
 81033f8:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 81033fc:	2200      	movs	r2, #0
 81033fe:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 8103400:	7bfa      	ldrb	r2, [r7, #15]
 8103402:	6879      	ldr	r1, [r7, #4]
 8103404:	4613      	mov	r3, r2
 8103406:	00db      	lsls	r3, r3, #3
 8103408:	4413      	add	r3, r2
 810340a:	009b      	lsls	r3, r3, #2
 810340c:	440b      	add	r3, r1
 810340e:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 8103412:	2200      	movs	r2, #0
 8103414:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8103416:	7bfa      	ldrb	r2, [r7, #15]
 8103418:	6879      	ldr	r1, [r7, #4]
 810341a:	4613      	mov	r3, r2
 810341c:	00db      	lsls	r3, r3, #3
 810341e:	4413      	add	r3, r2
 8103420:	009b      	lsls	r3, r3, #2
 8103422:	440b      	add	r3, r1
 8103424:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8103428:	2200      	movs	r2, #0
 810342a:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 810342c:	7bfa      	ldrb	r2, [r7, #15]
 810342e:	6879      	ldr	r1, [r7, #4]
 8103430:	4613      	mov	r3, r2
 8103432:	00db      	lsls	r3, r3, #3
 8103434:	4413      	add	r3, r2
 8103436:	009b      	lsls	r3, r3, #2
 8103438:	440b      	add	r3, r1
 810343a:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 810343e:	2200      	movs	r2, #0
 8103440:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8103442:	7bfb      	ldrb	r3, [r7, #15]
 8103444:	3301      	adds	r3, #1
 8103446:	73fb      	strb	r3, [r7, #15]
 8103448:	687b      	ldr	r3, [r7, #4]
 810344a:	791b      	ldrb	r3, [r3, #4]
 810344c:	7bfa      	ldrb	r2, [r7, #15]
 810344e:	429a      	cmp	r2, r3
 8103450:	d3b5      	bcc.n	81033be <HAL_PCD_Init+0x12e>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8103452:	687b      	ldr	r3, [r7, #4]
 8103454:	6818      	ldr	r0, [r3, #0]
 8103456:	687b      	ldr	r3, [r7, #4]
 8103458:	7c1a      	ldrb	r2, [r3, #16]
 810345a:	f88d 2000 	strb.w	r2, [sp]
 810345e:	3304      	adds	r3, #4
 8103460:	cb0e      	ldmia	r3, {r1, r2, r3}
 8103462:	f006 fbaf 	bl	8109bc4 <USB_DevInit>
 8103466:	4603      	mov	r3, r0
 8103468:	2b00      	cmp	r3, #0
 810346a:	d005      	beq.n	8103478 <HAL_PCD_Init+0x1e8>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 810346c:	687b      	ldr	r3, [r7, #4]
 810346e:	2202      	movs	r2, #2
 8103470:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 8103474:	2301      	movs	r3, #1
 8103476:	e013      	b.n	81034a0 <HAL_PCD_Init+0x210>
  }

  hpcd->USB_Address = 0U;
 8103478:	687b      	ldr	r3, [r7, #4]
 810347a:	2200      	movs	r2, #0
 810347c:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 810347e:	687b      	ldr	r3, [r7, #4]
 8103480:	2201      	movs	r2, #1
 8103482:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 8103486:	687b      	ldr	r3, [r7, #4]
 8103488:	7b1b      	ldrb	r3, [r3, #12]
 810348a:	2b01      	cmp	r3, #1
 810348c:	d102      	bne.n	8103494 <HAL_PCD_Init+0x204>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 810348e:	6878      	ldr	r0, [r7, #4]
 8103490:	f001 f96e 	bl	8104770 <HAL_PCDEx_ActivateLPM>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 8103494:	687b      	ldr	r3, [r7, #4]
 8103496:	681b      	ldr	r3, [r3, #0]
 8103498:	4618      	mov	r0, r3
 810349a:	f007 fbec 	bl	810ac76 <USB_DevDisconnect>

  return HAL_OK;
 810349e:	2300      	movs	r3, #0
}
 81034a0:	4618      	mov	r0, r3
 81034a2:	3710      	adds	r7, #16
 81034a4:	46bd      	mov	sp, r7
 81034a6:	bd80      	pop	{r7, pc}

081034a8 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 81034a8:	b580      	push	{r7, lr}
 81034aa:	b084      	sub	sp, #16
 81034ac:	af00      	add	r7, sp, #0
 81034ae:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 81034b0:	687b      	ldr	r3, [r7, #4]
 81034b2:	681b      	ldr	r3, [r3, #0]
 81034b4:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 81034b6:	687b      	ldr	r3, [r7, #4]
 81034b8:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 81034bc:	2b01      	cmp	r3, #1
 81034be:	d101      	bne.n	81034c4 <HAL_PCD_Start+0x1c>
 81034c0:	2302      	movs	r3, #2
 81034c2:	e022      	b.n	810350a <HAL_PCD_Start+0x62>
 81034c4:	687b      	ldr	r3, [r7, #4]
 81034c6:	2201      	movs	r2, #1
 81034c8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 81034cc:	68fb      	ldr	r3, [r7, #12]
 81034ce:	68db      	ldr	r3, [r3, #12]
 81034d0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 81034d4:	2b00      	cmp	r3, #0
 81034d6:	d009      	beq.n	81034ec <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 81034d8:	687b      	ldr	r3, [r7, #4]
 81034da:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 81034dc:	2b01      	cmp	r3, #1
 81034de:	d105      	bne.n	81034ec <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 81034e0:	68fb      	ldr	r3, [r7, #12]
 81034e2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 81034e4:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 81034e8:	68fb      	ldr	r3, [r7, #12]
 81034ea:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 81034ec:	687b      	ldr	r3, [r7, #4]
 81034ee:	681b      	ldr	r3, [r3, #0]
 81034f0:	4618      	mov	r0, r3
 81034f2:	f006 faf9 	bl	8109ae8 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 81034f6:	687b      	ldr	r3, [r7, #4]
 81034f8:	681b      	ldr	r3, [r3, #0]
 81034fa:	4618      	mov	r0, r3
 81034fc:	f007 fb9a 	bl	810ac34 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 8103500:	687b      	ldr	r3, [r7, #4]
 8103502:	2200      	movs	r2, #0
 8103504:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8103508:	2300      	movs	r3, #0
}
 810350a:	4618      	mov	r0, r3
 810350c:	3710      	adds	r7, #16
 810350e:	46bd      	mov	sp, r7
 8103510:	bd80      	pop	{r7, pc}

08103512 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8103512:	b590      	push	{r4, r7, lr}
 8103514:	b08d      	sub	sp, #52	@ 0x34
 8103516:	af00      	add	r7, sp, #0
 8103518:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 810351a:	687b      	ldr	r3, [r7, #4]
 810351c:	681b      	ldr	r3, [r3, #0]
 810351e:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8103520:	6a3b      	ldr	r3, [r7, #32]
 8103522:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8103524:	687b      	ldr	r3, [r7, #4]
 8103526:	681b      	ldr	r3, [r3, #0]
 8103528:	4618      	mov	r0, r3
 810352a:	f007 fc58 	bl	810adde <USB_GetMode>
 810352e:	4603      	mov	r3, r0
 8103530:	2b00      	cmp	r3, #0
 8103532:	f040 84b9 	bne.w	8103ea8 <HAL_PCD_IRQHandler+0x996>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8103536:	687b      	ldr	r3, [r7, #4]
 8103538:	681b      	ldr	r3, [r3, #0]
 810353a:	4618      	mov	r0, r3
 810353c:	f007 fbbc 	bl	810acb8 <USB_ReadInterrupts>
 8103540:	4603      	mov	r3, r0
 8103542:	2b00      	cmp	r3, #0
 8103544:	f000 84af 	beq.w	8103ea6 <HAL_PCD_IRQHandler+0x994>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8103548:	69fb      	ldr	r3, [r7, #28]
 810354a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810354e:	689b      	ldr	r3, [r3, #8]
 8103550:	0a1b      	lsrs	r3, r3, #8
 8103552:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8103556:	687b      	ldr	r3, [r7, #4]
 8103558:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 810355c:	687b      	ldr	r3, [r7, #4]
 810355e:	681b      	ldr	r3, [r3, #0]
 8103560:	4618      	mov	r0, r3
 8103562:	f007 fba9 	bl	810acb8 <USB_ReadInterrupts>
 8103566:	4603      	mov	r3, r0
 8103568:	f003 0302 	and.w	r3, r3, #2
 810356c:	2b02      	cmp	r3, #2
 810356e:	d107      	bne.n	8103580 <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8103570:	687b      	ldr	r3, [r7, #4]
 8103572:	681b      	ldr	r3, [r3, #0]
 8103574:	695a      	ldr	r2, [r3, #20]
 8103576:	687b      	ldr	r3, [r7, #4]
 8103578:	681b      	ldr	r3, [r3, #0]
 810357a:	f002 0202 	and.w	r2, r2, #2
 810357e:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8103580:	687b      	ldr	r3, [r7, #4]
 8103582:	681b      	ldr	r3, [r3, #0]
 8103584:	4618      	mov	r0, r3
 8103586:	f007 fb97 	bl	810acb8 <USB_ReadInterrupts>
 810358a:	4603      	mov	r3, r0
 810358c:	f003 0310 	and.w	r3, r3, #16
 8103590:	2b10      	cmp	r3, #16
 8103592:	d161      	bne.n	8103658 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8103594:	687b      	ldr	r3, [r7, #4]
 8103596:	681b      	ldr	r3, [r3, #0]
 8103598:	699a      	ldr	r2, [r3, #24]
 810359a:	687b      	ldr	r3, [r7, #4]
 810359c:	681b      	ldr	r3, [r3, #0]
 810359e:	f022 0210 	bic.w	r2, r2, #16
 81035a2:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 81035a4:	6a3b      	ldr	r3, [r7, #32]
 81035a6:	6a1b      	ldr	r3, [r3, #32]
 81035a8:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 81035aa:	69bb      	ldr	r3, [r7, #24]
 81035ac:	f003 020f 	and.w	r2, r3, #15
 81035b0:	4613      	mov	r3, r2
 81035b2:	00db      	lsls	r3, r3, #3
 81035b4:	4413      	add	r3, r2
 81035b6:	009b      	lsls	r3, r3, #2
 81035b8:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 81035bc:	687a      	ldr	r2, [r7, #4]
 81035be:	4413      	add	r3, r2
 81035c0:	3304      	adds	r3, #4
 81035c2:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 81035c4:	69bb      	ldr	r3, [r7, #24]
 81035c6:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 81035ca:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81035ce:	d124      	bne.n	810361a <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 81035d0:	69ba      	ldr	r2, [r7, #24]
 81035d2:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 81035d6:	4013      	ands	r3, r2
 81035d8:	2b00      	cmp	r3, #0
 81035da:	d035      	beq.n	8103648 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 81035dc:	697b      	ldr	r3, [r7, #20]
 81035de:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 81035e0:	69bb      	ldr	r3, [r7, #24]
 81035e2:	091b      	lsrs	r3, r3, #4
 81035e4:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 81035e6:	f3c3 030a 	ubfx	r3, r3, #0, #11
 81035ea:	b29b      	uxth	r3, r3
 81035ec:	461a      	mov	r2, r3
 81035ee:	6a38      	ldr	r0, [r7, #32]
 81035f0:	f007 f9ce 	bl	810a990 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 81035f4:	697b      	ldr	r3, [r7, #20]
 81035f6:	68da      	ldr	r2, [r3, #12]
 81035f8:	69bb      	ldr	r3, [r7, #24]
 81035fa:	091b      	lsrs	r3, r3, #4
 81035fc:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8103600:	441a      	add	r2, r3
 8103602:	697b      	ldr	r3, [r7, #20]
 8103604:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8103606:	697b      	ldr	r3, [r7, #20]
 8103608:	695a      	ldr	r2, [r3, #20]
 810360a:	69bb      	ldr	r3, [r7, #24]
 810360c:	091b      	lsrs	r3, r3, #4
 810360e:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8103612:	441a      	add	r2, r3
 8103614:	697b      	ldr	r3, [r7, #20]
 8103616:	615a      	str	r2, [r3, #20]
 8103618:	e016      	b.n	8103648 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 810361a:	69bb      	ldr	r3, [r7, #24]
 810361c:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 8103620:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8103624:	d110      	bne.n	8103648 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8103626:	687b      	ldr	r3, [r7, #4]
 8103628:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 810362c:	2208      	movs	r2, #8
 810362e:	4619      	mov	r1, r3
 8103630:	6a38      	ldr	r0, [r7, #32]
 8103632:	f007 f9ad 	bl	810a990 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8103636:	697b      	ldr	r3, [r7, #20]
 8103638:	695a      	ldr	r2, [r3, #20]
 810363a:	69bb      	ldr	r3, [r7, #24]
 810363c:	091b      	lsrs	r3, r3, #4
 810363e:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8103642:	441a      	add	r2, r3
 8103644:	697b      	ldr	r3, [r7, #20]
 8103646:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8103648:	687b      	ldr	r3, [r7, #4]
 810364a:	681b      	ldr	r3, [r3, #0]
 810364c:	699a      	ldr	r2, [r3, #24]
 810364e:	687b      	ldr	r3, [r7, #4]
 8103650:	681b      	ldr	r3, [r3, #0]
 8103652:	f042 0210 	orr.w	r2, r2, #16
 8103656:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8103658:	687b      	ldr	r3, [r7, #4]
 810365a:	681b      	ldr	r3, [r3, #0]
 810365c:	4618      	mov	r0, r3
 810365e:	f007 fb2b 	bl	810acb8 <USB_ReadInterrupts>
 8103662:	4603      	mov	r3, r0
 8103664:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8103668:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 810366c:	f040 80a7 	bne.w	81037be <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 8103670:	2300      	movs	r3, #0
 8103672:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8103674:	687b      	ldr	r3, [r7, #4]
 8103676:	681b      	ldr	r3, [r3, #0]
 8103678:	4618      	mov	r0, r3
 810367a:	f007 fb30 	bl	810acde <USB_ReadDevAllOutEpInterrupt>
 810367e:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 8103680:	e099      	b.n	81037b6 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 8103682:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8103684:	f003 0301 	and.w	r3, r3, #1
 8103688:	2b00      	cmp	r3, #0
 810368a:	f000 808e 	beq.w	81037aa <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 810368e:	687b      	ldr	r3, [r7, #4]
 8103690:	681b      	ldr	r3, [r3, #0]
 8103692:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103694:	b2d2      	uxtb	r2, r2
 8103696:	4611      	mov	r1, r2
 8103698:	4618      	mov	r0, r3
 810369a:	f007 fb54 	bl	810ad46 <USB_ReadDevOutEPInterrupt>
 810369e:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 81036a0:	693b      	ldr	r3, [r7, #16]
 81036a2:	f003 0301 	and.w	r3, r3, #1
 81036a6:	2b00      	cmp	r3, #0
 81036a8:	d00c      	beq.n	81036c4 <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 81036aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81036ac:	015a      	lsls	r2, r3, #5
 81036ae:	69fb      	ldr	r3, [r7, #28]
 81036b0:	4413      	add	r3, r2
 81036b2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81036b6:	461a      	mov	r2, r3
 81036b8:	2301      	movs	r3, #1
 81036ba:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 81036bc:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 81036be:	6878      	ldr	r0, [r7, #4]
 81036c0:	f000 fed0 	bl	8104464 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 81036c4:	693b      	ldr	r3, [r7, #16]
 81036c6:	f003 0308 	and.w	r3, r3, #8
 81036ca:	2b00      	cmp	r3, #0
 81036cc:	d00c      	beq.n	81036e8 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 81036ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81036d0:	015a      	lsls	r2, r3, #5
 81036d2:	69fb      	ldr	r3, [r7, #28]
 81036d4:	4413      	add	r3, r2
 81036d6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81036da:	461a      	mov	r2, r3
 81036dc:	2308      	movs	r3, #8
 81036de:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 81036e0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 81036e2:	6878      	ldr	r0, [r7, #4]
 81036e4:	f000 ffa6 	bl	8104634 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 81036e8:	693b      	ldr	r3, [r7, #16]
 81036ea:	f003 0310 	and.w	r3, r3, #16
 81036ee:	2b00      	cmp	r3, #0
 81036f0:	d008      	beq.n	8103704 <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 81036f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81036f4:	015a      	lsls	r2, r3, #5
 81036f6:	69fb      	ldr	r3, [r7, #28]
 81036f8:	4413      	add	r3, r2
 81036fa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81036fe:	461a      	mov	r2, r3
 8103700:	2310      	movs	r3, #16
 8103702:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8103704:	693b      	ldr	r3, [r7, #16]
 8103706:	f003 0302 	and.w	r3, r3, #2
 810370a:	2b00      	cmp	r3, #0
 810370c:	d030      	beq.n	8103770 <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 810370e:	6a3b      	ldr	r3, [r7, #32]
 8103710:	695b      	ldr	r3, [r3, #20]
 8103712:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8103716:	2b80      	cmp	r3, #128	@ 0x80
 8103718:	d109      	bne.n	810372e <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 810371a:	69fb      	ldr	r3, [r7, #28]
 810371c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103720:	685b      	ldr	r3, [r3, #4]
 8103722:	69fa      	ldr	r2, [r7, #28]
 8103724:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103728:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 810372c:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 810372e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103730:	4613      	mov	r3, r2
 8103732:	00db      	lsls	r3, r3, #3
 8103734:	4413      	add	r3, r2
 8103736:	009b      	lsls	r3, r3, #2
 8103738:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 810373c:	687a      	ldr	r2, [r7, #4]
 810373e:	4413      	add	r3, r2
 8103740:	3304      	adds	r3, #4
 8103742:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8103744:	697b      	ldr	r3, [r7, #20]
 8103746:	78db      	ldrb	r3, [r3, #3]
 8103748:	2b01      	cmp	r3, #1
 810374a:	d108      	bne.n	810375e <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 810374c:	697b      	ldr	r3, [r7, #20]
 810374e:	2200      	movs	r2, #0
 8103750:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8103752:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103754:	b2db      	uxtb	r3, r3
 8103756:	4619      	mov	r1, r3
 8103758:	6878      	ldr	r0, [r7, #4]
 810375a:	f009 fed5 	bl	810d508 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 810375e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103760:	015a      	lsls	r2, r3, #5
 8103762:	69fb      	ldr	r3, [r7, #28]
 8103764:	4413      	add	r3, r2
 8103766:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810376a:	461a      	mov	r2, r3
 810376c:	2302      	movs	r3, #2
 810376e:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8103770:	693b      	ldr	r3, [r7, #16]
 8103772:	f003 0320 	and.w	r3, r3, #32
 8103776:	2b00      	cmp	r3, #0
 8103778:	d008      	beq.n	810378c <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 810377a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810377c:	015a      	lsls	r2, r3, #5
 810377e:	69fb      	ldr	r3, [r7, #28]
 8103780:	4413      	add	r3, r2
 8103782:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8103786:	461a      	mov	r2, r3
 8103788:	2320      	movs	r3, #32
 810378a:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 810378c:	693b      	ldr	r3, [r7, #16]
 810378e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8103792:	2b00      	cmp	r3, #0
 8103794:	d009      	beq.n	81037aa <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8103796:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103798:	015a      	lsls	r2, r3, #5
 810379a:	69fb      	ldr	r3, [r7, #28]
 810379c:	4413      	add	r3, r2
 810379e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81037a2:	461a      	mov	r2, r3
 81037a4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 81037a8:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 81037aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81037ac:	3301      	adds	r3, #1
 81037ae:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 81037b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81037b2:	085b      	lsrs	r3, r3, #1
 81037b4:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 81037b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81037b8:	2b00      	cmp	r3, #0
 81037ba:	f47f af62 	bne.w	8103682 <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 81037be:	687b      	ldr	r3, [r7, #4]
 81037c0:	681b      	ldr	r3, [r3, #0]
 81037c2:	4618      	mov	r0, r3
 81037c4:	f007 fa78 	bl	810acb8 <USB_ReadInterrupts>
 81037c8:	4603      	mov	r3, r0
 81037ca:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 81037ce:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81037d2:	f040 80db 	bne.w	810398c <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 81037d6:	687b      	ldr	r3, [r7, #4]
 81037d8:	681b      	ldr	r3, [r3, #0]
 81037da:	4618      	mov	r0, r3
 81037dc:	f007 fa99 	bl	810ad12 <USB_ReadDevAllInEpInterrupt>
 81037e0:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 81037e2:	2300      	movs	r3, #0
 81037e4:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 81037e6:	e0cd      	b.n	8103984 <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 81037e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81037ea:	f003 0301 	and.w	r3, r3, #1
 81037ee:	2b00      	cmp	r3, #0
 81037f0:	f000 80c2 	beq.w	8103978 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 81037f4:	687b      	ldr	r3, [r7, #4]
 81037f6:	681b      	ldr	r3, [r3, #0]
 81037f8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 81037fa:	b2d2      	uxtb	r2, r2
 81037fc:	4611      	mov	r1, r2
 81037fe:	4618      	mov	r0, r3
 8103800:	f007 fabf 	bl	810ad82 <USB_ReadDevInEPInterrupt>
 8103804:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8103806:	693b      	ldr	r3, [r7, #16]
 8103808:	f003 0301 	and.w	r3, r3, #1
 810380c:	2b00      	cmp	r3, #0
 810380e:	d057      	beq.n	81038c0 <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8103810:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103812:	f003 030f 	and.w	r3, r3, #15
 8103816:	2201      	movs	r2, #1
 8103818:	fa02 f303 	lsl.w	r3, r2, r3
 810381c:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 810381e:	69fb      	ldr	r3, [r7, #28]
 8103820:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103824:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8103826:	68fb      	ldr	r3, [r7, #12]
 8103828:	43db      	mvns	r3, r3
 810382a:	69f9      	ldr	r1, [r7, #28]
 810382c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8103830:	4013      	ands	r3, r2
 8103832:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8103834:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103836:	015a      	lsls	r2, r3, #5
 8103838:	69fb      	ldr	r3, [r7, #28]
 810383a:	4413      	add	r3, r2
 810383c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8103840:	461a      	mov	r2, r3
 8103842:	2301      	movs	r3, #1
 8103844:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 8103846:	687b      	ldr	r3, [r7, #4]
 8103848:	799b      	ldrb	r3, [r3, #6]
 810384a:	2b01      	cmp	r3, #1
 810384c:	d132      	bne.n	81038b4 <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 810384e:	6879      	ldr	r1, [r7, #4]
 8103850:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103852:	4613      	mov	r3, r2
 8103854:	00db      	lsls	r3, r3, #3
 8103856:	4413      	add	r3, r2
 8103858:	009b      	lsls	r3, r3, #2
 810385a:	440b      	add	r3, r1
 810385c:	3320      	adds	r3, #32
 810385e:	6819      	ldr	r1, [r3, #0]
 8103860:	6878      	ldr	r0, [r7, #4]
 8103862:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103864:	4613      	mov	r3, r2
 8103866:	00db      	lsls	r3, r3, #3
 8103868:	4413      	add	r3, r2
 810386a:	009b      	lsls	r3, r3, #2
 810386c:	4403      	add	r3, r0
 810386e:	331c      	adds	r3, #28
 8103870:	681b      	ldr	r3, [r3, #0]
 8103872:	4419      	add	r1, r3
 8103874:	6878      	ldr	r0, [r7, #4]
 8103876:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103878:	4613      	mov	r3, r2
 810387a:	00db      	lsls	r3, r3, #3
 810387c:	4413      	add	r3, r2
 810387e:	009b      	lsls	r3, r3, #2
 8103880:	4403      	add	r3, r0
 8103882:	3320      	adds	r3, #32
 8103884:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8103886:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103888:	2b00      	cmp	r3, #0
 810388a:	d113      	bne.n	81038b4 <HAL_PCD_IRQHandler+0x3a2>
 810388c:	6879      	ldr	r1, [r7, #4]
 810388e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103890:	4613      	mov	r3, r2
 8103892:	00db      	lsls	r3, r3, #3
 8103894:	4413      	add	r3, r2
 8103896:	009b      	lsls	r3, r3, #2
 8103898:	440b      	add	r3, r1
 810389a:	3324      	adds	r3, #36	@ 0x24
 810389c:	681b      	ldr	r3, [r3, #0]
 810389e:	2b00      	cmp	r3, #0
 81038a0:	d108      	bne.n	81038b4 <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 81038a2:	687b      	ldr	r3, [r7, #4]
 81038a4:	6818      	ldr	r0, [r3, #0]
 81038a6:	687b      	ldr	r3, [r7, #4]
 81038a8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 81038ac:	461a      	mov	r2, r3
 81038ae:	2101      	movs	r1, #1
 81038b0:	f007 fac6 	bl	810ae40 <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 81038b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81038b6:	b2db      	uxtb	r3, r3
 81038b8:	4619      	mov	r1, r3
 81038ba:	6878      	ldr	r0, [r7, #4]
 81038bc:	f009 fd9f 	bl	810d3fe <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 81038c0:	693b      	ldr	r3, [r7, #16]
 81038c2:	f003 0308 	and.w	r3, r3, #8
 81038c6:	2b00      	cmp	r3, #0
 81038c8:	d008      	beq.n	81038dc <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 81038ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81038cc:	015a      	lsls	r2, r3, #5
 81038ce:	69fb      	ldr	r3, [r7, #28]
 81038d0:	4413      	add	r3, r2
 81038d2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 81038d6:	461a      	mov	r2, r3
 81038d8:	2308      	movs	r3, #8
 81038da:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 81038dc:	693b      	ldr	r3, [r7, #16]
 81038de:	f003 0310 	and.w	r3, r3, #16
 81038e2:	2b00      	cmp	r3, #0
 81038e4:	d008      	beq.n	81038f8 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 81038e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81038e8:	015a      	lsls	r2, r3, #5
 81038ea:	69fb      	ldr	r3, [r7, #28]
 81038ec:	4413      	add	r3, r2
 81038ee:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 81038f2:	461a      	mov	r2, r3
 81038f4:	2310      	movs	r3, #16
 81038f6:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 81038f8:	693b      	ldr	r3, [r7, #16]
 81038fa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 81038fe:	2b00      	cmp	r3, #0
 8103900:	d008      	beq.n	8103914 <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8103902:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103904:	015a      	lsls	r2, r3, #5
 8103906:	69fb      	ldr	r3, [r7, #28]
 8103908:	4413      	add	r3, r2
 810390a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810390e:	461a      	mov	r2, r3
 8103910:	2340      	movs	r3, #64	@ 0x40
 8103912:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8103914:	693b      	ldr	r3, [r7, #16]
 8103916:	f003 0302 	and.w	r3, r3, #2
 810391a:	2b00      	cmp	r3, #0
 810391c:	d023      	beq.n	8103966 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 810391e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8103920:	6a38      	ldr	r0, [r7, #32]
 8103922:	f006 faad 	bl	8109e80 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 8103926:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103928:	4613      	mov	r3, r2
 810392a:	00db      	lsls	r3, r3, #3
 810392c:	4413      	add	r3, r2
 810392e:	009b      	lsls	r3, r3, #2
 8103930:	3310      	adds	r3, #16
 8103932:	687a      	ldr	r2, [r7, #4]
 8103934:	4413      	add	r3, r2
 8103936:	3304      	adds	r3, #4
 8103938:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 810393a:	697b      	ldr	r3, [r7, #20]
 810393c:	78db      	ldrb	r3, [r3, #3]
 810393e:	2b01      	cmp	r3, #1
 8103940:	d108      	bne.n	8103954 <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 8103942:	697b      	ldr	r3, [r7, #20]
 8103944:	2200      	movs	r2, #0
 8103946:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8103948:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810394a:	b2db      	uxtb	r3, r3
 810394c:	4619      	mov	r1, r3
 810394e:	6878      	ldr	r0, [r7, #4]
 8103950:	f009 fdec 	bl	810d52c <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8103954:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103956:	015a      	lsls	r2, r3, #5
 8103958:	69fb      	ldr	r3, [r7, #28]
 810395a:	4413      	add	r3, r2
 810395c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8103960:	461a      	mov	r2, r3
 8103962:	2302      	movs	r3, #2
 8103964:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8103966:	693b      	ldr	r3, [r7, #16]
 8103968:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810396c:	2b00      	cmp	r3, #0
 810396e:	d003      	beq.n	8103978 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 8103970:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8103972:	6878      	ldr	r0, [r7, #4]
 8103974:	f000 fcea 	bl	810434c <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 8103978:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810397a:	3301      	adds	r3, #1
 810397c:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 810397e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8103980:	085b      	lsrs	r3, r3, #1
 8103982:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 8103984:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8103986:	2b00      	cmp	r3, #0
 8103988:	f47f af2e 	bne.w	81037e8 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 810398c:	687b      	ldr	r3, [r7, #4]
 810398e:	681b      	ldr	r3, [r3, #0]
 8103990:	4618      	mov	r0, r3
 8103992:	f007 f991 	bl	810acb8 <USB_ReadInterrupts>
 8103996:	4603      	mov	r3, r0
 8103998:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810399c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 81039a0:	d122      	bne.n	81039e8 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 81039a2:	69fb      	ldr	r3, [r7, #28]
 81039a4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 81039a8:	685b      	ldr	r3, [r3, #4]
 81039aa:	69fa      	ldr	r2, [r7, #28]
 81039ac:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 81039b0:	f023 0301 	bic.w	r3, r3, #1
 81039b4:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 81039b6:	687b      	ldr	r3, [r7, #4]
 81039b8:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 81039bc:	2b01      	cmp	r3, #1
 81039be:	d108      	bne.n	81039d2 <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 81039c0:	687b      	ldr	r3, [r7, #4]
 81039c2:	2200      	movs	r2, #0
 81039c4:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 81039c8:	2100      	movs	r1, #0
 81039ca:	6878      	ldr	r0, [r7, #4]
 81039cc:	f000 fef4 	bl	81047b8 <HAL_PCDEx_LPM_Callback>
 81039d0:	e002      	b.n	81039d8 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 81039d2:	6878      	ldr	r0, [r7, #4]
 81039d4:	f009 fd8a 	bl	810d4ec <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 81039d8:	687b      	ldr	r3, [r7, #4]
 81039da:	681b      	ldr	r3, [r3, #0]
 81039dc:	695a      	ldr	r2, [r3, #20]
 81039de:	687b      	ldr	r3, [r7, #4]
 81039e0:	681b      	ldr	r3, [r3, #0]
 81039e2:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 81039e6:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 81039e8:	687b      	ldr	r3, [r7, #4]
 81039ea:	681b      	ldr	r3, [r3, #0]
 81039ec:	4618      	mov	r0, r3
 81039ee:	f007 f963 	bl	810acb8 <USB_ReadInterrupts>
 81039f2:	4603      	mov	r3, r0
 81039f4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 81039f8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 81039fc:	d112      	bne.n	8103a24 <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 81039fe:	69fb      	ldr	r3, [r7, #28]
 8103a00:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103a04:	689b      	ldr	r3, [r3, #8]
 8103a06:	f003 0301 	and.w	r3, r3, #1
 8103a0a:	2b01      	cmp	r3, #1
 8103a0c:	d102      	bne.n	8103a14 <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8103a0e:	6878      	ldr	r0, [r7, #4]
 8103a10:	f009 fd46 	bl	810d4a0 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8103a14:	687b      	ldr	r3, [r7, #4]
 8103a16:	681b      	ldr	r3, [r3, #0]
 8103a18:	695a      	ldr	r2, [r3, #20]
 8103a1a:	687b      	ldr	r3, [r7, #4]
 8103a1c:	681b      	ldr	r3, [r3, #0]
 8103a1e:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8103a22:	615a      	str	r2, [r3, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 8103a24:	687b      	ldr	r3, [r7, #4]
 8103a26:	681b      	ldr	r3, [r3, #0]
 8103a28:	4618      	mov	r0, r3
 8103a2a:	f007 f945 	bl	810acb8 <USB_ReadInterrupts>
 8103a2e:	4603      	mov	r3, r0
 8103a30:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8103a34:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8103a38:	d121      	bne.n	8103a7e <HAL_PCD_IRQHandler+0x56c>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8103a3a:	687b      	ldr	r3, [r7, #4]
 8103a3c:	681b      	ldr	r3, [r3, #0]
 8103a3e:	695a      	ldr	r2, [r3, #20]
 8103a40:	687b      	ldr	r3, [r7, #4]
 8103a42:	681b      	ldr	r3, [r3, #0]
 8103a44:	f002 6200 	and.w	r2, r2, #134217728	@ 0x8000000
 8103a48:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
 8103a4a:	687b      	ldr	r3, [r7, #4]
 8103a4c:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 8103a50:	2b00      	cmp	r3, #0
 8103a52:	d111      	bne.n	8103a78 <HAL_PCD_IRQHandler+0x566>
      {
        hpcd->LPM_State = LPM_L1;
 8103a54:	687b      	ldr	r3, [r7, #4]
 8103a56:	2201      	movs	r2, #1
 8103a58:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8103a5c:	687b      	ldr	r3, [r7, #4]
 8103a5e:	681b      	ldr	r3, [r3, #0]
 8103a60:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8103a62:	089b      	lsrs	r3, r3, #2
 8103a64:	f003 020f 	and.w	r2, r3, #15
 8103a68:	687b      	ldr	r3, [r7, #4]
 8103a6a:	f8c3 24d0 	str.w	r2, [r3, #1232]	@ 0x4d0

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8103a6e:	2101      	movs	r1, #1
 8103a70:	6878      	ldr	r0, [r7, #4]
 8103a72:	f000 fea1 	bl	81047b8 <HAL_PCDEx_LPM_Callback>
 8103a76:	e002      	b.n	8103a7e <HAL_PCD_IRQHandler+0x56c>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8103a78:	6878      	ldr	r0, [r7, #4]
 8103a7a:	f009 fd11 	bl	810d4a0 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8103a7e:	687b      	ldr	r3, [r7, #4]
 8103a80:	681b      	ldr	r3, [r3, #0]
 8103a82:	4618      	mov	r0, r3
 8103a84:	f007 f918 	bl	810acb8 <USB_ReadInterrupts>
 8103a88:	4603      	mov	r3, r0
 8103a8a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8103a8e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8103a92:	f040 80b7 	bne.w	8103c04 <HAL_PCD_IRQHandler+0x6f2>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8103a96:	69fb      	ldr	r3, [r7, #28]
 8103a98:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103a9c:	685b      	ldr	r3, [r3, #4]
 8103a9e:	69fa      	ldr	r2, [r7, #28]
 8103aa0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103aa4:	f023 0301 	bic.w	r3, r3, #1
 8103aa8:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8103aaa:	687b      	ldr	r3, [r7, #4]
 8103aac:	681b      	ldr	r3, [r3, #0]
 8103aae:	2110      	movs	r1, #16
 8103ab0:	4618      	mov	r0, r3
 8103ab2:	f006 f9e5 	bl	8109e80 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8103ab6:	2300      	movs	r3, #0
 8103ab8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8103aba:	e046      	b.n	8103b4a <HAL_PCD_IRQHandler+0x638>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8103abc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103abe:	015a      	lsls	r2, r3, #5
 8103ac0:	69fb      	ldr	r3, [r7, #28]
 8103ac2:	4413      	add	r3, r2
 8103ac4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8103ac8:	461a      	mov	r2, r3
 8103aca:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8103ace:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8103ad0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103ad2:	015a      	lsls	r2, r3, #5
 8103ad4:	69fb      	ldr	r3, [r7, #28]
 8103ad6:	4413      	add	r3, r2
 8103ad8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8103adc:	681b      	ldr	r3, [r3, #0]
 8103ade:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8103ae0:	0151      	lsls	r1, r2, #5
 8103ae2:	69fa      	ldr	r2, [r7, #28]
 8103ae4:	440a      	add	r2, r1
 8103ae6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8103aea:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8103aee:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8103af0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103af2:	015a      	lsls	r2, r3, #5
 8103af4:	69fb      	ldr	r3, [r7, #28]
 8103af6:	4413      	add	r3, r2
 8103af8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8103afc:	461a      	mov	r2, r3
 8103afe:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8103b02:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8103b04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103b06:	015a      	lsls	r2, r3, #5
 8103b08:	69fb      	ldr	r3, [r7, #28]
 8103b0a:	4413      	add	r3, r2
 8103b0c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8103b10:	681b      	ldr	r3, [r3, #0]
 8103b12:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8103b14:	0151      	lsls	r1, r2, #5
 8103b16:	69fa      	ldr	r2, [r7, #28]
 8103b18:	440a      	add	r2, r1
 8103b1a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8103b1e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8103b22:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8103b24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103b26:	015a      	lsls	r2, r3, #5
 8103b28:	69fb      	ldr	r3, [r7, #28]
 8103b2a:	4413      	add	r3, r2
 8103b2c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8103b30:	681b      	ldr	r3, [r3, #0]
 8103b32:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8103b34:	0151      	lsls	r1, r2, #5
 8103b36:	69fa      	ldr	r2, [r7, #28]
 8103b38:	440a      	add	r2, r1
 8103b3a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8103b3e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8103b42:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8103b44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103b46:	3301      	adds	r3, #1
 8103b48:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8103b4a:	687b      	ldr	r3, [r7, #4]
 8103b4c:	791b      	ldrb	r3, [r3, #4]
 8103b4e:	461a      	mov	r2, r3
 8103b50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103b52:	4293      	cmp	r3, r2
 8103b54:	d3b2      	bcc.n	8103abc <HAL_PCD_IRQHandler+0x5aa>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8103b56:	69fb      	ldr	r3, [r7, #28]
 8103b58:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103b5c:	69db      	ldr	r3, [r3, #28]
 8103b5e:	69fa      	ldr	r2, [r7, #28]
 8103b60:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103b64:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8103b68:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8103b6a:	687b      	ldr	r3, [r7, #4]
 8103b6c:	7bdb      	ldrb	r3, [r3, #15]
 8103b6e:	2b00      	cmp	r3, #0
 8103b70:	d016      	beq.n	8103ba0 <HAL_PCD_IRQHandler+0x68e>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8103b72:	69fb      	ldr	r3, [r7, #28]
 8103b74:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103b78:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8103b7c:	69fa      	ldr	r2, [r7, #28]
 8103b7e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103b82:	f043 030b 	orr.w	r3, r3, #11
 8103b86:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8103b8a:	69fb      	ldr	r3, [r7, #28]
 8103b8c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103b90:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8103b92:	69fa      	ldr	r2, [r7, #28]
 8103b94:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103b98:	f043 030b 	orr.w	r3, r3, #11
 8103b9c:	6453      	str	r3, [r2, #68]	@ 0x44
 8103b9e:	e015      	b.n	8103bcc <HAL_PCD_IRQHandler+0x6ba>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8103ba0:	69fb      	ldr	r3, [r7, #28]
 8103ba2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103ba6:	695b      	ldr	r3, [r3, #20]
 8103ba8:	69fa      	ldr	r2, [r7, #28]
 8103baa:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103bae:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8103bb2:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
 8103bb6:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8103bb8:	69fb      	ldr	r3, [r7, #28]
 8103bba:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103bbe:	691b      	ldr	r3, [r3, #16]
 8103bc0:	69fa      	ldr	r2, [r7, #28]
 8103bc2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103bc6:	f043 030b 	orr.w	r3, r3, #11
 8103bca:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8103bcc:	69fb      	ldr	r3, [r7, #28]
 8103bce:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103bd2:	681b      	ldr	r3, [r3, #0]
 8103bd4:	69fa      	ldr	r2, [r7, #28]
 8103bd6:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103bda:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8103bde:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8103be0:	687b      	ldr	r3, [r7, #4]
 8103be2:	6818      	ldr	r0, [r3, #0]
 8103be4:	687b      	ldr	r3, [r7, #4]
 8103be6:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 8103be8:	687b      	ldr	r3, [r7, #4]
 8103bea:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8103bee:	461a      	mov	r2, r3
 8103bf0:	f007 f926 	bl	810ae40 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8103bf4:	687b      	ldr	r3, [r7, #4]
 8103bf6:	681b      	ldr	r3, [r3, #0]
 8103bf8:	695a      	ldr	r2, [r3, #20]
 8103bfa:	687b      	ldr	r3, [r7, #4]
 8103bfc:	681b      	ldr	r3, [r3, #0]
 8103bfe:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 8103c02:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8103c04:	687b      	ldr	r3, [r7, #4]
 8103c06:	681b      	ldr	r3, [r3, #0]
 8103c08:	4618      	mov	r0, r3
 8103c0a:	f007 f855 	bl	810acb8 <USB_ReadInterrupts>
 8103c0e:	4603      	mov	r3, r0
 8103c10:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8103c14:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8103c18:	d123      	bne.n	8103c62 <HAL_PCD_IRQHandler+0x750>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8103c1a:	687b      	ldr	r3, [r7, #4]
 8103c1c:	681b      	ldr	r3, [r3, #0]
 8103c1e:	4618      	mov	r0, r3
 8103c20:	f007 f8eb 	bl	810adfa <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8103c24:	687b      	ldr	r3, [r7, #4]
 8103c26:	681b      	ldr	r3, [r3, #0]
 8103c28:	4618      	mov	r0, r3
 8103c2a:	f006 f9a2 	bl	8109f72 <USB_GetDevSpeed>
 8103c2e:	4603      	mov	r3, r0
 8103c30:	461a      	mov	r2, r3
 8103c32:	687b      	ldr	r3, [r7, #4]
 8103c34:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8103c36:	687b      	ldr	r3, [r7, #4]
 8103c38:	681c      	ldr	r4, [r3, #0]
 8103c3a:	f000 ffdb 	bl	8104bf4 <HAL_RCC_GetHCLKFreq>
 8103c3e:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8103c40:	687b      	ldr	r3, [r7, #4]
 8103c42:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8103c44:	461a      	mov	r2, r3
 8103c46:	4620      	mov	r0, r4
 8103c48:	f005 feac 	bl	81099a4 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8103c4c:	6878      	ldr	r0, [r7, #4]
 8103c4e:	f009 fbfe 	bl	810d44e <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8103c52:	687b      	ldr	r3, [r7, #4]
 8103c54:	681b      	ldr	r3, [r3, #0]
 8103c56:	695a      	ldr	r2, [r3, #20]
 8103c58:	687b      	ldr	r3, [r7, #4]
 8103c5a:	681b      	ldr	r3, [r3, #0]
 8103c5c:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8103c60:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8103c62:	687b      	ldr	r3, [r7, #4]
 8103c64:	681b      	ldr	r3, [r3, #0]
 8103c66:	4618      	mov	r0, r3
 8103c68:	f007 f826 	bl	810acb8 <USB_ReadInterrupts>
 8103c6c:	4603      	mov	r3, r0
 8103c6e:	f003 0308 	and.w	r3, r3, #8
 8103c72:	2b08      	cmp	r3, #8
 8103c74:	d10a      	bne.n	8103c8c <HAL_PCD_IRQHandler+0x77a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8103c76:	6878      	ldr	r0, [r7, #4]
 8103c78:	f009 fbdb 	bl	810d432 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8103c7c:	687b      	ldr	r3, [r7, #4]
 8103c7e:	681b      	ldr	r3, [r3, #0]
 8103c80:	695a      	ldr	r2, [r3, #20]
 8103c82:	687b      	ldr	r3, [r7, #4]
 8103c84:	681b      	ldr	r3, [r3, #0]
 8103c86:	f002 0208 	and.w	r2, r2, #8
 8103c8a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8103c8c:	687b      	ldr	r3, [r7, #4]
 8103c8e:	681b      	ldr	r3, [r3, #0]
 8103c90:	4618      	mov	r0, r3
 8103c92:	f007 f811 	bl	810acb8 <USB_ReadInterrupts>
 8103c96:	4603      	mov	r3, r0
 8103c98:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8103c9c:	2b80      	cmp	r3, #128	@ 0x80
 8103c9e:	d123      	bne.n	8103ce8 <HAL_PCD_IRQHandler+0x7d6>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8103ca0:	6a3b      	ldr	r3, [r7, #32]
 8103ca2:	699b      	ldr	r3, [r3, #24]
 8103ca4:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8103ca8:	6a3b      	ldr	r3, [r7, #32]
 8103caa:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103cac:	2301      	movs	r3, #1
 8103cae:	627b      	str	r3, [r7, #36]	@ 0x24
 8103cb0:	e014      	b.n	8103cdc <HAL_PCD_IRQHandler+0x7ca>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8103cb2:	6879      	ldr	r1, [r7, #4]
 8103cb4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103cb6:	4613      	mov	r3, r2
 8103cb8:	00db      	lsls	r3, r3, #3
 8103cba:	4413      	add	r3, r2
 8103cbc:	009b      	lsls	r3, r3, #2
 8103cbe:	440b      	add	r3, r1
 8103cc0:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8103cc4:	781b      	ldrb	r3, [r3, #0]
 8103cc6:	2b01      	cmp	r3, #1
 8103cc8:	d105      	bne.n	8103cd6 <HAL_PCD_IRQHandler+0x7c4>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 8103cca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103ccc:	b2db      	uxtb	r3, r3
 8103cce:	4619      	mov	r1, r3
 8103cd0:	6878      	ldr	r0, [r7, #4]
 8103cd2:	f000 fb0a 	bl	81042ea <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103cd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103cd8:	3301      	adds	r3, #1
 8103cda:	627b      	str	r3, [r7, #36]	@ 0x24
 8103cdc:	687b      	ldr	r3, [r7, #4]
 8103cde:	791b      	ldrb	r3, [r3, #4]
 8103ce0:	461a      	mov	r2, r3
 8103ce2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103ce4:	4293      	cmp	r3, r2
 8103ce6:	d3e4      	bcc.n	8103cb2 <HAL_PCD_IRQHandler+0x7a0>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8103ce8:	687b      	ldr	r3, [r7, #4]
 8103cea:	681b      	ldr	r3, [r3, #0]
 8103cec:	4618      	mov	r0, r3
 8103cee:	f006 ffe3 	bl	810acb8 <USB_ReadInterrupts>
 8103cf2:	4603      	mov	r3, r0
 8103cf4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8103cf8:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8103cfc:	d13c      	bne.n	8103d78 <HAL_PCD_IRQHandler+0x866>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103cfe:	2301      	movs	r3, #1
 8103d00:	627b      	str	r3, [r7, #36]	@ 0x24
 8103d02:	e02b      	b.n	8103d5c <HAL_PCD_IRQHandler+0x84a>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8103d04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103d06:	015a      	lsls	r2, r3, #5
 8103d08:	69fb      	ldr	r3, [r7, #28]
 8103d0a:	4413      	add	r3, r2
 8103d0c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8103d10:	681b      	ldr	r3, [r3, #0]
 8103d12:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8103d14:	6879      	ldr	r1, [r7, #4]
 8103d16:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103d18:	4613      	mov	r3, r2
 8103d1a:	00db      	lsls	r3, r3, #3
 8103d1c:	4413      	add	r3, r2
 8103d1e:	009b      	lsls	r3, r3, #2
 8103d20:	440b      	add	r3, r1
 8103d22:	3318      	adds	r3, #24
 8103d24:	781b      	ldrb	r3, [r3, #0]
 8103d26:	2b01      	cmp	r3, #1
 8103d28:	d115      	bne.n	8103d56 <HAL_PCD_IRQHandler+0x844>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8103d2a:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8103d2c:	2b00      	cmp	r3, #0
 8103d2e:	da12      	bge.n	8103d56 <HAL_PCD_IRQHandler+0x844>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8103d30:	6879      	ldr	r1, [r7, #4]
 8103d32:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103d34:	4613      	mov	r3, r2
 8103d36:	00db      	lsls	r3, r3, #3
 8103d38:	4413      	add	r3, r2
 8103d3a:	009b      	lsls	r3, r3, #2
 8103d3c:	440b      	add	r3, r1
 8103d3e:	3317      	adds	r3, #23
 8103d40:	2201      	movs	r2, #1
 8103d42:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 8103d44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103d46:	b2db      	uxtb	r3, r3
 8103d48:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8103d4c:	b2db      	uxtb	r3, r3
 8103d4e:	4619      	mov	r1, r3
 8103d50:	6878      	ldr	r0, [r7, #4]
 8103d52:	f000 faca 	bl	81042ea <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103d56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103d58:	3301      	adds	r3, #1
 8103d5a:	627b      	str	r3, [r7, #36]	@ 0x24
 8103d5c:	687b      	ldr	r3, [r7, #4]
 8103d5e:	791b      	ldrb	r3, [r3, #4]
 8103d60:	461a      	mov	r2, r3
 8103d62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103d64:	4293      	cmp	r3, r2
 8103d66:	d3cd      	bcc.n	8103d04 <HAL_PCD_IRQHandler+0x7f2>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8103d68:	687b      	ldr	r3, [r7, #4]
 8103d6a:	681b      	ldr	r3, [r3, #0]
 8103d6c:	695a      	ldr	r2, [r3, #20]
 8103d6e:	687b      	ldr	r3, [r7, #4]
 8103d70:	681b      	ldr	r3, [r3, #0]
 8103d72:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 8103d76:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8103d78:	687b      	ldr	r3, [r7, #4]
 8103d7a:	681b      	ldr	r3, [r3, #0]
 8103d7c:	4618      	mov	r0, r3
 8103d7e:	f006 ff9b 	bl	810acb8 <USB_ReadInterrupts>
 8103d82:	4603      	mov	r3, r0
 8103d84:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8103d88:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8103d8c:	d156      	bne.n	8103e3c <HAL_PCD_IRQHandler+0x92a>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103d8e:	2301      	movs	r3, #1
 8103d90:	627b      	str	r3, [r7, #36]	@ 0x24
 8103d92:	e045      	b.n	8103e20 <HAL_PCD_IRQHandler+0x90e>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8103d94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103d96:	015a      	lsls	r2, r3, #5
 8103d98:	69fb      	ldr	r3, [r7, #28]
 8103d9a:	4413      	add	r3, r2
 8103d9c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8103da0:	681b      	ldr	r3, [r3, #0]
 8103da2:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8103da4:	6879      	ldr	r1, [r7, #4]
 8103da6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103da8:	4613      	mov	r3, r2
 8103daa:	00db      	lsls	r3, r3, #3
 8103dac:	4413      	add	r3, r2
 8103dae:	009b      	lsls	r3, r3, #2
 8103db0:	440b      	add	r3, r1
 8103db2:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8103db6:	781b      	ldrb	r3, [r3, #0]
 8103db8:	2b01      	cmp	r3, #1
 8103dba:	d12e      	bne.n	8103e1a <HAL_PCD_IRQHandler+0x908>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8103dbc:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8103dbe:	2b00      	cmp	r3, #0
 8103dc0:	da2b      	bge.n	8103e1a <HAL_PCD_IRQHandler+0x908>
            (((RegVal & (0x1U << 16)) >> 16U) == (hpcd->FrameNumber & 0x1U)))
 8103dc2:	69bb      	ldr	r3, [r7, #24]
 8103dc4:	0c1a      	lsrs	r2, r3, #16
 8103dc6:	687b      	ldr	r3, [r7, #4]
 8103dc8:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 8103dcc:	4053      	eors	r3, r2
 8103dce:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8103dd2:	2b00      	cmp	r3, #0
 8103dd4:	d121      	bne.n	8103e1a <HAL_PCD_IRQHandler+0x908>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8103dd6:	6879      	ldr	r1, [r7, #4]
 8103dd8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8103dda:	4613      	mov	r3, r2
 8103ddc:	00db      	lsls	r3, r3, #3
 8103dde:	4413      	add	r3, r2
 8103de0:	009b      	lsls	r3, r3, #2
 8103de2:	440b      	add	r3, r1
 8103de4:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8103de8:	2201      	movs	r2, #1
 8103dea:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8103dec:	6a3b      	ldr	r3, [r7, #32]
 8103dee:	699b      	ldr	r3, [r3, #24]
 8103df0:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8103df4:	6a3b      	ldr	r3, [r7, #32]
 8103df6:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8103df8:	6a3b      	ldr	r3, [r7, #32]
 8103dfa:	695b      	ldr	r3, [r3, #20]
 8103dfc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8103e00:	2b00      	cmp	r3, #0
 8103e02:	d10a      	bne.n	8103e1a <HAL_PCD_IRQHandler+0x908>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8103e04:	69fb      	ldr	r3, [r7, #28]
 8103e06:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8103e0a:	685b      	ldr	r3, [r3, #4]
 8103e0c:	69fa      	ldr	r2, [r7, #28]
 8103e0e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8103e12:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8103e16:	6053      	str	r3, [r2, #4]
            break;
 8103e18:	e008      	b.n	8103e2c <HAL_PCD_IRQHandler+0x91a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8103e1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103e1c:	3301      	adds	r3, #1
 8103e1e:	627b      	str	r3, [r7, #36]	@ 0x24
 8103e20:	687b      	ldr	r3, [r7, #4]
 8103e22:	791b      	ldrb	r3, [r3, #4]
 8103e24:	461a      	mov	r2, r3
 8103e26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103e28:	4293      	cmp	r3, r2
 8103e2a:	d3b3      	bcc.n	8103d94 <HAL_PCD_IRQHandler+0x882>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8103e2c:	687b      	ldr	r3, [r7, #4]
 8103e2e:	681b      	ldr	r3, [r3, #0]
 8103e30:	695a      	ldr	r2, [r3, #20]
 8103e32:	687b      	ldr	r3, [r7, #4]
 8103e34:	681b      	ldr	r3, [r3, #0]
 8103e36:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 8103e3a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8103e3c:	687b      	ldr	r3, [r7, #4]
 8103e3e:	681b      	ldr	r3, [r3, #0]
 8103e40:	4618      	mov	r0, r3
 8103e42:	f006 ff39 	bl	810acb8 <USB_ReadInterrupts>
 8103e46:	4603      	mov	r3, r0
 8103e48:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8103e4c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8103e50:	d10a      	bne.n	8103e68 <HAL_PCD_IRQHandler+0x956>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8103e52:	6878      	ldr	r0, [r7, #4]
 8103e54:	f009 fb7c 	bl	810d550 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8103e58:	687b      	ldr	r3, [r7, #4]
 8103e5a:	681b      	ldr	r3, [r3, #0]
 8103e5c:	695a      	ldr	r2, [r3, #20]
 8103e5e:	687b      	ldr	r3, [r7, #4]
 8103e60:	681b      	ldr	r3, [r3, #0]
 8103e62:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8103e66:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8103e68:	687b      	ldr	r3, [r7, #4]
 8103e6a:	681b      	ldr	r3, [r3, #0]
 8103e6c:	4618      	mov	r0, r3
 8103e6e:	f006 ff23 	bl	810acb8 <USB_ReadInterrupts>
 8103e72:	4603      	mov	r3, r0
 8103e74:	f003 0304 	and.w	r3, r3, #4
 8103e78:	2b04      	cmp	r3, #4
 8103e7a:	d115      	bne.n	8103ea8 <HAL_PCD_IRQHandler+0x996>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8103e7c:	687b      	ldr	r3, [r7, #4]
 8103e7e:	681b      	ldr	r3, [r3, #0]
 8103e80:	685b      	ldr	r3, [r3, #4]
 8103e82:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8103e84:	69bb      	ldr	r3, [r7, #24]
 8103e86:	f003 0304 	and.w	r3, r3, #4
 8103e8a:	2b00      	cmp	r3, #0
 8103e8c:	d002      	beq.n	8103e94 <HAL_PCD_IRQHandler+0x982>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8103e8e:	6878      	ldr	r0, [r7, #4]
 8103e90:	f009 fb6c 	bl	810d56c <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 8103e94:	687b      	ldr	r3, [r7, #4]
 8103e96:	681b      	ldr	r3, [r3, #0]
 8103e98:	6859      	ldr	r1, [r3, #4]
 8103e9a:	687b      	ldr	r3, [r7, #4]
 8103e9c:	681b      	ldr	r3, [r3, #0]
 8103e9e:	69ba      	ldr	r2, [r7, #24]
 8103ea0:	430a      	orrs	r2, r1
 8103ea2:	605a      	str	r2, [r3, #4]
 8103ea4:	e000      	b.n	8103ea8 <HAL_PCD_IRQHandler+0x996>
      return;
 8103ea6:	bf00      	nop
    }
  }
}
 8103ea8:	3734      	adds	r7, #52	@ 0x34
 8103eaa:	46bd      	mov	sp, r7
 8103eac:	bd90      	pop	{r4, r7, pc}

08103eae <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8103eae:	b580      	push	{r7, lr}
 8103eb0:	b082      	sub	sp, #8
 8103eb2:	af00      	add	r7, sp, #0
 8103eb4:	6078      	str	r0, [r7, #4]
 8103eb6:	460b      	mov	r3, r1
 8103eb8:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8103eba:	687b      	ldr	r3, [r7, #4]
 8103ebc:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8103ec0:	2b01      	cmp	r3, #1
 8103ec2:	d101      	bne.n	8103ec8 <HAL_PCD_SetAddress+0x1a>
 8103ec4:	2302      	movs	r3, #2
 8103ec6:	e012      	b.n	8103eee <HAL_PCD_SetAddress+0x40>
 8103ec8:	687b      	ldr	r3, [r7, #4]
 8103eca:	2201      	movs	r2, #1
 8103ecc:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 8103ed0:	687b      	ldr	r3, [r7, #4]
 8103ed2:	78fa      	ldrb	r2, [r7, #3]
 8103ed4:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8103ed6:	687b      	ldr	r3, [r7, #4]
 8103ed8:	681b      	ldr	r3, [r3, #0]
 8103eda:	78fa      	ldrb	r2, [r7, #3]
 8103edc:	4611      	mov	r1, r2
 8103ede:	4618      	mov	r0, r3
 8103ee0:	f006 fe82 	bl	810abe8 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8103ee4:	687b      	ldr	r3, [r7, #4]
 8103ee6:	2200      	movs	r2, #0
 8103ee8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8103eec:	2300      	movs	r3, #0
}
 8103eee:	4618      	mov	r0, r3
 8103ef0:	3708      	adds	r7, #8
 8103ef2:	46bd      	mov	sp, r7
 8103ef4:	bd80      	pop	{r7, pc}

08103ef6 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 8103ef6:	b580      	push	{r7, lr}
 8103ef8:	b084      	sub	sp, #16
 8103efa:	af00      	add	r7, sp, #0
 8103efc:	6078      	str	r0, [r7, #4]
 8103efe:	4608      	mov	r0, r1
 8103f00:	4611      	mov	r1, r2
 8103f02:	461a      	mov	r2, r3
 8103f04:	4603      	mov	r3, r0
 8103f06:	70fb      	strb	r3, [r7, #3]
 8103f08:	460b      	mov	r3, r1
 8103f0a:	803b      	strh	r3, [r7, #0]
 8103f0c:	4613      	mov	r3, r2
 8103f0e:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
 8103f10:	2300      	movs	r3, #0
 8103f12:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8103f14:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8103f18:	2b00      	cmp	r3, #0
 8103f1a:	da0f      	bge.n	8103f3c <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8103f1c:	78fb      	ldrb	r3, [r7, #3]
 8103f1e:	f003 020f 	and.w	r2, r3, #15
 8103f22:	4613      	mov	r3, r2
 8103f24:	00db      	lsls	r3, r3, #3
 8103f26:	4413      	add	r3, r2
 8103f28:	009b      	lsls	r3, r3, #2
 8103f2a:	3310      	adds	r3, #16
 8103f2c:	687a      	ldr	r2, [r7, #4]
 8103f2e:	4413      	add	r3, r2
 8103f30:	3304      	adds	r3, #4
 8103f32:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8103f34:	68fb      	ldr	r3, [r7, #12]
 8103f36:	2201      	movs	r2, #1
 8103f38:	705a      	strb	r2, [r3, #1]
 8103f3a:	e00f      	b.n	8103f5c <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8103f3c:	78fb      	ldrb	r3, [r7, #3]
 8103f3e:	f003 020f 	and.w	r2, r3, #15
 8103f42:	4613      	mov	r3, r2
 8103f44:	00db      	lsls	r3, r3, #3
 8103f46:	4413      	add	r3, r2
 8103f48:	009b      	lsls	r3, r3, #2
 8103f4a:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8103f4e:	687a      	ldr	r2, [r7, #4]
 8103f50:	4413      	add	r3, r2
 8103f52:	3304      	adds	r3, #4
 8103f54:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8103f56:	68fb      	ldr	r3, [r7, #12]
 8103f58:	2200      	movs	r2, #0
 8103f5a:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8103f5c:	78fb      	ldrb	r3, [r7, #3]
 8103f5e:	f003 030f 	and.w	r3, r3, #15
 8103f62:	b2da      	uxtb	r2, r3
 8103f64:	68fb      	ldr	r3, [r7, #12]
 8103f66:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
 8103f68:	883b      	ldrh	r3, [r7, #0]
 8103f6a:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8103f6e:	68fb      	ldr	r3, [r7, #12]
 8103f70:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8103f72:	68fb      	ldr	r3, [r7, #12]
 8103f74:	78ba      	ldrb	r2, [r7, #2]
 8103f76:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 8103f78:	68fb      	ldr	r3, [r7, #12]
 8103f7a:	785b      	ldrb	r3, [r3, #1]
 8103f7c:	2b00      	cmp	r3, #0
 8103f7e:	d004      	beq.n	8103f8a <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8103f80:	68fb      	ldr	r3, [r7, #12]
 8103f82:	781b      	ldrb	r3, [r3, #0]
 8103f84:	461a      	mov	r2, r3
 8103f86:	68fb      	ldr	r3, [r7, #12]
 8103f88:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8103f8a:	78bb      	ldrb	r3, [r7, #2]
 8103f8c:	2b02      	cmp	r3, #2
 8103f8e:	d102      	bne.n	8103f96 <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
 8103f90:	68fb      	ldr	r3, [r7, #12]
 8103f92:	2200      	movs	r2, #0
 8103f94:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 8103f96:	687b      	ldr	r3, [r7, #4]
 8103f98:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8103f9c:	2b01      	cmp	r3, #1
 8103f9e:	d101      	bne.n	8103fa4 <HAL_PCD_EP_Open+0xae>
 8103fa0:	2302      	movs	r3, #2
 8103fa2:	e00e      	b.n	8103fc2 <HAL_PCD_EP_Open+0xcc>
 8103fa4:	687b      	ldr	r3, [r7, #4]
 8103fa6:	2201      	movs	r2, #1
 8103fa8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8103fac:	687b      	ldr	r3, [r7, #4]
 8103fae:	681b      	ldr	r3, [r3, #0]
 8103fb0:	68f9      	ldr	r1, [r7, #12]
 8103fb2:	4618      	mov	r0, r3
 8103fb4:	f006 f802 	bl	8109fbc <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8103fb8:	687b      	ldr	r3, [r7, #4]
 8103fba:	2200      	movs	r2, #0
 8103fbc:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 8103fc0:	7afb      	ldrb	r3, [r7, #11]
}
 8103fc2:	4618      	mov	r0, r3
 8103fc4:	3710      	adds	r7, #16
 8103fc6:	46bd      	mov	sp, r7
 8103fc8:	bd80      	pop	{r7, pc}

08103fca <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8103fca:	b580      	push	{r7, lr}
 8103fcc:	b084      	sub	sp, #16
 8103fce:	af00      	add	r7, sp, #0
 8103fd0:	6078      	str	r0, [r7, #4]
 8103fd2:	460b      	mov	r3, r1
 8103fd4:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8103fd6:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8103fda:	2b00      	cmp	r3, #0
 8103fdc:	da0f      	bge.n	8103ffe <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8103fde:	78fb      	ldrb	r3, [r7, #3]
 8103fe0:	f003 020f 	and.w	r2, r3, #15
 8103fe4:	4613      	mov	r3, r2
 8103fe6:	00db      	lsls	r3, r3, #3
 8103fe8:	4413      	add	r3, r2
 8103fea:	009b      	lsls	r3, r3, #2
 8103fec:	3310      	adds	r3, #16
 8103fee:	687a      	ldr	r2, [r7, #4]
 8103ff0:	4413      	add	r3, r2
 8103ff2:	3304      	adds	r3, #4
 8103ff4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8103ff6:	68fb      	ldr	r3, [r7, #12]
 8103ff8:	2201      	movs	r2, #1
 8103ffa:	705a      	strb	r2, [r3, #1]
 8103ffc:	e00f      	b.n	810401e <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8103ffe:	78fb      	ldrb	r3, [r7, #3]
 8104000:	f003 020f 	and.w	r2, r3, #15
 8104004:	4613      	mov	r3, r2
 8104006:	00db      	lsls	r3, r3, #3
 8104008:	4413      	add	r3, r2
 810400a:	009b      	lsls	r3, r3, #2
 810400c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8104010:	687a      	ldr	r2, [r7, #4]
 8104012:	4413      	add	r3, r2
 8104014:	3304      	adds	r3, #4
 8104016:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8104018:	68fb      	ldr	r3, [r7, #12]
 810401a:	2200      	movs	r2, #0
 810401c:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 810401e:	78fb      	ldrb	r3, [r7, #3]
 8104020:	f003 030f 	and.w	r3, r3, #15
 8104024:	b2da      	uxtb	r2, r3
 8104026:	68fb      	ldr	r3, [r7, #12]
 8104028:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 810402a:	687b      	ldr	r3, [r7, #4]
 810402c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8104030:	2b01      	cmp	r3, #1
 8104032:	d101      	bne.n	8104038 <HAL_PCD_EP_Close+0x6e>
 8104034:	2302      	movs	r3, #2
 8104036:	e00e      	b.n	8104056 <HAL_PCD_EP_Close+0x8c>
 8104038:	687b      	ldr	r3, [r7, #4]
 810403a:	2201      	movs	r2, #1
 810403c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8104040:	687b      	ldr	r3, [r7, #4]
 8104042:	681b      	ldr	r3, [r3, #0]
 8104044:	68f9      	ldr	r1, [r7, #12]
 8104046:	4618      	mov	r0, r3
 8104048:	f006 f840 	bl	810a0cc <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 810404c:	687b      	ldr	r3, [r7, #4]
 810404e:	2200      	movs	r2, #0
 8104050:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 8104054:	2300      	movs	r3, #0
}
 8104056:	4618      	mov	r0, r3
 8104058:	3710      	adds	r7, #16
 810405a:	46bd      	mov	sp, r7
 810405c:	bd80      	pop	{r7, pc}

0810405e <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 810405e:	b580      	push	{r7, lr}
 8104060:	b086      	sub	sp, #24
 8104062:	af00      	add	r7, sp, #0
 8104064:	60f8      	str	r0, [r7, #12]
 8104066:	607a      	str	r2, [r7, #4]
 8104068:	603b      	str	r3, [r7, #0]
 810406a:	460b      	mov	r3, r1
 810406c:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 810406e:	7afb      	ldrb	r3, [r7, #11]
 8104070:	f003 020f 	and.w	r2, r3, #15
 8104074:	4613      	mov	r3, r2
 8104076:	00db      	lsls	r3, r3, #3
 8104078:	4413      	add	r3, r2
 810407a:	009b      	lsls	r3, r3, #2
 810407c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8104080:	68fa      	ldr	r2, [r7, #12]
 8104082:	4413      	add	r3, r2
 8104084:	3304      	adds	r3, #4
 8104086:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8104088:	697b      	ldr	r3, [r7, #20]
 810408a:	687a      	ldr	r2, [r7, #4]
 810408c:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 810408e:	697b      	ldr	r3, [r7, #20]
 8104090:	683a      	ldr	r2, [r7, #0]
 8104092:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8104094:	697b      	ldr	r3, [r7, #20]
 8104096:	2200      	movs	r2, #0
 8104098:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 810409a:	697b      	ldr	r3, [r7, #20]
 810409c:	2200      	movs	r2, #0
 810409e:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 81040a0:	7afb      	ldrb	r3, [r7, #11]
 81040a2:	f003 030f 	and.w	r3, r3, #15
 81040a6:	b2da      	uxtb	r2, r3
 81040a8:	697b      	ldr	r3, [r7, #20]
 81040aa:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 81040ac:	68fb      	ldr	r3, [r7, #12]
 81040ae:	799b      	ldrb	r3, [r3, #6]
 81040b0:	2b01      	cmp	r3, #1
 81040b2:	d102      	bne.n	81040ba <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 81040b4:	687a      	ldr	r2, [r7, #4]
 81040b6:	697b      	ldr	r3, [r7, #20]
 81040b8:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 81040ba:	68fb      	ldr	r3, [r7, #12]
 81040bc:	6818      	ldr	r0, [r3, #0]
 81040be:	68fb      	ldr	r3, [r7, #12]
 81040c0:	799b      	ldrb	r3, [r3, #6]
 81040c2:	461a      	mov	r2, r3
 81040c4:	6979      	ldr	r1, [r7, #20]
 81040c6:	f006 f8dd 	bl	810a284 <USB_EPStartXfer>

  return HAL_OK;
 81040ca:	2300      	movs	r3, #0
}
 81040cc:	4618      	mov	r0, r3
 81040ce:	3718      	adds	r7, #24
 81040d0:	46bd      	mov	sp, r7
 81040d2:	bd80      	pop	{r7, pc}

081040d4 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 81040d4:	b480      	push	{r7}
 81040d6:	b083      	sub	sp, #12
 81040d8:	af00      	add	r7, sp, #0
 81040da:	6078      	str	r0, [r7, #4]
 81040dc:	460b      	mov	r3, r1
 81040de:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 81040e0:	78fb      	ldrb	r3, [r7, #3]
 81040e2:	f003 020f 	and.w	r2, r3, #15
 81040e6:	6879      	ldr	r1, [r7, #4]
 81040e8:	4613      	mov	r3, r2
 81040ea:	00db      	lsls	r3, r3, #3
 81040ec:	4413      	add	r3, r2
 81040ee:	009b      	lsls	r3, r3, #2
 81040f0:	440b      	add	r3, r1
 81040f2:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 81040f6:	681b      	ldr	r3, [r3, #0]
}
 81040f8:	4618      	mov	r0, r3
 81040fa:	370c      	adds	r7, #12
 81040fc:	46bd      	mov	sp, r7
 81040fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104102:	4770      	bx	lr

08104104 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8104104:	b580      	push	{r7, lr}
 8104106:	b086      	sub	sp, #24
 8104108:	af00      	add	r7, sp, #0
 810410a:	60f8      	str	r0, [r7, #12]
 810410c:	607a      	str	r2, [r7, #4]
 810410e:	603b      	str	r3, [r7, #0]
 8104110:	460b      	mov	r3, r1
 8104112:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8104114:	7afb      	ldrb	r3, [r7, #11]
 8104116:	f003 020f 	and.w	r2, r3, #15
 810411a:	4613      	mov	r3, r2
 810411c:	00db      	lsls	r3, r3, #3
 810411e:	4413      	add	r3, r2
 8104120:	009b      	lsls	r3, r3, #2
 8104122:	3310      	adds	r3, #16
 8104124:	68fa      	ldr	r2, [r7, #12]
 8104126:	4413      	add	r3, r2
 8104128:	3304      	adds	r3, #4
 810412a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 810412c:	697b      	ldr	r3, [r7, #20]
 810412e:	687a      	ldr	r2, [r7, #4]
 8104130:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8104132:	697b      	ldr	r3, [r7, #20]
 8104134:	683a      	ldr	r2, [r7, #0]
 8104136:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8104138:	697b      	ldr	r3, [r7, #20]
 810413a:	2200      	movs	r2, #0
 810413c:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 810413e:	697b      	ldr	r3, [r7, #20]
 8104140:	2201      	movs	r2, #1
 8104142:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8104144:	7afb      	ldrb	r3, [r7, #11]
 8104146:	f003 030f 	and.w	r3, r3, #15
 810414a:	b2da      	uxtb	r2, r3
 810414c:	697b      	ldr	r3, [r7, #20]
 810414e:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8104150:	68fb      	ldr	r3, [r7, #12]
 8104152:	799b      	ldrb	r3, [r3, #6]
 8104154:	2b01      	cmp	r3, #1
 8104156:	d102      	bne.n	810415e <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8104158:	687a      	ldr	r2, [r7, #4]
 810415a:	697b      	ldr	r3, [r7, #20]
 810415c:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 810415e:	68fb      	ldr	r3, [r7, #12]
 8104160:	6818      	ldr	r0, [r3, #0]
 8104162:	68fb      	ldr	r3, [r7, #12]
 8104164:	799b      	ldrb	r3, [r3, #6]
 8104166:	461a      	mov	r2, r3
 8104168:	6979      	ldr	r1, [r7, #20]
 810416a:	f006 f88b 	bl	810a284 <USB_EPStartXfer>

  return HAL_OK;
 810416e:	2300      	movs	r3, #0
}
 8104170:	4618      	mov	r0, r3
 8104172:	3718      	adds	r7, #24
 8104174:	46bd      	mov	sp, r7
 8104176:	bd80      	pop	{r7, pc}

08104178 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8104178:	b580      	push	{r7, lr}
 810417a:	b084      	sub	sp, #16
 810417c:	af00      	add	r7, sp, #0
 810417e:	6078      	str	r0, [r7, #4]
 8104180:	460b      	mov	r3, r1
 8104182:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8104184:	78fb      	ldrb	r3, [r7, #3]
 8104186:	f003 030f 	and.w	r3, r3, #15
 810418a:	687a      	ldr	r2, [r7, #4]
 810418c:	7912      	ldrb	r2, [r2, #4]
 810418e:	4293      	cmp	r3, r2
 8104190:	d901      	bls.n	8104196 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8104192:	2301      	movs	r3, #1
 8104194:	e04f      	b.n	8104236 <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8104196:	f997 3003 	ldrsb.w	r3, [r7, #3]
 810419a:	2b00      	cmp	r3, #0
 810419c:	da0f      	bge.n	81041be <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 810419e:	78fb      	ldrb	r3, [r7, #3]
 81041a0:	f003 020f 	and.w	r2, r3, #15
 81041a4:	4613      	mov	r3, r2
 81041a6:	00db      	lsls	r3, r3, #3
 81041a8:	4413      	add	r3, r2
 81041aa:	009b      	lsls	r3, r3, #2
 81041ac:	3310      	adds	r3, #16
 81041ae:	687a      	ldr	r2, [r7, #4]
 81041b0:	4413      	add	r3, r2
 81041b2:	3304      	adds	r3, #4
 81041b4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 81041b6:	68fb      	ldr	r3, [r7, #12]
 81041b8:	2201      	movs	r2, #1
 81041ba:	705a      	strb	r2, [r3, #1]
 81041bc:	e00d      	b.n	81041da <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 81041be:	78fa      	ldrb	r2, [r7, #3]
 81041c0:	4613      	mov	r3, r2
 81041c2:	00db      	lsls	r3, r3, #3
 81041c4:	4413      	add	r3, r2
 81041c6:	009b      	lsls	r3, r3, #2
 81041c8:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 81041cc:	687a      	ldr	r2, [r7, #4]
 81041ce:	4413      	add	r3, r2
 81041d0:	3304      	adds	r3, #4
 81041d2:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 81041d4:	68fb      	ldr	r3, [r7, #12]
 81041d6:	2200      	movs	r2, #0
 81041d8:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 81041da:	68fb      	ldr	r3, [r7, #12]
 81041dc:	2201      	movs	r2, #1
 81041de:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 81041e0:	78fb      	ldrb	r3, [r7, #3]
 81041e2:	f003 030f 	and.w	r3, r3, #15
 81041e6:	b2da      	uxtb	r2, r3
 81041e8:	68fb      	ldr	r3, [r7, #12]
 81041ea:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 81041ec:	687b      	ldr	r3, [r7, #4]
 81041ee:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 81041f2:	2b01      	cmp	r3, #1
 81041f4:	d101      	bne.n	81041fa <HAL_PCD_EP_SetStall+0x82>
 81041f6:	2302      	movs	r3, #2
 81041f8:	e01d      	b.n	8104236 <HAL_PCD_EP_SetStall+0xbe>
 81041fa:	687b      	ldr	r3, [r7, #4]
 81041fc:	2201      	movs	r2, #1
 81041fe:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 8104202:	687b      	ldr	r3, [r7, #4]
 8104204:	681b      	ldr	r3, [r3, #0]
 8104206:	68f9      	ldr	r1, [r7, #12]
 8104208:	4618      	mov	r0, r3
 810420a:	f006 fc19 	bl	810aa40 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 810420e:	78fb      	ldrb	r3, [r7, #3]
 8104210:	f003 030f 	and.w	r3, r3, #15
 8104214:	2b00      	cmp	r3, #0
 8104216:	d109      	bne.n	810422c <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8104218:	687b      	ldr	r3, [r7, #4]
 810421a:	6818      	ldr	r0, [r3, #0]
 810421c:	687b      	ldr	r3, [r7, #4]
 810421e:	7999      	ldrb	r1, [r3, #6]
 8104220:	687b      	ldr	r3, [r7, #4]
 8104222:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8104226:	461a      	mov	r2, r3
 8104228:	f006 fe0a 	bl	810ae40 <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 810422c:	687b      	ldr	r3, [r7, #4]
 810422e:	2200      	movs	r2, #0
 8104230:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8104234:	2300      	movs	r3, #0
}
 8104236:	4618      	mov	r0, r3
 8104238:	3710      	adds	r7, #16
 810423a:	46bd      	mov	sp, r7
 810423c:	bd80      	pop	{r7, pc}

0810423e <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 810423e:	b580      	push	{r7, lr}
 8104240:	b084      	sub	sp, #16
 8104242:	af00      	add	r7, sp, #0
 8104244:	6078      	str	r0, [r7, #4]
 8104246:	460b      	mov	r3, r1
 8104248:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 810424a:	78fb      	ldrb	r3, [r7, #3]
 810424c:	f003 030f 	and.w	r3, r3, #15
 8104250:	687a      	ldr	r2, [r7, #4]
 8104252:	7912      	ldrb	r2, [r2, #4]
 8104254:	4293      	cmp	r3, r2
 8104256:	d901      	bls.n	810425c <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 8104258:	2301      	movs	r3, #1
 810425a:	e042      	b.n	81042e2 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 810425c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8104260:	2b00      	cmp	r3, #0
 8104262:	da0f      	bge.n	8104284 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8104264:	78fb      	ldrb	r3, [r7, #3]
 8104266:	f003 020f 	and.w	r2, r3, #15
 810426a:	4613      	mov	r3, r2
 810426c:	00db      	lsls	r3, r3, #3
 810426e:	4413      	add	r3, r2
 8104270:	009b      	lsls	r3, r3, #2
 8104272:	3310      	adds	r3, #16
 8104274:	687a      	ldr	r2, [r7, #4]
 8104276:	4413      	add	r3, r2
 8104278:	3304      	adds	r3, #4
 810427a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 810427c:	68fb      	ldr	r3, [r7, #12]
 810427e:	2201      	movs	r2, #1
 8104280:	705a      	strb	r2, [r3, #1]
 8104282:	e00f      	b.n	81042a4 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8104284:	78fb      	ldrb	r3, [r7, #3]
 8104286:	f003 020f 	and.w	r2, r3, #15
 810428a:	4613      	mov	r3, r2
 810428c:	00db      	lsls	r3, r3, #3
 810428e:	4413      	add	r3, r2
 8104290:	009b      	lsls	r3, r3, #2
 8104292:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8104296:	687a      	ldr	r2, [r7, #4]
 8104298:	4413      	add	r3, r2
 810429a:	3304      	adds	r3, #4
 810429c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 810429e:	68fb      	ldr	r3, [r7, #12]
 81042a0:	2200      	movs	r2, #0
 81042a2:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 81042a4:	68fb      	ldr	r3, [r7, #12]
 81042a6:	2200      	movs	r2, #0
 81042a8:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 81042aa:	78fb      	ldrb	r3, [r7, #3]
 81042ac:	f003 030f 	and.w	r3, r3, #15
 81042b0:	b2da      	uxtb	r2, r3
 81042b2:	68fb      	ldr	r3, [r7, #12]
 81042b4:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 81042b6:	687b      	ldr	r3, [r7, #4]
 81042b8:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 81042bc:	2b01      	cmp	r3, #1
 81042be:	d101      	bne.n	81042c4 <HAL_PCD_EP_ClrStall+0x86>
 81042c0:	2302      	movs	r3, #2
 81042c2:	e00e      	b.n	81042e2 <HAL_PCD_EP_ClrStall+0xa4>
 81042c4:	687b      	ldr	r3, [r7, #4]
 81042c6:	2201      	movs	r2, #1
 81042c8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 81042cc:	687b      	ldr	r3, [r7, #4]
 81042ce:	681b      	ldr	r3, [r3, #0]
 81042d0:	68f9      	ldr	r1, [r7, #12]
 81042d2:	4618      	mov	r0, r3
 81042d4:	f006 fc22 	bl	810ab1c <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 81042d8:	687b      	ldr	r3, [r7, #4]
 81042da:	2200      	movs	r2, #0
 81042dc:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 81042e0:	2300      	movs	r3, #0
}
 81042e2:	4618      	mov	r0, r3
 81042e4:	3710      	adds	r7, #16
 81042e6:	46bd      	mov	sp, r7
 81042e8:	bd80      	pop	{r7, pc}

081042ea <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 81042ea:	b580      	push	{r7, lr}
 81042ec:	b084      	sub	sp, #16
 81042ee:	af00      	add	r7, sp, #0
 81042f0:	6078      	str	r0, [r7, #4]
 81042f2:	460b      	mov	r3, r1
 81042f4:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 81042f6:	f997 3003 	ldrsb.w	r3, [r7, #3]
 81042fa:	2b00      	cmp	r3, #0
 81042fc:	da0c      	bge.n	8104318 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 81042fe:	78fb      	ldrb	r3, [r7, #3]
 8104300:	f003 020f 	and.w	r2, r3, #15
 8104304:	4613      	mov	r3, r2
 8104306:	00db      	lsls	r3, r3, #3
 8104308:	4413      	add	r3, r2
 810430a:	009b      	lsls	r3, r3, #2
 810430c:	3310      	adds	r3, #16
 810430e:	687a      	ldr	r2, [r7, #4]
 8104310:	4413      	add	r3, r2
 8104312:	3304      	adds	r3, #4
 8104314:	60fb      	str	r3, [r7, #12]
 8104316:	e00c      	b.n	8104332 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8104318:	78fb      	ldrb	r3, [r7, #3]
 810431a:	f003 020f 	and.w	r2, r3, #15
 810431e:	4613      	mov	r3, r2
 8104320:	00db      	lsls	r3, r3, #3
 8104322:	4413      	add	r3, r2
 8104324:	009b      	lsls	r3, r3, #2
 8104326:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 810432a:	687a      	ldr	r2, [r7, #4]
 810432c:	4413      	add	r3, r2
 810432e:	3304      	adds	r3, #4
 8104330:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8104332:	687b      	ldr	r3, [r7, #4]
 8104334:	681b      	ldr	r3, [r3, #0]
 8104336:	68f9      	ldr	r1, [r7, #12]
 8104338:	4618      	mov	r0, r3
 810433a:	f006 fa41 	bl	810a7c0 <USB_EPStopXfer>
 810433e:	4603      	mov	r3, r0
 8104340:	72fb      	strb	r3, [r7, #11]

  return ret;
 8104342:	7afb      	ldrb	r3, [r7, #11]
}
 8104344:	4618      	mov	r0, r3
 8104346:	3710      	adds	r7, #16
 8104348:	46bd      	mov	sp, r7
 810434a:	bd80      	pop	{r7, pc}

0810434c <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 810434c:	b580      	push	{r7, lr}
 810434e:	b08a      	sub	sp, #40	@ 0x28
 8104350:	af02      	add	r7, sp, #8
 8104352:	6078      	str	r0, [r7, #4]
 8104354:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8104356:	687b      	ldr	r3, [r7, #4]
 8104358:	681b      	ldr	r3, [r3, #0]
 810435a:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810435c:	697b      	ldr	r3, [r7, #20]
 810435e:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 8104360:	683a      	ldr	r2, [r7, #0]
 8104362:	4613      	mov	r3, r2
 8104364:	00db      	lsls	r3, r3, #3
 8104366:	4413      	add	r3, r2
 8104368:	009b      	lsls	r3, r3, #2
 810436a:	3310      	adds	r3, #16
 810436c:	687a      	ldr	r2, [r7, #4]
 810436e:	4413      	add	r3, r2
 8104370:	3304      	adds	r3, #4
 8104372:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 8104374:	68fb      	ldr	r3, [r7, #12]
 8104376:	695a      	ldr	r2, [r3, #20]
 8104378:	68fb      	ldr	r3, [r7, #12]
 810437a:	691b      	ldr	r3, [r3, #16]
 810437c:	429a      	cmp	r2, r3
 810437e:	d901      	bls.n	8104384 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 8104380:	2301      	movs	r3, #1
 8104382:	e06b      	b.n	810445c <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 8104384:	68fb      	ldr	r3, [r7, #12]
 8104386:	691a      	ldr	r2, [r3, #16]
 8104388:	68fb      	ldr	r3, [r7, #12]
 810438a:	695b      	ldr	r3, [r3, #20]
 810438c:	1ad3      	subs	r3, r2, r3
 810438e:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 8104390:	68fb      	ldr	r3, [r7, #12]
 8104392:	689b      	ldr	r3, [r3, #8]
 8104394:	69fa      	ldr	r2, [r7, #28]
 8104396:	429a      	cmp	r2, r3
 8104398:	d902      	bls.n	81043a0 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 810439a:	68fb      	ldr	r3, [r7, #12]
 810439c:	689b      	ldr	r3, [r3, #8]
 810439e:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 81043a0:	69fb      	ldr	r3, [r7, #28]
 81043a2:	3303      	adds	r3, #3
 81043a4:	089b      	lsrs	r3, r3, #2
 81043a6:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 81043a8:	e02a      	b.n	8104400 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 81043aa:	68fb      	ldr	r3, [r7, #12]
 81043ac:	691a      	ldr	r2, [r3, #16]
 81043ae:	68fb      	ldr	r3, [r7, #12]
 81043b0:	695b      	ldr	r3, [r3, #20]
 81043b2:	1ad3      	subs	r3, r2, r3
 81043b4:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 81043b6:	68fb      	ldr	r3, [r7, #12]
 81043b8:	689b      	ldr	r3, [r3, #8]
 81043ba:	69fa      	ldr	r2, [r7, #28]
 81043bc:	429a      	cmp	r2, r3
 81043be:	d902      	bls.n	81043c6 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 81043c0:	68fb      	ldr	r3, [r7, #12]
 81043c2:	689b      	ldr	r3, [r3, #8]
 81043c4:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 81043c6:	69fb      	ldr	r3, [r7, #28]
 81043c8:	3303      	adds	r3, #3
 81043ca:	089b      	lsrs	r3, r3, #2
 81043cc:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 81043ce:	68fb      	ldr	r3, [r7, #12]
 81043d0:	68d9      	ldr	r1, [r3, #12]
 81043d2:	683b      	ldr	r3, [r7, #0]
 81043d4:	b2da      	uxtb	r2, r3
 81043d6:	69fb      	ldr	r3, [r7, #28]
 81043d8:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 81043da:	687b      	ldr	r3, [r7, #4]
 81043dc:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 81043de:	9300      	str	r3, [sp, #0]
 81043e0:	4603      	mov	r3, r0
 81043e2:	6978      	ldr	r0, [r7, #20]
 81043e4:	f006 fa96 	bl	810a914 <USB_WritePacket>

    ep->xfer_buff  += len;
 81043e8:	68fb      	ldr	r3, [r7, #12]
 81043ea:	68da      	ldr	r2, [r3, #12]
 81043ec:	69fb      	ldr	r3, [r7, #28]
 81043ee:	441a      	add	r2, r3
 81043f0:	68fb      	ldr	r3, [r7, #12]
 81043f2:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 81043f4:	68fb      	ldr	r3, [r7, #12]
 81043f6:	695a      	ldr	r2, [r3, #20]
 81043f8:	69fb      	ldr	r3, [r7, #28]
 81043fa:	441a      	add	r2, r3
 81043fc:	68fb      	ldr	r3, [r7, #12]
 81043fe:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8104400:	683b      	ldr	r3, [r7, #0]
 8104402:	015a      	lsls	r2, r3, #5
 8104404:	693b      	ldr	r3, [r7, #16]
 8104406:	4413      	add	r3, r2
 8104408:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810440c:	699b      	ldr	r3, [r3, #24]
 810440e:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8104410:	69ba      	ldr	r2, [r7, #24]
 8104412:	429a      	cmp	r2, r3
 8104414:	d809      	bhi.n	810442a <PCD_WriteEmptyTxFifo+0xde>
 8104416:	68fb      	ldr	r3, [r7, #12]
 8104418:	695a      	ldr	r2, [r3, #20]
 810441a:	68fb      	ldr	r3, [r7, #12]
 810441c:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 810441e:	429a      	cmp	r2, r3
 8104420:	d203      	bcs.n	810442a <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8104422:	68fb      	ldr	r3, [r7, #12]
 8104424:	691b      	ldr	r3, [r3, #16]
 8104426:	2b00      	cmp	r3, #0
 8104428:	d1bf      	bne.n	81043aa <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 810442a:	68fb      	ldr	r3, [r7, #12]
 810442c:	691a      	ldr	r2, [r3, #16]
 810442e:	68fb      	ldr	r3, [r7, #12]
 8104430:	695b      	ldr	r3, [r3, #20]
 8104432:	429a      	cmp	r2, r3
 8104434:	d811      	bhi.n	810445a <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8104436:	683b      	ldr	r3, [r7, #0]
 8104438:	f003 030f 	and.w	r3, r3, #15
 810443c:	2201      	movs	r2, #1
 810443e:	fa02 f303 	lsl.w	r3, r2, r3
 8104442:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8104444:	693b      	ldr	r3, [r7, #16]
 8104446:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810444a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 810444c:	68bb      	ldr	r3, [r7, #8]
 810444e:	43db      	mvns	r3, r3
 8104450:	6939      	ldr	r1, [r7, #16]
 8104452:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8104456:	4013      	ands	r3, r2
 8104458:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 810445a:	2300      	movs	r3, #0
}
 810445c:	4618      	mov	r0, r3
 810445e:	3720      	adds	r7, #32
 8104460:	46bd      	mov	sp, r7
 8104462:	bd80      	pop	{r7, pc}

08104464 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8104464:	b580      	push	{r7, lr}
 8104466:	b088      	sub	sp, #32
 8104468:	af00      	add	r7, sp, #0
 810446a:	6078      	str	r0, [r7, #4]
 810446c:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 810446e:	687b      	ldr	r3, [r7, #4]
 8104470:	681b      	ldr	r3, [r3, #0]
 8104472:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8104474:	69fb      	ldr	r3, [r7, #28]
 8104476:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8104478:	69fb      	ldr	r3, [r7, #28]
 810447a:	333c      	adds	r3, #60	@ 0x3c
 810447c:	3304      	adds	r3, #4
 810447e:	681b      	ldr	r3, [r3, #0]
 8104480:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8104482:	683b      	ldr	r3, [r7, #0]
 8104484:	015a      	lsls	r2, r3, #5
 8104486:	69bb      	ldr	r3, [r7, #24]
 8104488:	4413      	add	r3, r2
 810448a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810448e:	689b      	ldr	r3, [r3, #8]
 8104490:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 8104492:	687b      	ldr	r3, [r7, #4]
 8104494:	799b      	ldrb	r3, [r3, #6]
 8104496:	2b01      	cmp	r3, #1
 8104498:	d17b      	bne.n	8104592 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 810449a:	693b      	ldr	r3, [r7, #16]
 810449c:	f003 0308 	and.w	r3, r3, #8
 81044a0:	2b00      	cmp	r3, #0
 81044a2:	d015      	beq.n	81044d0 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 81044a4:	697b      	ldr	r3, [r7, #20]
 81044a6:	4a61      	ldr	r2, [pc, #388]	@ (810462c <PCD_EP_OutXfrComplete_int+0x1c8>)
 81044a8:	4293      	cmp	r3, r2
 81044aa:	f240 80b9 	bls.w	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 81044ae:	693b      	ldr	r3, [r7, #16]
 81044b0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 81044b4:	2b00      	cmp	r3, #0
 81044b6:	f000 80b3 	beq.w	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 81044ba:	683b      	ldr	r3, [r7, #0]
 81044bc:	015a      	lsls	r2, r3, #5
 81044be:	69bb      	ldr	r3, [r7, #24]
 81044c0:	4413      	add	r3, r2
 81044c2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81044c6:	461a      	mov	r2, r3
 81044c8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 81044cc:	6093      	str	r3, [r2, #8]
 81044ce:	e0a7      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 81044d0:	693b      	ldr	r3, [r7, #16]
 81044d2:	f003 0320 	and.w	r3, r3, #32
 81044d6:	2b00      	cmp	r3, #0
 81044d8:	d009      	beq.n	81044ee <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 81044da:	683b      	ldr	r3, [r7, #0]
 81044dc:	015a      	lsls	r2, r3, #5
 81044de:	69bb      	ldr	r3, [r7, #24]
 81044e0:	4413      	add	r3, r2
 81044e2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81044e6:	461a      	mov	r2, r3
 81044e8:	2320      	movs	r3, #32
 81044ea:	6093      	str	r3, [r2, #8]
 81044ec:	e098      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 81044ee:	693b      	ldr	r3, [r7, #16]
 81044f0:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 81044f4:	2b00      	cmp	r3, #0
 81044f6:	f040 8093 	bne.w	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 81044fa:	697b      	ldr	r3, [r7, #20]
 81044fc:	4a4b      	ldr	r2, [pc, #300]	@ (810462c <PCD_EP_OutXfrComplete_int+0x1c8>)
 81044fe:	4293      	cmp	r3, r2
 8104500:	d90f      	bls.n	8104522 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8104502:	693b      	ldr	r3, [r7, #16]
 8104504:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8104508:	2b00      	cmp	r3, #0
 810450a:	d00a      	beq.n	8104522 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 810450c:	683b      	ldr	r3, [r7, #0]
 810450e:	015a      	lsls	r2, r3, #5
 8104510:	69bb      	ldr	r3, [r7, #24]
 8104512:	4413      	add	r3, r2
 8104514:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8104518:	461a      	mov	r2, r3
 810451a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 810451e:	6093      	str	r3, [r2, #8]
 8104520:	e07e      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 8104522:	683a      	ldr	r2, [r7, #0]
 8104524:	4613      	mov	r3, r2
 8104526:	00db      	lsls	r3, r3, #3
 8104528:	4413      	add	r3, r2
 810452a:	009b      	lsls	r3, r3, #2
 810452c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8104530:	687a      	ldr	r2, [r7, #4]
 8104532:	4413      	add	r3, r2
 8104534:	3304      	adds	r3, #4
 8104536:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8104538:	68fb      	ldr	r3, [r7, #12]
 810453a:	6a1a      	ldr	r2, [r3, #32]
 810453c:	683b      	ldr	r3, [r7, #0]
 810453e:	0159      	lsls	r1, r3, #5
 8104540:	69bb      	ldr	r3, [r7, #24]
 8104542:	440b      	add	r3, r1
 8104544:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8104548:	691b      	ldr	r3, [r3, #16]
 810454a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810454e:	1ad2      	subs	r2, r2, r3
 8104550:	68fb      	ldr	r3, [r7, #12]
 8104552:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 8104554:	683b      	ldr	r3, [r7, #0]
 8104556:	2b00      	cmp	r3, #0
 8104558:	d114      	bne.n	8104584 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 810455a:	68fb      	ldr	r3, [r7, #12]
 810455c:	691b      	ldr	r3, [r3, #16]
 810455e:	2b00      	cmp	r3, #0
 8104560:	d109      	bne.n	8104576 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8104562:	687b      	ldr	r3, [r7, #4]
 8104564:	6818      	ldr	r0, [r3, #0]
 8104566:	687b      	ldr	r3, [r7, #4]
 8104568:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 810456c:	461a      	mov	r2, r3
 810456e:	2101      	movs	r1, #1
 8104570:	f006 fc66 	bl	810ae40 <USB_EP0_OutStart>
 8104574:	e006      	b.n	8104584 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 8104576:	68fb      	ldr	r3, [r7, #12]
 8104578:	68da      	ldr	r2, [r3, #12]
 810457a:	68fb      	ldr	r3, [r7, #12]
 810457c:	695b      	ldr	r3, [r3, #20]
 810457e:	441a      	add	r2, r3
 8104580:	68fb      	ldr	r3, [r7, #12]
 8104582:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8104584:	683b      	ldr	r3, [r7, #0]
 8104586:	b2db      	uxtb	r3, r3
 8104588:	4619      	mov	r1, r3
 810458a:	6878      	ldr	r0, [r7, #4]
 810458c:	f008 ff1c 	bl	810d3c8 <HAL_PCD_DataOutStageCallback>
 8104590:	e046      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8104592:	697b      	ldr	r3, [r7, #20]
 8104594:	4a26      	ldr	r2, [pc, #152]	@ (8104630 <PCD_EP_OutXfrComplete_int+0x1cc>)
 8104596:	4293      	cmp	r3, r2
 8104598:	d124      	bne.n	81045e4 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 810459a:	693b      	ldr	r3, [r7, #16]
 810459c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 81045a0:	2b00      	cmp	r3, #0
 81045a2:	d00a      	beq.n	81045ba <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 81045a4:	683b      	ldr	r3, [r7, #0]
 81045a6:	015a      	lsls	r2, r3, #5
 81045a8:	69bb      	ldr	r3, [r7, #24]
 81045aa:	4413      	add	r3, r2
 81045ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81045b0:	461a      	mov	r2, r3
 81045b2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 81045b6:	6093      	str	r3, [r2, #8]
 81045b8:	e032      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 81045ba:	693b      	ldr	r3, [r7, #16]
 81045bc:	f003 0320 	and.w	r3, r3, #32
 81045c0:	2b00      	cmp	r3, #0
 81045c2:	d008      	beq.n	81045d6 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 81045c4:	683b      	ldr	r3, [r7, #0]
 81045c6:	015a      	lsls	r2, r3, #5
 81045c8:	69bb      	ldr	r3, [r7, #24]
 81045ca:	4413      	add	r3, r2
 81045cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 81045d0:	461a      	mov	r2, r3
 81045d2:	2320      	movs	r3, #32
 81045d4:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 81045d6:	683b      	ldr	r3, [r7, #0]
 81045d8:	b2db      	uxtb	r3, r3
 81045da:	4619      	mov	r1, r3
 81045dc:	6878      	ldr	r0, [r7, #4]
 81045de:	f008 fef3 	bl	810d3c8 <HAL_PCD_DataOutStageCallback>
 81045e2:	e01d      	b.n	8104620 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 81045e4:	683b      	ldr	r3, [r7, #0]
 81045e6:	2b00      	cmp	r3, #0
 81045e8:	d114      	bne.n	8104614 <PCD_EP_OutXfrComplete_int+0x1b0>
 81045ea:	6879      	ldr	r1, [r7, #4]
 81045ec:	683a      	ldr	r2, [r7, #0]
 81045ee:	4613      	mov	r3, r2
 81045f0:	00db      	lsls	r3, r3, #3
 81045f2:	4413      	add	r3, r2
 81045f4:	009b      	lsls	r3, r3, #2
 81045f6:	440b      	add	r3, r1
 81045f8:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 81045fc:	681b      	ldr	r3, [r3, #0]
 81045fe:	2b00      	cmp	r3, #0
 8104600:	d108      	bne.n	8104614 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8104602:	687b      	ldr	r3, [r7, #4]
 8104604:	6818      	ldr	r0, [r3, #0]
 8104606:	687b      	ldr	r3, [r7, #4]
 8104608:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 810460c:	461a      	mov	r2, r3
 810460e:	2100      	movs	r1, #0
 8104610:	f006 fc16 	bl	810ae40 <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8104614:	683b      	ldr	r3, [r7, #0]
 8104616:	b2db      	uxtb	r3, r3
 8104618:	4619      	mov	r1, r3
 810461a:	6878      	ldr	r0, [r7, #4]
 810461c:	f008 fed4 	bl	810d3c8 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 8104620:	2300      	movs	r3, #0
}
 8104622:	4618      	mov	r0, r3
 8104624:	3720      	adds	r7, #32
 8104626:	46bd      	mov	sp, r7
 8104628:	bd80      	pop	{r7, pc}
 810462a:	bf00      	nop
 810462c:	4f54300a 	.word	0x4f54300a
 8104630:	4f54310a 	.word	0x4f54310a

08104634 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8104634:	b580      	push	{r7, lr}
 8104636:	b086      	sub	sp, #24
 8104638:	af00      	add	r7, sp, #0
 810463a:	6078      	str	r0, [r7, #4]
 810463c:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 810463e:	687b      	ldr	r3, [r7, #4]
 8104640:	681b      	ldr	r3, [r3, #0]
 8104642:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8104644:	697b      	ldr	r3, [r7, #20]
 8104646:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8104648:	697b      	ldr	r3, [r7, #20]
 810464a:	333c      	adds	r3, #60	@ 0x3c
 810464c:	3304      	adds	r3, #4
 810464e:	681b      	ldr	r3, [r3, #0]
 8104650:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8104652:	683b      	ldr	r3, [r7, #0]
 8104654:	015a      	lsls	r2, r3, #5
 8104656:	693b      	ldr	r3, [r7, #16]
 8104658:	4413      	add	r3, r2
 810465a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810465e:	689b      	ldr	r3, [r3, #8]
 8104660:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8104662:	68fb      	ldr	r3, [r7, #12]
 8104664:	4a15      	ldr	r2, [pc, #84]	@ (81046bc <PCD_EP_OutSetupPacket_int+0x88>)
 8104666:	4293      	cmp	r3, r2
 8104668:	d90e      	bls.n	8104688 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 810466a:	68bb      	ldr	r3, [r7, #8]
 810466c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8104670:	2b00      	cmp	r3, #0
 8104672:	d009      	beq.n	8104688 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8104674:	683b      	ldr	r3, [r7, #0]
 8104676:	015a      	lsls	r2, r3, #5
 8104678:	693b      	ldr	r3, [r7, #16]
 810467a:	4413      	add	r3, r2
 810467c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8104680:	461a      	mov	r2, r3
 8104682:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8104686:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8104688:	6878      	ldr	r0, [r7, #4]
 810468a:	f008 fe8b 	bl	810d3a4 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 810468e:	68fb      	ldr	r3, [r7, #12]
 8104690:	4a0a      	ldr	r2, [pc, #40]	@ (81046bc <PCD_EP_OutSetupPacket_int+0x88>)
 8104692:	4293      	cmp	r3, r2
 8104694:	d90c      	bls.n	81046b0 <PCD_EP_OutSetupPacket_int+0x7c>
 8104696:	687b      	ldr	r3, [r7, #4]
 8104698:	799b      	ldrb	r3, [r3, #6]
 810469a:	2b01      	cmp	r3, #1
 810469c:	d108      	bne.n	81046b0 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 810469e:	687b      	ldr	r3, [r7, #4]
 81046a0:	6818      	ldr	r0, [r3, #0]
 81046a2:	687b      	ldr	r3, [r7, #4]
 81046a4:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 81046a8:	461a      	mov	r2, r3
 81046aa:	2101      	movs	r1, #1
 81046ac:	f006 fbc8 	bl	810ae40 <USB_EP0_OutStart>
  }

  return HAL_OK;
 81046b0:	2300      	movs	r3, #0
}
 81046b2:	4618      	mov	r0, r3
 81046b4:	3718      	adds	r7, #24
 81046b6:	46bd      	mov	sp, r7
 81046b8:	bd80      	pop	{r7, pc}
 81046ba:	bf00      	nop
 81046bc:	4f54300a 	.word	0x4f54300a

081046c0 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 81046c0:	b480      	push	{r7}
 81046c2:	b085      	sub	sp, #20
 81046c4:	af00      	add	r7, sp, #0
 81046c6:	6078      	str	r0, [r7, #4]
 81046c8:	460b      	mov	r3, r1
 81046ca:	70fb      	strb	r3, [r7, #3]
 81046cc:	4613      	mov	r3, r2
 81046ce:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 81046d0:	687b      	ldr	r3, [r7, #4]
 81046d2:	681b      	ldr	r3, [r3, #0]
 81046d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 81046d6:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 81046d8:	78fb      	ldrb	r3, [r7, #3]
 81046da:	2b00      	cmp	r3, #0
 81046dc:	d107      	bne.n	81046ee <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 81046de:	883b      	ldrh	r3, [r7, #0]
 81046e0:	0419      	lsls	r1, r3, #16
 81046e2:	687b      	ldr	r3, [r7, #4]
 81046e4:	681b      	ldr	r3, [r3, #0]
 81046e6:	68ba      	ldr	r2, [r7, #8]
 81046e8:	430a      	orrs	r2, r1
 81046ea:	629a      	str	r2, [r3, #40]	@ 0x28
 81046ec:	e028      	b.n	8104740 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 81046ee:	687b      	ldr	r3, [r7, #4]
 81046f0:	681b      	ldr	r3, [r3, #0]
 81046f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81046f4:	0c1b      	lsrs	r3, r3, #16
 81046f6:	68ba      	ldr	r2, [r7, #8]
 81046f8:	4413      	add	r3, r2
 81046fa:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 81046fc:	2300      	movs	r3, #0
 81046fe:	73fb      	strb	r3, [r7, #15]
 8104700:	e00d      	b.n	810471e <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8104702:	687b      	ldr	r3, [r7, #4]
 8104704:	681a      	ldr	r2, [r3, #0]
 8104706:	7bfb      	ldrb	r3, [r7, #15]
 8104708:	3340      	adds	r3, #64	@ 0x40
 810470a:	009b      	lsls	r3, r3, #2
 810470c:	4413      	add	r3, r2
 810470e:	685b      	ldr	r3, [r3, #4]
 8104710:	0c1b      	lsrs	r3, r3, #16
 8104712:	68ba      	ldr	r2, [r7, #8]
 8104714:	4413      	add	r3, r2
 8104716:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8104718:	7bfb      	ldrb	r3, [r7, #15]
 810471a:	3301      	adds	r3, #1
 810471c:	73fb      	strb	r3, [r7, #15]
 810471e:	7bfa      	ldrb	r2, [r7, #15]
 8104720:	78fb      	ldrb	r3, [r7, #3]
 8104722:	3b01      	subs	r3, #1
 8104724:	429a      	cmp	r2, r3
 8104726:	d3ec      	bcc.n	8104702 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8104728:	883b      	ldrh	r3, [r7, #0]
 810472a:	0418      	lsls	r0, r3, #16
 810472c:	687b      	ldr	r3, [r7, #4]
 810472e:	6819      	ldr	r1, [r3, #0]
 8104730:	78fb      	ldrb	r3, [r7, #3]
 8104732:	3b01      	subs	r3, #1
 8104734:	68ba      	ldr	r2, [r7, #8]
 8104736:	4302      	orrs	r2, r0
 8104738:	3340      	adds	r3, #64	@ 0x40
 810473a:	009b      	lsls	r3, r3, #2
 810473c:	440b      	add	r3, r1
 810473e:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 8104740:	2300      	movs	r3, #0
}
 8104742:	4618      	mov	r0, r3
 8104744:	3714      	adds	r7, #20
 8104746:	46bd      	mov	sp, r7
 8104748:	f85d 7b04 	ldr.w	r7, [sp], #4
 810474c:	4770      	bx	lr

0810474e <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 810474e:	b480      	push	{r7}
 8104750:	b083      	sub	sp, #12
 8104752:	af00      	add	r7, sp, #0
 8104754:	6078      	str	r0, [r7, #4]
 8104756:	460b      	mov	r3, r1
 8104758:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 810475a:	687b      	ldr	r3, [r7, #4]
 810475c:	681b      	ldr	r3, [r3, #0]
 810475e:	887a      	ldrh	r2, [r7, #2]
 8104760:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 8104762:	2300      	movs	r3, #0
}
 8104764:	4618      	mov	r0, r3
 8104766:	370c      	adds	r7, #12
 8104768:	46bd      	mov	sp, r7
 810476a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810476e:	4770      	bx	lr

08104770 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8104770:	b480      	push	{r7}
 8104772:	b085      	sub	sp, #20
 8104774:	af00      	add	r7, sp, #0
 8104776:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8104778:	687b      	ldr	r3, [r7, #4]
 810477a:	681b      	ldr	r3, [r3, #0]
 810477c:	60fb      	str	r3, [r7, #12]

  hpcd->lpm_active = 1U;
 810477e:	687b      	ldr	r3, [r7, #4]
 8104780:	2201      	movs	r2, #1
 8104782:	f8c3 24d8 	str.w	r2, [r3, #1240]	@ 0x4d8
  hpcd->LPM_State = LPM_L0;
 8104786:	687b      	ldr	r3, [r7, #4]
 8104788:	2200      	movs	r2, #0
 810478a:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 810478e:	68fb      	ldr	r3, [r7, #12]
 8104790:	699b      	ldr	r3, [r3, #24]
 8104792:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8104796:	68fb      	ldr	r3, [r7, #12]
 8104798:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 810479a:	68fb      	ldr	r3, [r7, #12]
 810479c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 810479e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 81047a2:	f043 0303 	orr.w	r3, r3, #3
 81047a6:	68fa      	ldr	r2, [r7, #12]
 81047a8:	6553      	str	r3, [r2, #84]	@ 0x54

  return HAL_OK;
 81047aa:	2300      	movs	r3, #0
}
 81047ac:	4618      	mov	r0, r3
 81047ae:	3714      	adds	r7, #20
 81047b0:	46bd      	mov	sp, r7
 81047b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81047b6:	4770      	bx	lr

081047b8 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 81047b8:	b480      	push	{r7}
 81047ba:	b083      	sub	sp, #12
 81047bc:	af00      	add	r7, sp, #0
 81047be:	6078      	str	r0, [r7, #4]
 81047c0:	460b      	mov	r3, r1
 81047c2:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 81047c4:	bf00      	nop
 81047c6:	370c      	adds	r7, #12
 81047c8:	46bd      	mov	sp, r7
 81047ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 81047ce:	4770      	bx	lr

081047d0 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
 81047d0:	b580      	push	{r7, lr}
 81047d2:	b084      	sub	sp, #16
 81047d4:	af00      	add	r7, sp, #0
 81047d6:	60f8      	str	r0, [r7, #12]
 81047d8:	460b      	mov	r3, r1
 81047da:	607a      	str	r2, [r7, #4]
 81047dc:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
 81047de:	4b37      	ldr	r3, [pc, #220]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 81047e0:	681b      	ldr	r3, [r3, #0]
 81047e2:	f023 0201 	bic.w	r2, r3, #1
 81047e6:	4935      	ldr	r1, [pc, #212]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 81047e8:	68fb      	ldr	r3, [r7, #12]
 81047ea:	4313      	orrs	r3, r2
 81047ec:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
 81047ee:	687b      	ldr	r3, [r7, #4]
 81047f0:	2b00      	cmp	r3, #0
 81047f2:	d123      	bne.n	810483c <HAL_PWREx_EnterSTOPMode+0x6c>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM7_CPUID)
 81047f4:	f7fd f9c8 	bl	8101b88 <HAL_GetCurrentCPUID>
 81047f8:	4603      	mov	r3, r0
 81047fa:	2b03      	cmp	r3, #3
 81047fc:	d158      	bne.n	81048b0 <HAL_PWREx_EnterSTOPMode+0xe0>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 81047fe:	4b2f      	ldr	r3, [pc, #188]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 8104800:	691b      	ldr	r3, [r3, #16]
 8104802:	4a2e      	ldr	r2, [pc, #184]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 8104804:	f023 0301 	bic.w	r3, r3, #1
 8104808:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 810480a:	4b2d      	ldr	r3, [pc, #180]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 810480c:	691b      	ldr	r3, [r3, #16]
 810480e:	4a2c      	ldr	r2, [pc, #176]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8104810:	f043 0304 	orr.w	r3, r3, #4
 8104814:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8104816:	f3bf 8f4f 	dsb	sy
}
 810481a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 810481c:	f3bf 8f6f 	isb	sy
}
 8104820:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8104822:	7afb      	ldrb	r3, [r7, #11]
 8104824:	2b01      	cmp	r3, #1
 8104826:	d101      	bne.n	810482c <HAL_PWREx_EnterSTOPMode+0x5c>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8104828:	bf30      	wfi
 810482a:	e000      	b.n	810482e <HAL_PWREx_EnterSTOPMode+0x5e>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 810482c:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 810482e:	4b24      	ldr	r3, [pc, #144]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8104830:	691b      	ldr	r3, [r3, #16]
 8104832:	4a23      	ldr	r2, [pc, #140]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8104834:	f023 0304 	bic.w	r3, r3, #4
 8104838:	6113      	str	r3, [r2, #16]
 810483a:	e03c      	b.n	81048b6 <HAL_PWREx_EnterSTOPMode+0xe6>
  }
#if defined (PWR_CPUCR_PDDS_D2)
  else if (Domain == PWR_D2_DOMAIN)
 810483c:	687b      	ldr	r3, [r7, #4]
 810483e:	2b01      	cmp	r3, #1
 8104840:	d123      	bne.n	810488a <HAL_PWREx_EnterSTOPMode+0xba>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM4_CPUID)
 8104842:	f7fd f9a1 	bl	8101b88 <HAL_GetCurrentCPUID>
 8104846:	4603      	mov	r3, r0
 8104848:	2b01      	cmp	r3, #1
 810484a:	d133      	bne.n	81048b4 <HAL_PWREx_EnterSTOPMode+0xe4>
      */
      return;
    }

    /* Keep DSTOP mode when D2 domain enters Deepsleep */
    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);
 810484c:	4b1b      	ldr	r3, [pc, #108]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 810484e:	695b      	ldr	r3, [r3, #20]
 8104850:	4a1a      	ldr	r2, [pc, #104]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 8104852:	f023 0302 	bic.w	r3, r3, #2
 8104856:	6153      	str	r3, [r2, #20]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8104858:	4b19      	ldr	r3, [pc, #100]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 810485a:	691b      	ldr	r3, [r3, #16]
 810485c:	4a18      	ldr	r2, [pc, #96]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 810485e:	f043 0304 	orr.w	r3, r3, #4
 8104862:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8104864:	f3bf 8f4f 	dsb	sy
}
 8104868:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 810486a:	f3bf 8f6f 	isb	sy
}
 810486e:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8104870:	7afb      	ldrb	r3, [r7, #11]
 8104872:	2b01      	cmp	r3, #1
 8104874:	d101      	bne.n	810487a <HAL_PWREx_EnterSTOPMode+0xaa>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8104876:	bf30      	wfi
 8104878:	e000      	b.n	810487c <HAL_PWREx_EnterSTOPMode+0xac>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 810487a:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 810487c:	4b10      	ldr	r3, [pc, #64]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 810487e:	691b      	ldr	r3, [r3, #16]
 8104880:	4a0f      	ldr	r2, [pc, #60]	@ (81048c0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8104882:	f023 0304 	bic.w	r3, r3, #4
 8104886:	6113      	str	r3, [r2, #16]
 8104888:	e015      	b.n	81048b6 <HAL_PWREx_EnterSTOPMode+0xe6>
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
 810488a:	f7fd f97d 	bl	8101b88 <HAL_GetCurrentCPUID>
 810488e:	4603      	mov	r3, r0
 8104890:	2b03      	cmp	r3, #3
 8104892:	d106      	bne.n	81048a2 <HAL_PWREx_EnterSTOPMode+0xd2>
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 8104894:	4b09      	ldr	r3, [pc, #36]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 8104896:	691b      	ldr	r3, [r3, #16]
 8104898:	4a08      	ldr	r2, [pc, #32]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 810489a:	f023 0304 	bic.w	r3, r3, #4
 810489e:	6113      	str	r3, [r2, #16]
 81048a0:	e009      	b.n	81048b6 <HAL_PWREx_EnterSTOPMode+0xe6>
    }
    else
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
 81048a2:	4b06      	ldr	r3, [pc, #24]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 81048a4:	695b      	ldr	r3, [r3, #20]
 81048a6:	4a05      	ldr	r2, [pc, #20]	@ (81048bc <HAL_PWREx_EnterSTOPMode+0xec>)
 81048a8:	f023 0304 	bic.w	r3, r3, #4
 81048ac:	6153      	str	r3, [r2, #20]
 81048ae:	e002      	b.n	81048b6 <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 81048b0:	bf00      	nop
 81048b2:	e000      	b.n	81048b6 <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 81048b4:	bf00      	nop
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
 81048b6:	3710      	adds	r7, #16
 81048b8:	46bd      	mov	sp, r7
 81048ba:	bd80      	pop	{r7, pc}
 81048bc:	58024800 	.word	0x58024800
 81048c0:	e000ed00 	.word	0xe000ed00

081048c4 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
 81048c4:	b580      	push	{r7, lr}
 81048c6:	af00      	add	r7, sp, #0
#if defined (DUAL_CORE)
  /* Check the current Core */
  if (HAL_GetCurrentCPUID () == CM7_CPUID)
 81048c8:	f7fd f95e 	bl	8101b88 <HAL_GetCurrentCPUID>
 81048cc:	4603      	mov	r3, r0
 81048ce:	2b03      	cmp	r3, #3
 81048d0:	d101      	bne.n	81048d6 <HAL_PWREx_ClearPendingEvent+0x12>
  {
    __WFE ();
 81048d2:	bf20      	wfe
    __WFE ();
  }
#else
  __WFE ();
#endif /* defined (DUAL_CORE) */
}
 81048d4:	e001      	b.n	81048da <HAL_PWREx_ClearPendingEvent+0x16>
    __SEV ();
 81048d6:	bf40      	sev
    __WFE ();
 81048d8:	bf20      	wfe
}
 81048da:	bf00      	nop
 81048dc:	bd80      	pop	{r7, pc}
	...

081048e0 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
 81048e0:	b480      	push	{r7}
 81048e2:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 81048e4:	4b05      	ldr	r3, [pc, #20]	@ (81048fc <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 81048e6:	68db      	ldr	r3, [r3, #12]
 81048e8:	4a04      	ldr	r2, [pc, #16]	@ (81048fc <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 81048ea:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 81048ee:	60d3      	str	r3, [r2, #12]
}
 81048f0:	bf00      	nop
 81048f2:	46bd      	mov	sp, r7
 81048f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81048f8:	4770      	bx	lr
 81048fa:	bf00      	nop
 81048fc:	58024800 	.word	0x58024800

08104900 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8104900:	b480      	push	{r7}
 8104902:	b089      	sub	sp, #36	@ 0x24
 8104904:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8104906:	4bb3      	ldr	r3, [pc, #716]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104908:	691b      	ldr	r3, [r3, #16]
 810490a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 810490e:	2b18      	cmp	r3, #24
 8104910:	f200 8155 	bhi.w	8104bbe <HAL_RCC_GetSysClockFreq+0x2be>
 8104914:	a201      	add	r2, pc, #4	@ (adr r2, 810491c <HAL_RCC_GetSysClockFreq+0x1c>)
 8104916:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810491a:	bf00      	nop
 810491c:	08104981 	.word	0x08104981
 8104920:	08104bbf 	.word	0x08104bbf
 8104924:	08104bbf 	.word	0x08104bbf
 8104928:	08104bbf 	.word	0x08104bbf
 810492c:	08104bbf 	.word	0x08104bbf
 8104930:	08104bbf 	.word	0x08104bbf
 8104934:	08104bbf 	.word	0x08104bbf
 8104938:	08104bbf 	.word	0x08104bbf
 810493c:	081049a7 	.word	0x081049a7
 8104940:	08104bbf 	.word	0x08104bbf
 8104944:	08104bbf 	.word	0x08104bbf
 8104948:	08104bbf 	.word	0x08104bbf
 810494c:	08104bbf 	.word	0x08104bbf
 8104950:	08104bbf 	.word	0x08104bbf
 8104954:	08104bbf 	.word	0x08104bbf
 8104958:	08104bbf 	.word	0x08104bbf
 810495c:	081049ad 	.word	0x081049ad
 8104960:	08104bbf 	.word	0x08104bbf
 8104964:	08104bbf 	.word	0x08104bbf
 8104968:	08104bbf 	.word	0x08104bbf
 810496c:	08104bbf 	.word	0x08104bbf
 8104970:	08104bbf 	.word	0x08104bbf
 8104974:	08104bbf 	.word	0x08104bbf
 8104978:	08104bbf 	.word	0x08104bbf
 810497c:	081049b3 	.word	0x081049b3
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8104980:	4b94      	ldr	r3, [pc, #592]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104982:	681b      	ldr	r3, [r3, #0]
 8104984:	f003 0320 	and.w	r3, r3, #32
 8104988:	2b00      	cmp	r3, #0
 810498a:	d009      	beq.n	81049a0 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810498c:	4b91      	ldr	r3, [pc, #580]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810498e:	681b      	ldr	r3, [r3, #0]
 8104990:	08db      	lsrs	r3, r3, #3
 8104992:	f003 0303 	and.w	r3, r3, #3
 8104996:	4a90      	ldr	r2, [pc, #576]	@ (8104bd8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8104998:	fa22 f303 	lsr.w	r3, r2, r3
 810499c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
 810499e:	e111      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 81049a0:	4b8d      	ldr	r3, [pc, #564]	@ (8104bd8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 81049a2:	61bb      	str	r3, [r7, #24]
      break;
 81049a4:	e10e      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
 81049a6:	4b8d      	ldr	r3, [pc, #564]	@ (8104bdc <HAL_RCC_GetSysClockFreq+0x2dc>)
 81049a8:	61bb      	str	r3, [r7, #24]
      break;
 81049aa:	e10b      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
 81049ac:	4b8c      	ldr	r3, [pc, #560]	@ (8104be0 <HAL_RCC_GetSysClockFreq+0x2e0>)
 81049ae:	61bb      	str	r3, [r7, #24]
      break;
 81049b0:	e108      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 81049b2:	4b88      	ldr	r3, [pc, #544]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81049b4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81049b6:	f003 0303 	and.w	r3, r3, #3
 81049ba:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 81049bc:	4b85      	ldr	r3, [pc, #532]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81049be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81049c0:	091b      	lsrs	r3, r3, #4
 81049c2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 81049c6:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 81049c8:	4b82      	ldr	r3, [pc, #520]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81049ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81049cc:	f003 0301 	and.w	r3, r3, #1
 81049d0:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 81049d2:	4b80      	ldr	r3, [pc, #512]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81049d4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81049d6:	08db      	lsrs	r3, r3, #3
 81049d8:	f3c3 030c 	ubfx	r3, r3, #0, #13
 81049dc:	68fa      	ldr	r2, [r7, #12]
 81049de:	fb02 f303 	mul.w	r3, r2, r3
 81049e2:	ee07 3a90 	vmov	s15, r3
 81049e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81049ea:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
 81049ee:	693b      	ldr	r3, [r7, #16]
 81049f0:	2b00      	cmp	r3, #0
 81049f2:	f000 80e1 	beq.w	8104bb8 <HAL_RCC_GetSysClockFreq+0x2b8>
      {
        switch (pllsource)
 81049f6:	697b      	ldr	r3, [r7, #20]
 81049f8:	2b02      	cmp	r3, #2
 81049fa:	f000 8083 	beq.w	8104b04 <HAL_RCC_GetSysClockFreq+0x204>
 81049fe:	697b      	ldr	r3, [r7, #20]
 8104a00:	2b02      	cmp	r3, #2
 8104a02:	f200 80a1 	bhi.w	8104b48 <HAL_RCC_GetSysClockFreq+0x248>
 8104a06:	697b      	ldr	r3, [r7, #20]
 8104a08:	2b00      	cmp	r3, #0
 8104a0a:	d003      	beq.n	8104a14 <HAL_RCC_GetSysClockFreq+0x114>
 8104a0c:	697b      	ldr	r3, [r7, #20]
 8104a0e:	2b01      	cmp	r3, #1
 8104a10:	d056      	beq.n	8104ac0 <HAL_RCC_GetSysClockFreq+0x1c0>
 8104a12:	e099      	b.n	8104b48 <HAL_RCC_GetSysClockFreq+0x248>
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8104a14:	4b6f      	ldr	r3, [pc, #444]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104a16:	681b      	ldr	r3, [r3, #0]
 8104a18:	f003 0320 	and.w	r3, r3, #32
 8104a1c:	2b00      	cmp	r3, #0
 8104a1e:	d02d      	beq.n	8104a7c <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8104a20:	4b6c      	ldr	r3, [pc, #432]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104a22:	681b      	ldr	r3, [r3, #0]
 8104a24:	08db      	lsrs	r3, r3, #3
 8104a26:	f003 0303 	and.w	r3, r3, #3
 8104a2a:	4a6b      	ldr	r2, [pc, #428]	@ (8104bd8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8104a2c:	fa22 f303 	lsr.w	r3, r2, r3
 8104a30:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8104a32:	687b      	ldr	r3, [r7, #4]
 8104a34:	ee07 3a90 	vmov	s15, r3
 8104a38:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104a3c:	693b      	ldr	r3, [r7, #16]
 8104a3e:	ee07 3a90 	vmov	s15, r3
 8104a42:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8104a46:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8104a4a:	4b62      	ldr	r3, [pc, #392]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104a4c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104a4e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8104a52:	ee07 3a90 	vmov	s15, r3
 8104a56:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104a5a:	ed97 6a02 	vldr	s12, [r7, #8]
 8104a5e:	eddf 5a61 	vldr	s11, [pc, #388]	@ 8104be4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8104a62:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8104a66:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8104a6a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8104a6e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8104a72:	ee67 7a27 	vmul.f32	s15, s14, s15
 8104a76:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
 8104a7a:	e087      	b.n	8104b8c <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8104a7c:	693b      	ldr	r3, [r7, #16]
 8104a7e:	ee07 3a90 	vmov	s15, r3
 8104a82:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8104a86:	eddf 6a58 	vldr	s13, [pc, #352]	@ 8104be8 <HAL_RCC_GetSysClockFreq+0x2e8>
 8104a8a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8104a8e:	4b51      	ldr	r3, [pc, #324]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104a90:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104a92:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8104a96:	ee07 3a90 	vmov	s15, r3
 8104a9a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104a9e:	ed97 6a02 	vldr	s12, [r7, #8]
 8104aa2:	eddf 5a50 	vldr	s11, [pc, #320]	@ 8104be4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8104aa6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8104aaa:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8104aae:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8104ab2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8104ab6:	ee67 7a27 	vmul.f32	s15, s14, s15
 8104aba:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8104abe:	e065      	b.n	8104b8c <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8104ac0:	693b      	ldr	r3, [r7, #16]
 8104ac2:	ee07 3a90 	vmov	s15, r3
 8104ac6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8104aca:	eddf 6a48 	vldr	s13, [pc, #288]	@ 8104bec <HAL_RCC_GetSysClockFreq+0x2ec>
 8104ace:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8104ad2:	4b40      	ldr	r3, [pc, #256]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104ad4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104ad6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8104ada:	ee07 3a90 	vmov	s15, r3
 8104ade:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104ae2:	ed97 6a02 	vldr	s12, [r7, #8]
 8104ae6:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 8104be4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8104aea:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8104aee:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8104af2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8104af6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8104afa:	ee67 7a27 	vmul.f32	s15, s14, s15
 8104afe:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8104b02:	e043      	b.n	8104b8c <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8104b04:	693b      	ldr	r3, [r7, #16]
 8104b06:	ee07 3a90 	vmov	s15, r3
 8104b0a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8104b0e:	eddf 6a38 	vldr	s13, [pc, #224]	@ 8104bf0 <HAL_RCC_GetSysClockFreq+0x2f0>
 8104b12:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8104b16:	4b2f      	ldr	r3, [pc, #188]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104b18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104b1a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8104b1e:	ee07 3a90 	vmov	s15, r3
 8104b22:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104b26:	ed97 6a02 	vldr	s12, [r7, #8]
 8104b2a:	eddf 5a2e 	vldr	s11, [pc, #184]	@ 8104be4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8104b2e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8104b32:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8104b36:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8104b3a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8104b3e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8104b42:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8104b46:	e021      	b.n	8104b8c <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8104b48:	693b      	ldr	r3, [r7, #16]
 8104b4a:	ee07 3a90 	vmov	s15, r3
 8104b4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8104b52:	eddf 6a26 	vldr	s13, [pc, #152]	@ 8104bec <HAL_RCC_GetSysClockFreq+0x2ec>
 8104b56:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8104b5a:	4b1e      	ldr	r3, [pc, #120]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104b5c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104b5e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8104b62:	ee07 3a90 	vmov	s15, r3
 8104b66:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8104b6a:	ed97 6a02 	vldr	s12, [r7, #8]
 8104b6e:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 8104be4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8104b72:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8104b76:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8104b7a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8104b7e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8104b82:	ee67 7a27 	vmul.f32	s15, s14, s15
 8104b86:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8104b8a:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 8104b8c:	4b11      	ldr	r3, [pc, #68]	@ (8104bd4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8104b8e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8104b90:	0a5b      	lsrs	r3, r3, #9
 8104b92:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8104b96:	3301      	adds	r3, #1
 8104b98:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 8104b9a:	683b      	ldr	r3, [r7, #0]
 8104b9c:	ee07 3a90 	vmov	s15, r3
 8104ba0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8104ba4:	edd7 6a07 	vldr	s13, [r7, #28]
 8104ba8:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8104bac:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8104bb0:	ee17 3a90 	vmov	r3, s15
 8104bb4:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
 8104bb6:	e005      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
 8104bb8:	2300      	movs	r3, #0
 8104bba:	61bb      	str	r3, [r7, #24]
      break;
 8104bbc:	e002      	b.n	8104bc4 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
 8104bbe:	4b07      	ldr	r3, [pc, #28]	@ (8104bdc <HAL_RCC_GetSysClockFreq+0x2dc>)
 8104bc0:	61bb      	str	r3, [r7, #24]
      break;
 8104bc2:	bf00      	nop
  }

  return sysclockfreq;
 8104bc4:	69bb      	ldr	r3, [r7, #24]
}
 8104bc6:	4618      	mov	r0, r3
 8104bc8:	3724      	adds	r7, #36	@ 0x24
 8104bca:	46bd      	mov	sp, r7
 8104bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104bd0:	4770      	bx	lr
 8104bd2:	bf00      	nop
 8104bd4:	58024400 	.word	0x58024400
 8104bd8:	03d09000 	.word	0x03d09000
 8104bdc:	003d0900 	.word	0x003d0900
 8104be0:	017d7840 	.word	0x017d7840
 8104be4:	46000000 	.word	0x46000000
 8104be8:	4c742400 	.word	0x4c742400
 8104bec:	4a742400 	.word	0x4a742400
 8104bf0:	4bbebc20 	.word	0x4bbebc20

08104bf4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8104bf4:	b580      	push	{r7, lr}
 8104bf6:	b082      	sub	sp, #8
 8104bf8:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8104bfa:	f7ff fe81 	bl	8104900 <HAL_RCC_GetSysClockFreq>
 8104bfe:	4602      	mov	r2, r0
 8104c00:	4b11      	ldr	r3, [pc, #68]	@ (8104c48 <HAL_RCC_GetHCLKFreq+0x54>)
 8104c02:	699b      	ldr	r3, [r3, #24]
 8104c04:	0a1b      	lsrs	r3, r3, #8
 8104c06:	f003 030f 	and.w	r3, r3, #15
 8104c0a:	4910      	ldr	r1, [pc, #64]	@ (8104c4c <HAL_RCC_GetHCLKFreq+0x58>)
 8104c0c:	5ccb      	ldrb	r3, [r1, r3]
 8104c0e:	f003 031f 	and.w	r3, r3, #31
 8104c12:	fa22 f303 	lsr.w	r3, r2, r3
 8104c16:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8104c18:	4b0b      	ldr	r3, [pc, #44]	@ (8104c48 <HAL_RCC_GetHCLKFreq+0x54>)
 8104c1a:	699b      	ldr	r3, [r3, #24]
 8104c1c:	f003 030f 	and.w	r3, r3, #15
 8104c20:	4a0a      	ldr	r2, [pc, #40]	@ (8104c4c <HAL_RCC_GetHCLKFreq+0x58>)
 8104c22:	5cd3      	ldrb	r3, [r2, r3]
 8104c24:	f003 031f 	and.w	r3, r3, #31
 8104c28:	687a      	ldr	r2, [r7, #4]
 8104c2a:	fa22 f303 	lsr.w	r3, r2, r3
 8104c2e:	4a08      	ldr	r2, [pc, #32]	@ (8104c50 <HAL_RCC_GetHCLKFreq+0x5c>)
 8104c30:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 8104c32:	4b07      	ldr	r3, [pc, #28]	@ (8104c50 <HAL_RCC_GetHCLKFreq+0x5c>)
 8104c34:	681b      	ldr	r3, [r3, #0]
 8104c36:	4a07      	ldr	r2, [pc, #28]	@ (8104c54 <HAL_RCC_GetHCLKFreq+0x60>)
 8104c38:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 8104c3a:	4b05      	ldr	r3, [pc, #20]	@ (8104c50 <HAL_RCC_GetHCLKFreq+0x5c>)
 8104c3c:	681b      	ldr	r3, [r3, #0]
}
 8104c3e:	4618      	mov	r0, r3
 8104c40:	3708      	adds	r7, #8
 8104c42:	46bd      	mov	sp, r7
 8104c44:	bd80      	pop	{r7, pc}
 8104c46:	bf00      	nop
 8104c48:	58024400 	.word	0x58024400
 8104c4c:	0810d9fc 	.word	0x0810d9fc
 8104c50:	1003202c 	.word	0x1003202c
 8104c54:	10032028 	.word	0x10032028

08104c58 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8104c58:	b580      	push	{r7, lr}
 8104c5a:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8104c5c:	f7ff ffca 	bl	8104bf4 <HAL_RCC_GetHCLKFreq>
 8104c60:	4602      	mov	r2, r0
 8104c62:	4b06      	ldr	r3, [pc, #24]	@ (8104c7c <HAL_RCC_GetPCLK1Freq+0x24>)
 8104c64:	69db      	ldr	r3, [r3, #28]
 8104c66:	091b      	lsrs	r3, r3, #4
 8104c68:	f003 0307 	and.w	r3, r3, #7
 8104c6c:	4904      	ldr	r1, [pc, #16]	@ (8104c80 <HAL_RCC_GetPCLK1Freq+0x28>)
 8104c6e:	5ccb      	ldrb	r3, [r1, r3]
 8104c70:	f003 031f 	and.w	r3, r3, #31
 8104c74:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8104c78:	4618      	mov	r0, r3
 8104c7a:	bd80      	pop	{r7, pc}
 8104c7c:	58024400 	.word	0x58024400
 8104c80:	0810d9fc 	.word	0x0810d9fc

08104c84 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8104c84:	b480      	push	{r7}
 8104c86:	b083      	sub	sp, #12
 8104c88:	af00      	add	r7, sp, #0
 8104c8a:	6078      	str	r0, [r7, #4]
 8104c8c:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 8104c8e:	687b      	ldr	r3, [r7, #4]
 8104c90:	223f      	movs	r2, #63	@ 0x3f
 8104c92:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8104c94:	4b1a      	ldr	r3, [pc, #104]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104c96:	691b      	ldr	r3, [r3, #16]
 8104c98:	f003 0207 	and.w	r2, r3, #7
 8104c9c:	687b      	ldr	r3, [r7, #4]
 8104c9e:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 8104ca0:	4b17      	ldr	r3, [pc, #92]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104ca2:	699b      	ldr	r3, [r3, #24]
 8104ca4:	f403 6270 	and.w	r2, r3, #3840	@ 0xf00
 8104ca8:	687b      	ldr	r3, [r7, #4]
 8104caa:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 8104cac:	4b14      	ldr	r3, [pc, #80]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104cae:	699b      	ldr	r3, [r3, #24]
 8104cb0:	f003 020f 	and.w	r2, r3, #15
 8104cb4:	687b      	ldr	r3, [r7, #4]
 8104cb6:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 8104cb8:	4b11      	ldr	r3, [pc, #68]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104cba:	699b      	ldr	r3, [r3, #24]
 8104cbc:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8104cc0:	687b      	ldr	r3, [r7, #4]
 8104cc2:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 8104cc4:	4b0e      	ldr	r3, [pc, #56]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104cc6:	69db      	ldr	r3, [r3, #28]
 8104cc8:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8104ccc:	687b      	ldr	r3, [r7, #4]
 8104cce:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8104cd0:	4b0b      	ldr	r3, [pc, #44]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104cd2:	69db      	ldr	r3, [r3, #28]
 8104cd4:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
 8104cd8:	687b      	ldr	r3, [r7, #4]
 8104cda:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 8104cdc:	4b08      	ldr	r3, [pc, #32]	@ (8104d00 <HAL_RCC_GetClockConfig+0x7c>)
 8104cde:	6a1b      	ldr	r3, [r3, #32]
 8104ce0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8104ce4:	687b      	ldr	r3, [r7, #4]
 8104ce6:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8104ce8:	4b06      	ldr	r3, [pc, #24]	@ (8104d04 <HAL_RCC_GetClockConfig+0x80>)
 8104cea:	681b      	ldr	r3, [r3, #0]
 8104cec:	f003 020f 	and.w	r2, r3, #15
 8104cf0:	683b      	ldr	r3, [r7, #0]
 8104cf2:	601a      	str	r2, [r3, #0]
}
 8104cf4:	bf00      	nop
 8104cf6:	370c      	adds	r7, #12
 8104cf8:	46bd      	mov	sp, r7
 8104cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104cfe:	4770      	bx	lr
 8104d00:	58024400 	.word	0x58024400
 8104d04:	52002000 	.word	0x52002000

08104d08 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8104d08:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8104d0c:	b0ca      	sub	sp, #296	@ 0x128
 8104d0e:	af00      	add	r7, sp, #0
 8104d10:	f8c7 0114 	str.w	r0, [r7, #276]	@ 0x114
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8104d14:	2300      	movs	r3, #0
 8104d16:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8104d1a:	2300      	movs	r3, #0
 8104d1c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8104d20:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104d24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8104d28:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
 8104d2c:	2500      	movs	r5, #0
 8104d2e:	ea54 0305 	orrs.w	r3, r4, r5
 8104d32:	d049      	beq.n	8104dc8 <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
 8104d34:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104d38:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8104d3a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8104d3e:	d02f      	beq.n	8104da0 <HAL_RCCEx_PeriphCLKConfig+0x98>
 8104d40:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8104d44:	d828      	bhi.n	8104d98 <HAL_RCCEx_PeriphCLKConfig+0x90>
 8104d46:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8104d4a:	d01a      	beq.n	8104d82 <HAL_RCCEx_PeriphCLKConfig+0x7a>
 8104d4c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8104d50:	d822      	bhi.n	8104d98 <HAL_RCCEx_PeriphCLKConfig+0x90>
 8104d52:	2b00      	cmp	r3, #0
 8104d54:	d003      	beq.n	8104d5e <HAL_RCCEx_PeriphCLKConfig+0x56>
 8104d56:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8104d5a:	d007      	beq.n	8104d6c <HAL_RCCEx_PeriphCLKConfig+0x64>
 8104d5c:	e01c      	b.n	8104d98 <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8104d5e:	4bb8      	ldr	r3, [pc, #736]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104d60:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8104d62:	4ab7      	ldr	r2, [pc, #732]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104d64:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8104d68:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8104d6a:	e01a      	b.n	8104da2 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8104d6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104d70:	3308      	adds	r3, #8
 8104d72:	2102      	movs	r1, #2
 8104d74:	4618      	mov	r0, r3
 8104d76:	f002 fb61 	bl	810743c <RCCEx_PLL2_Config>
 8104d7a:	4603      	mov	r3, r0
 8104d7c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8104d80:	e00f      	b.n	8104da2 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8104d82:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104d86:	3328      	adds	r3, #40	@ 0x28
 8104d88:	2102      	movs	r1, #2
 8104d8a:	4618      	mov	r0, r3
 8104d8c:	f002 fc08 	bl	81075a0 <RCCEx_PLL3_Config>
 8104d90:	4603      	mov	r3, r0
 8104d92:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8104d96:	e004      	b.n	8104da2 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8104d98:	2301      	movs	r3, #1
 8104d9a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8104d9e:	e000      	b.n	8104da2 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
 8104da0:	bf00      	nop
    }

    if (ret == HAL_OK)
 8104da2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104da6:	2b00      	cmp	r3, #0
 8104da8:	d10a      	bne.n	8104dc0 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 8104daa:	4ba5      	ldr	r3, [pc, #660]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104dac:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8104dae:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 8104db2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104db6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8104db8:	4aa1      	ldr	r2, [pc, #644]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104dba:	430b      	orrs	r3, r1
 8104dbc:	6513      	str	r3, [r2, #80]	@ 0x50
 8104dbe:	e003      	b.n	8104dc8 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8104dc0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104dc4:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8104dc8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104dcc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8104dd0:	f402 7880 	and.w	r8, r2, #256	@ 0x100
 8104dd4:	f04f 0900 	mov.w	r9, #0
 8104dd8:	ea58 0309 	orrs.w	r3, r8, r9
 8104ddc:	d047      	beq.n	8104e6e <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
 8104dde:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104de2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8104de4:	2b04      	cmp	r3, #4
 8104de6:	d82a      	bhi.n	8104e3e <HAL_RCCEx_PeriphCLKConfig+0x136>
 8104de8:	a201      	add	r2, pc, #4	@ (adr r2, 8104df0 <HAL_RCCEx_PeriphCLKConfig+0xe8>)
 8104dea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8104dee:	bf00      	nop
 8104df0:	08104e05 	.word	0x08104e05
 8104df4:	08104e13 	.word	0x08104e13
 8104df8:	08104e29 	.word	0x08104e29
 8104dfc:	08104e47 	.word	0x08104e47
 8104e00:	08104e47 	.word	0x08104e47
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8104e04:	4b8e      	ldr	r3, [pc, #568]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104e06:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8104e08:	4a8d      	ldr	r2, [pc, #564]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104e0a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8104e0e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8104e10:	e01a      	b.n	8104e48 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8104e12:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104e16:	3308      	adds	r3, #8
 8104e18:	2100      	movs	r1, #0
 8104e1a:	4618      	mov	r0, r3
 8104e1c:	f002 fb0e 	bl	810743c <RCCEx_PLL2_Config>
 8104e20:	4603      	mov	r3, r0
 8104e22:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8104e26:	e00f      	b.n	8104e48 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8104e28:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104e2c:	3328      	adds	r3, #40	@ 0x28
 8104e2e:	2100      	movs	r1, #0
 8104e30:	4618      	mov	r0, r3
 8104e32:	f002 fbb5 	bl	81075a0 <RCCEx_PLL3_Config>
 8104e36:	4603      	mov	r3, r0
 8104e38:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8104e3c:	e004      	b.n	8104e48 <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8104e3e:	2301      	movs	r3, #1
 8104e40:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8104e44:	e000      	b.n	8104e48 <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
 8104e46:	bf00      	nop
    }

    if (ret == HAL_OK)
 8104e48:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104e4c:	2b00      	cmp	r3, #0
 8104e4e:	d10a      	bne.n	8104e66 <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8104e50:	4b7b      	ldr	r3, [pc, #492]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104e52:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8104e54:	f023 0107 	bic.w	r1, r3, #7
 8104e58:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104e5c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8104e5e:	4a78      	ldr	r2, [pc, #480]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104e60:	430b      	orrs	r3, r1
 8104e62:	6513      	str	r3, [r2, #80]	@ 0x50
 8104e64:	e003      	b.n	8104e6e <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8104e66:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104e6a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 8104e6e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104e72:	e9d3 2300 	ldrd	r2, r3, [r3]
 8104e76:	f402 7a00 	and.w	sl, r2, #512	@ 0x200
 8104e7a:	f04f 0b00 	mov.w	fp, #0
 8104e7e:	ea5a 030b 	orrs.w	r3, sl, fp
 8104e82:	d04c      	beq.n	8104f1e <HAL_RCCEx_PeriphCLKConfig+0x216>
  {
    switch (PeriphClkInit->Sai23ClockSelection)
 8104e84:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104e88:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8104e8a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8104e8e:	d030      	beq.n	8104ef2 <HAL_RCCEx_PeriphCLKConfig+0x1ea>
 8104e90:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8104e94:	d829      	bhi.n	8104eea <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8104e96:	2bc0      	cmp	r3, #192	@ 0xc0
 8104e98:	d02d      	beq.n	8104ef6 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 8104e9a:	2bc0      	cmp	r3, #192	@ 0xc0
 8104e9c:	d825      	bhi.n	8104eea <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8104e9e:	2b80      	cmp	r3, #128	@ 0x80
 8104ea0:	d018      	beq.n	8104ed4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
 8104ea2:	2b80      	cmp	r3, #128	@ 0x80
 8104ea4:	d821      	bhi.n	8104eea <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8104ea6:	2b00      	cmp	r3, #0
 8104ea8:	d002      	beq.n	8104eb0 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
 8104eaa:	2b40      	cmp	r3, #64	@ 0x40
 8104eac:	d007      	beq.n	8104ebe <HAL_RCCEx_PeriphCLKConfig+0x1b6>
 8104eae:	e01c      	b.n	8104eea <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    {
      case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8104eb0:	4b63      	ldr	r3, [pc, #396]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104eb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8104eb4:	4a62      	ldr	r2, [pc, #392]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104eb6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8104eba:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8104ebc:	e01c      	b.n	8104ef8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8104ebe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104ec2:	3308      	adds	r3, #8
 8104ec4:	2100      	movs	r1, #0
 8104ec6:	4618      	mov	r0, r3
 8104ec8:	f002 fab8 	bl	810743c <RCCEx_PLL2_Config>
 8104ecc:	4603      	mov	r3, r0
 8104ece:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8104ed2:	e011      	b.n	8104ef8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8104ed4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104ed8:	3328      	adds	r3, #40	@ 0x28
 8104eda:	2100      	movs	r1, #0
 8104edc:	4618      	mov	r0, r3
 8104ede:	f002 fb5f 	bl	81075a0 <RCCEx_PLL3_Config>
 8104ee2:	4603      	mov	r3, r0
 8104ee4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8104ee8:	e006      	b.n	8104ef8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
        /* SAI2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8104eea:	2301      	movs	r3, #1
 8104eec:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8104ef0:	e002      	b.n	8104ef8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 8104ef2:	bf00      	nop
 8104ef4:	e000      	b.n	8104ef8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 8104ef6:	bf00      	nop
    }

    if (ret == HAL_OK)
 8104ef8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104efc:	2b00      	cmp	r3, #0
 8104efe:	d10a      	bne.n	8104f16 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 8104f00:	4b4f      	ldr	r3, [pc, #316]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104f02:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8104f04:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 8104f08:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104f0c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8104f0e:	4a4c      	ldr	r2, [pc, #304]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104f10:	430b      	orrs	r3, r1
 8104f12:	6513      	str	r3, [r2, #80]	@ 0x50
 8104f14:	e003      	b.n	8104f1e <HAL_RCCEx_PeriphCLKConfig+0x216>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8104f16:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104f1a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 8104f1e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104f22:	e9d3 2300 	ldrd	r2, r3, [r3]
 8104f26:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 8104f2a:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8104f2e:	2300      	movs	r3, #0
 8104f30:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 8104f34:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	@ 0x108
 8104f38:	460b      	mov	r3, r1
 8104f3a:	4313      	orrs	r3, r2
 8104f3c:	d053      	beq.n	8104fe6 <HAL_RCCEx_PeriphCLKConfig+0x2de>
  {
    switch (PeriphClkInit->Sai4AClockSelection)
 8104f3e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104f42:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8104f46:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8104f4a:	d035      	beq.n	8104fb8 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 8104f4c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8104f50:	d82e      	bhi.n	8104fb0 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8104f52:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8104f56:	d031      	beq.n	8104fbc <HAL_RCCEx_PeriphCLKConfig+0x2b4>
 8104f58:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8104f5c:	d828      	bhi.n	8104fb0 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8104f5e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8104f62:	d01a      	beq.n	8104f9a <HAL_RCCEx_PeriphCLKConfig+0x292>
 8104f64:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8104f68:	d822      	bhi.n	8104fb0 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8104f6a:	2b00      	cmp	r3, #0
 8104f6c:	d003      	beq.n	8104f76 <HAL_RCCEx_PeriphCLKConfig+0x26e>
 8104f6e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8104f72:	d007      	beq.n	8104f84 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 8104f74:	e01c      	b.n	8104fb0 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    {
      case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8104f76:	4b32      	ldr	r3, [pc, #200]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104f78:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8104f7a:	4a31      	ldr	r2, [pc, #196]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104f7c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8104f80:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8104f82:	e01c      	b.n	8104fbe <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8104f84:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104f88:	3308      	adds	r3, #8
 8104f8a:	2100      	movs	r1, #0
 8104f8c:	4618      	mov	r0, r3
 8104f8e:	f002 fa55 	bl	810743c <RCCEx_PLL2_Config>
 8104f92:	4603      	mov	r3, r0
 8104f94:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 8104f98:	e011      	b.n	8104fbe <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8104f9a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104f9e:	3328      	adds	r3, #40	@ 0x28
 8104fa0:	2100      	movs	r1, #0
 8104fa2:	4618      	mov	r0, r3
 8104fa4:	f002 fafc 	bl	81075a0 <RCCEx_PLL3_Config>
 8104fa8:	4603      	mov	r3, r0
 8104faa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8104fae:	e006      	b.n	8104fbe <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        /* SAI4A clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 8104fb0:	2301      	movs	r3, #1
 8104fb2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8104fb6:	e002      	b.n	8104fbe <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 8104fb8:	bf00      	nop
 8104fba:	e000      	b.n	8104fbe <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 8104fbc:	bf00      	nop
    }

    if (ret == HAL_OK)
 8104fbe:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104fc2:	2b00      	cmp	r3, #0
 8104fc4:	d10b      	bne.n	8104fde <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 8104fc6:	4b1e      	ldr	r3, [pc, #120]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104fc8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8104fca:	f423 0160 	bic.w	r1, r3, #14680064	@ 0xe00000
 8104fce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104fd2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8104fd6:	4a1a      	ldr	r2, [pc, #104]	@ (8105040 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8104fd8:	430b      	orrs	r3, r1
 8104fda:	6593      	str	r3, [r2, #88]	@ 0x58
 8104fdc:	e003      	b.n	8104fe6 <HAL_RCCEx_PeriphCLKConfig+0x2de>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8104fde:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8104fe2:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 8104fe6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8104fea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8104fee:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 8104ff2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 8104ff6:	2300      	movs	r3, #0
 8104ff8:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8104ffc:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	@ 0x100
 8105000:	460b      	mov	r3, r1
 8105002:	4313      	orrs	r3, r2
 8105004:	d056      	beq.n	81050b4 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
  {
    switch (PeriphClkInit->Sai4BClockSelection)
 8105006:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810500a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 810500e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8105012:	d038      	beq.n	8105086 <HAL_RCCEx_PeriphCLKConfig+0x37e>
 8105014:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8105018:	d831      	bhi.n	810507e <HAL_RCCEx_PeriphCLKConfig+0x376>
 810501a:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 810501e:	d034      	beq.n	810508a <HAL_RCCEx_PeriphCLKConfig+0x382>
 8105020:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8105024:	d82b      	bhi.n	810507e <HAL_RCCEx_PeriphCLKConfig+0x376>
 8105026:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 810502a:	d01d      	beq.n	8105068 <HAL_RCCEx_PeriphCLKConfig+0x360>
 810502c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8105030:	d825      	bhi.n	810507e <HAL_RCCEx_PeriphCLKConfig+0x376>
 8105032:	2b00      	cmp	r3, #0
 8105034:	d006      	beq.n	8105044 <HAL_RCCEx_PeriphCLKConfig+0x33c>
 8105036:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 810503a:	d00a      	beq.n	8105052 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 810503c:	e01f      	b.n	810507e <HAL_RCCEx_PeriphCLKConfig+0x376>
 810503e:	bf00      	nop
 8105040:	58024400 	.word	0x58024400
    {
      case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8105044:	4ba2      	ldr	r3, [pc, #648]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8105046:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8105048:	4aa1      	ldr	r2, [pc, #644]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810504a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 810504e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8105050:	e01c      	b.n	810508c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8105052:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105056:	3308      	adds	r3, #8
 8105058:	2100      	movs	r1, #0
 810505a:	4618      	mov	r0, r3
 810505c:	f002 f9ee 	bl	810743c <RCCEx_PLL2_Config>
 8105060:	4603      	mov	r3, r0
 8105062:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 8105066:	e011      	b.n	810508c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8105068:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810506c:	3328      	adds	r3, #40	@ 0x28
 810506e:	2100      	movs	r1, #0
 8105070:	4618      	mov	r0, r3
 8105072:	f002 fa95 	bl	81075a0 <RCCEx_PLL3_Config>
 8105076:	4603      	mov	r3, r0
 8105078:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 810507c:	e006      	b.n	810508c <HAL_RCCEx_PeriphCLKConfig+0x384>
        /* SAI4B clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 810507e:	2301      	movs	r3, #1
 8105080:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105084:	e002      	b.n	810508c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 8105086:	bf00      	nop
 8105088:	e000      	b.n	810508c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 810508a:	bf00      	nop
    }

    if (ret == HAL_OK)
 810508c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105090:	2b00      	cmp	r3, #0
 8105092:	d10b      	bne.n	81050ac <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8105094:	4b8e      	ldr	r3, [pc, #568]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8105096:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105098:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 810509c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81050a0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 81050a4:	4a8a      	ldr	r2, [pc, #552]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81050a6:	430b      	orrs	r3, r1
 81050a8:	6593      	str	r3, [r2, #88]	@ 0x58
 81050aa:	e003      	b.n	81050b4 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81050ac:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81050b0:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 81050b4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81050b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 81050bc:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 81050c0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 81050c4:	2300      	movs	r3, #0
 81050c6:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 81050ca:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	@ 0xf8
 81050ce:	460b      	mov	r3, r1
 81050d0:	4313      	orrs	r3, r2
 81050d2:	d03a      	beq.n	810514a <HAL_RCCEx_PeriphCLKConfig+0x442>
  {
    switch (PeriphClkInit->QspiClockSelection)
 81050d4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81050d8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81050da:	2b30      	cmp	r3, #48	@ 0x30
 81050dc:	d01f      	beq.n	810511e <HAL_RCCEx_PeriphCLKConfig+0x416>
 81050de:	2b30      	cmp	r3, #48	@ 0x30
 81050e0:	d819      	bhi.n	8105116 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 81050e2:	2b20      	cmp	r3, #32
 81050e4:	d00c      	beq.n	8105100 <HAL_RCCEx_PeriphCLKConfig+0x3f8>
 81050e6:	2b20      	cmp	r3, #32
 81050e8:	d815      	bhi.n	8105116 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 81050ea:	2b00      	cmp	r3, #0
 81050ec:	d019      	beq.n	8105122 <HAL_RCCEx_PeriphCLKConfig+0x41a>
 81050ee:	2b10      	cmp	r3, #16
 81050f0:	d111      	bne.n	8105116 <HAL_RCCEx_PeriphCLKConfig+0x40e>
    {
      case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
        /* Enable QSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81050f2:	4b77      	ldr	r3, [pc, #476]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81050f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81050f6:	4a76      	ldr	r2, [pc, #472]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81050f8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81050fc:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* QSPI clock source configuration done later after clock selection check */
        break;
 81050fe:	e011      	b.n	8105124 <HAL_RCCEx_PeriphCLKConfig+0x41c>

      case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8105100:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105104:	3308      	adds	r3, #8
 8105106:	2102      	movs	r1, #2
 8105108:	4618      	mov	r0, r3
 810510a:	f002 f997 	bl	810743c <RCCEx_PLL2_Config>
 810510e:	4603      	mov	r3, r0
 8105110:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* QSPI clock source configuration done later after clock selection check */
        break;
 8105114:	e006      	b.n	8105124 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      case RCC_QSPICLKSOURCE_D1HCLK:
        /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 8105116:	2301      	movs	r3, #1
 8105118:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810511c:	e002      	b.n	8105124 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 810511e:	bf00      	nop
 8105120:	e000      	b.n	8105124 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 8105122:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105124:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105128:	2b00      	cmp	r3, #0
 810512a:	d10a      	bne.n	8105142 <HAL_RCCEx_PeriphCLKConfig+0x43a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 810512c:	4b68      	ldr	r3, [pc, #416]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810512e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8105130:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 8105134:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105138:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810513a:	4a65      	ldr	r2, [pc, #404]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810513c:	430b      	orrs	r3, r1
 810513e:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8105140:	e003      	b.n	810514a <HAL_RCCEx_PeriphCLKConfig+0x442>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105142:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105146:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 810514a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810514e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105152:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 8105156:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 810515a:	2300      	movs	r3, #0
 810515c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8105160:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 8105164:	460b      	mov	r3, r1
 8105166:	4313      	orrs	r3, r2
 8105168:	d051      	beq.n	810520e <HAL_RCCEx_PeriphCLKConfig+0x506>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
 810516a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810516e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8105170:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8105174:	d035      	beq.n	81051e2 <HAL_RCCEx_PeriphCLKConfig+0x4da>
 8105176:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 810517a:	d82e      	bhi.n	81051da <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 810517c:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8105180:	d031      	beq.n	81051e6 <HAL_RCCEx_PeriphCLKConfig+0x4de>
 8105182:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8105186:	d828      	bhi.n	81051da <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8105188:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 810518c:	d01a      	beq.n	81051c4 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
 810518e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8105192:	d822      	bhi.n	81051da <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8105194:	2b00      	cmp	r3, #0
 8105196:	d003      	beq.n	81051a0 <HAL_RCCEx_PeriphCLKConfig+0x498>
 8105198:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810519c:	d007      	beq.n	81051ae <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 810519e:	e01c      	b.n	81051da <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81051a0:	4b4b      	ldr	r3, [pc, #300]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81051a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81051a4:	4a4a      	ldr	r2, [pc, #296]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81051a6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81051aa:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 81051ac:	e01c      	b.n	81051e8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81051ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81051b2:	3308      	adds	r3, #8
 81051b4:	2100      	movs	r1, #0
 81051b6:	4618      	mov	r0, r3
 81051b8:	f002 f940 	bl	810743c <RCCEx_PLL2_Config>
 81051bc:	4603      	mov	r3, r0
 81051be:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 81051c2:	e011      	b.n	81051e8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 81051c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81051c8:	3328      	adds	r3, #40	@ 0x28
 81051ca:	2100      	movs	r1, #0
 81051cc:	4618      	mov	r0, r3
 81051ce:	f002 f9e7 	bl	81075a0 <RCCEx_PLL3_Config>
 81051d2:	4603      	mov	r3, r0
 81051d4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 81051d8:	e006      	b.n	81051e8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81051da:	2301      	movs	r3, #1
 81051dc:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81051e0:	e002      	b.n	81051e8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 81051e2:	bf00      	nop
 81051e4:	e000      	b.n	81051e8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 81051e6:	bf00      	nop
    }

    if (ret == HAL_OK)
 81051e8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81051ec:	2b00      	cmp	r3, #0
 81051ee:	d10a      	bne.n	8105206 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 81051f0:	4b37      	ldr	r3, [pc, #220]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81051f2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81051f4:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 81051f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81051fc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81051fe:	4a34      	ldr	r2, [pc, #208]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8105200:	430b      	orrs	r3, r1
 8105202:	6513      	str	r3, [r2, #80]	@ 0x50
 8105204:	e003      	b.n	810520e <HAL_RCCEx_PeriphCLKConfig+0x506>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105206:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810520a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 810520e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105212:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105216:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 810521a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 810521e:	2300      	movs	r3, #0
 8105220:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 8105224:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 8105228:	460b      	mov	r3, r1
 810522a:	4313      	orrs	r3, r2
 810522c:	d056      	beq.n	81052dc <HAL_RCCEx_PeriphCLKConfig+0x5d4>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
 810522e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105232:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8105234:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8105238:	d033      	beq.n	81052a2 <HAL_RCCEx_PeriphCLKConfig+0x59a>
 810523a:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 810523e:	d82c      	bhi.n	810529a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8105240:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8105244:	d02f      	beq.n	81052a6 <HAL_RCCEx_PeriphCLKConfig+0x59e>
 8105246:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 810524a:	d826      	bhi.n	810529a <HAL_RCCEx_PeriphCLKConfig+0x592>
 810524c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8105250:	d02b      	beq.n	81052aa <HAL_RCCEx_PeriphCLKConfig+0x5a2>
 8105252:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8105256:	d820      	bhi.n	810529a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8105258:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 810525c:	d012      	beq.n	8105284 <HAL_RCCEx_PeriphCLKConfig+0x57c>
 810525e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8105262:	d81a      	bhi.n	810529a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8105264:	2b00      	cmp	r3, #0
 8105266:	d022      	beq.n	81052ae <HAL_RCCEx_PeriphCLKConfig+0x5a6>
 8105268:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 810526c:	d115      	bne.n	810529a <HAL_RCCEx_PeriphCLKConfig+0x592>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 810526e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105272:	3308      	adds	r3, #8
 8105274:	2101      	movs	r1, #1
 8105276:	4618      	mov	r0, r3
 8105278:	f002 f8e0 	bl	810743c <RCCEx_PLL2_Config>
 810527c:	4603      	mov	r3, r0
 810527e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 8105282:	e015      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8105284:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105288:	3328      	adds	r3, #40	@ 0x28
 810528a:	2101      	movs	r1, #1
 810528c:	4618      	mov	r0, r3
 810528e:	f002 f987 	bl	81075a0 <RCCEx_PLL3_Config>
 8105292:	4603      	mov	r3, r0
 8105294:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 8105298:	e00a      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810529a:	2301      	movs	r3, #1
 810529c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81052a0:	e006      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 81052a2:	bf00      	nop
 81052a4:	e004      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 81052a6:	bf00      	nop
 81052a8:	e002      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 81052aa:	bf00      	nop
 81052ac:	e000      	b.n	81052b0 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 81052ae:	bf00      	nop
    }

    if (ret == HAL_OK)
 81052b0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81052b4:	2b00      	cmp	r3, #0
 81052b6:	d10d      	bne.n	81052d4 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 81052b8:	4b05      	ldr	r3, [pc, #20]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81052ba:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81052bc:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 81052c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81052c4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81052c6:	4a02      	ldr	r2, [pc, #8]	@ (81052d0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81052c8:	430b      	orrs	r3, r1
 81052ca:	6513      	str	r3, [r2, #80]	@ 0x50
 81052cc:	e006      	b.n	81052dc <HAL_RCCEx_PeriphCLKConfig+0x5d4>
 81052ce:	bf00      	nop
 81052d0:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 81052d4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81052d8:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 81052dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81052e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81052e4:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 81052e8:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 81052ec:	2300      	movs	r3, #0
 81052ee:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 81052f2:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	@ 0xe0
 81052f6:	460b      	mov	r3, r1
 81052f8:	4313      	orrs	r3, r2
 81052fa:	d055      	beq.n	81053a8 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
 81052fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105300:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8105304:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8105308:	d033      	beq.n	8105372 <HAL_RCCEx_PeriphCLKConfig+0x66a>
 810530a:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 810530e:	d82c      	bhi.n	810536a <HAL_RCCEx_PeriphCLKConfig+0x662>
 8105310:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8105314:	d02f      	beq.n	8105376 <HAL_RCCEx_PeriphCLKConfig+0x66e>
 8105316:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 810531a:	d826      	bhi.n	810536a <HAL_RCCEx_PeriphCLKConfig+0x662>
 810531c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8105320:	d02b      	beq.n	810537a <HAL_RCCEx_PeriphCLKConfig+0x672>
 8105322:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8105326:	d820      	bhi.n	810536a <HAL_RCCEx_PeriphCLKConfig+0x662>
 8105328:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 810532c:	d012      	beq.n	8105354 <HAL_RCCEx_PeriphCLKConfig+0x64c>
 810532e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8105332:	d81a      	bhi.n	810536a <HAL_RCCEx_PeriphCLKConfig+0x662>
 8105334:	2b00      	cmp	r3, #0
 8105336:	d022      	beq.n	810537e <HAL_RCCEx_PeriphCLKConfig+0x676>
 8105338:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810533c:	d115      	bne.n	810536a <HAL_RCCEx_PeriphCLKConfig+0x662>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 810533e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105342:	3308      	adds	r3, #8
 8105344:	2101      	movs	r1, #1
 8105346:	4618      	mov	r0, r3
 8105348:	f002 f878 	bl	810743c <RCCEx_PLL2_Config>
 810534c:	4603      	mov	r3, r0
 810534e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8105352:	e015      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8105354:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105358:	3328      	adds	r3, #40	@ 0x28
 810535a:	2101      	movs	r1, #1
 810535c:	4618      	mov	r0, r3
 810535e:	f002 f91f 	bl	81075a0 <RCCEx_PLL3_Config>
 8105362:	4603      	mov	r3, r0
 8105364:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8105368:	e00a      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
 810536a:	2301      	movs	r3, #1
 810536c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105370:	e006      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8105372:	bf00      	nop
 8105374:	e004      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8105376:	bf00      	nop
 8105378:	e002      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 810537a:	bf00      	nop
 810537c:	e000      	b.n	8105380 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 810537e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105380:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105384:	2b00      	cmp	r3, #0
 8105386:	d10b      	bne.n	81053a0 <HAL_RCCEx_PeriphCLKConfig+0x698>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 8105388:	4ba4      	ldr	r3, [pc, #656]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810538a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 810538c:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 8105390:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105394:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8105398:	4aa0      	ldr	r2, [pc, #640]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810539a:	430b      	orrs	r3, r1
 810539c:	6593      	str	r3, [r2, #88]	@ 0x58
 810539e:	e003      	b.n	81053a8 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81053a0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81053a4:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 81053a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81053ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 81053b0:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 81053b4:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 81053b8:	2300      	movs	r3, #0
 81053ba:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 81053be:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 81053c2:	460b      	mov	r3, r1
 81053c4:	4313      	orrs	r3, r2
 81053c6:	d037      	beq.n	8105438 <HAL_RCCEx_PeriphCLKConfig+0x730>
  {
    switch (PeriphClkInit->FdcanClockSelection)
 81053c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81053cc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 81053ce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81053d2:	d00e      	beq.n	81053f2 <HAL_RCCEx_PeriphCLKConfig+0x6ea>
 81053d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81053d8:	d816      	bhi.n	8105408 <HAL_RCCEx_PeriphCLKConfig+0x700>
 81053da:	2b00      	cmp	r3, #0
 81053dc:	d018      	beq.n	8105410 <HAL_RCCEx_PeriphCLKConfig+0x708>
 81053de:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 81053e2:	d111      	bne.n	8105408 <HAL_RCCEx_PeriphCLKConfig+0x700>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81053e4:	4b8d      	ldr	r3, [pc, #564]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81053e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81053e8:	4a8c      	ldr	r2, [pc, #560]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81053ea:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81053ee:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 81053f0:	e00f      	b.n	8105412 <HAL_RCCEx_PeriphCLKConfig+0x70a>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 81053f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81053f6:	3308      	adds	r3, #8
 81053f8:	2101      	movs	r1, #1
 81053fa:	4618      	mov	r0, r3
 81053fc:	f002 f81e 	bl	810743c <RCCEx_PLL2_Config>
 8105400:	4603      	mov	r3, r0
 8105402:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 8105406:	e004      	b.n	8105412 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105408:	2301      	movs	r3, #1
 810540a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810540e:	e000      	b.n	8105412 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        break;
 8105410:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105412:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105416:	2b00      	cmp	r3, #0
 8105418:	d10a      	bne.n	8105430 <HAL_RCCEx_PeriphCLKConfig+0x728>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 810541a:	4b80      	ldr	r3, [pc, #512]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810541c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810541e:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8105422:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105426:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8105428:	4a7c      	ldr	r2, [pc, #496]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810542a:	430b      	orrs	r3, r1
 810542c:	6513      	str	r3, [r2, #80]	@ 0x50
 810542e:	e003      	b.n	8105438 <HAL_RCCEx_PeriphCLKConfig+0x730>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105430:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105434:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 8105438:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810543c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105440:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 8105444:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8105448:	2300      	movs	r3, #0
 810544a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 810544e:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 8105452:	460b      	mov	r3, r1
 8105454:	4313      	orrs	r3, r2
 8105456:	d039      	beq.n	81054cc <HAL_RCCEx_PeriphCLKConfig+0x7c4>
  {
    switch (PeriphClkInit->FmcClockSelection)
 8105458:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810545c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 810545e:	2b03      	cmp	r3, #3
 8105460:	d81c      	bhi.n	810549c <HAL_RCCEx_PeriphCLKConfig+0x794>
 8105462:	a201      	add	r2, pc, #4	@ (adr r2, 8105468 <HAL_RCCEx_PeriphCLKConfig+0x760>)
 8105464:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8105468:	081054a5 	.word	0x081054a5
 810546c:	08105479 	.word	0x08105479
 8105470:	08105487 	.word	0x08105487
 8105474:	081054a5 	.word	0x081054a5
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8105478:	4b68      	ldr	r3, [pc, #416]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810547a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810547c:	4a67      	ldr	r2, [pc, #412]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810547e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8105482:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
 8105484:	e00f      	b.n	81054a6 <HAL_RCCEx_PeriphCLKConfig+0x79e>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8105486:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810548a:	3308      	adds	r3, #8
 810548c:	2102      	movs	r1, #2
 810548e:	4618      	mov	r0, r3
 8105490:	f001 ffd4 	bl	810743c <RCCEx_PLL2_Config>
 8105494:	4603      	mov	r3, r0
 8105496:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FMC clock source configuration done later after clock selection check */
        break;
 810549a:	e004      	b.n	81054a6 <HAL_RCCEx_PeriphCLKConfig+0x79e>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 810549c:	2301      	movs	r3, #1
 810549e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81054a2:	e000      	b.n	81054a6 <HAL_RCCEx_PeriphCLKConfig+0x79e>
        break;
 81054a4:	bf00      	nop
    }

    if (ret == HAL_OK)
 81054a6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81054aa:	2b00      	cmp	r3, #0
 81054ac:	d10a      	bne.n	81054c4 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 81054ae:	4b5b      	ldr	r3, [pc, #364]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81054b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81054b2:	f023 0103 	bic.w	r1, r3, #3
 81054b6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81054ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 81054bc:	4a57      	ldr	r2, [pc, #348]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81054be:	430b      	orrs	r3, r1
 81054c0:	64d3      	str	r3, [r2, #76]	@ 0x4c
 81054c2:	e003      	b.n	81054cc <HAL_RCCEx_PeriphCLKConfig+0x7c4>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81054c4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81054c8:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 81054cc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81054d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81054d4:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 81054d8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 81054dc:	2300      	movs	r3, #0
 81054de:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 81054e2:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 81054e6:	460b      	mov	r3, r1
 81054e8:	4313      	orrs	r3, r2
 81054ea:	f000 809f 	beq.w	810562c <HAL_RCCEx_PeriphCLKConfig+0x924>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 81054ee:	4b4c      	ldr	r3, [pc, #304]	@ (8105620 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 81054f0:	681b      	ldr	r3, [r3, #0]
 81054f2:	4a4b      	ldr	r2, [pc, #300]	@ (8105620 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 81054f4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 81054f8:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 81054fa:	f7fc fa35 	bl	8101968 <HAL_GetTick>
 81054fe:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8105502:	e00b      	b.n	810551c <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8105504:	f7fc fa30 	bl	8101968 <HAL_GetTick>
 8105508:	4602      	mov	r2, r0
 810550a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 810550e:	1ad3      	subs	r3, r2, r3
 8105510:	2b64      	cmp	r3, #100	@ 0x64
 8105512:	d903      	bls.n	810551c <HAL_RCCEx_PeriphCLKConfig+0x814>
      {
        ret = HAL_TIMEOUT;
 8105514:	2303      	movs	r3, #3
 8105516:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810551a:	e005      	b.n	8105528 <HAL_RCCEx_PeriphCLKConfig+0x820>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 810551c:	4b40      	ldr	r3, [pc, #256]	@ (8105620 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 810551e:	681b      	ldr	r3, [r3, #0]
 8105520:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8105524:	2b00      	cmp	r3, #0
 8105526:	d0ed      	beq.n	8105504 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      }
    }

    if (ret == HAL_OK)
 8105528:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810552c:	2b00      	cmp	r3, #0
 810552e:	d179      	bne.n	8105624 <HAL_RCCEx_PeriphCLKConfig+0x91c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8105530:	4b3a      	ldr	r3, [pc, #232]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105532:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8105534:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105538:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 810553c:	4053      	eors	r3, r2
 810553e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8105542:	2b00      	cmp	r3, #0
 8105544:	d015      	beq.n	8105572 <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8105546:	4b35      	ldr	r3, [pc, #212]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105548:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 810554a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 810554e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8105552:	4b32      	ldr	r3, [pc, #200]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105554:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8105556:	4a31      	ldr	r2, [pc, #196]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105558:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 810555c:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 810555e:	4b2f      	ldr	r3, [pc, #188]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105560:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8105562:	4a2e      	ldr	r2, [pc, #184]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8105564:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8105568:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 810556a:	4a2c      	ldr	r2, [pc, #176]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810556c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8105570:	6713      	str	r3, [r2, #112]	@ 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8105572:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105576:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 810557a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 810557e:	d118      	bne.n	81055b2 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8105580:	f7fc f9f2 	bl	8101968 <HAL_GetTick>
 8105584:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8105588:	e00d      	b.n	81055a6 <HAL_RCCEx_PeriphCLKConfig+0x89e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 810558a:	f7fc f9ed 	bl	8101968 <HAL_GetTick>
 810558e:	4602      	mov	r2, r0
 8105590:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8105594:	1ad2      	subs	r2, r2, r3
 8105596:	f241 3388 	movw	r3, #5000	@ 0x1388
 810559a:	429a      	cmp	r2, r3
 810559c:	d903      	bls.n	81055a6 <HAL_RCCEx_PeriphCLKConfig+0x89e>
          {
            ret = HAL_TIMEOUT;
 810559e:	2303      	movs	r3, #3
 81055a0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
            break;
 81055a4:	e005      	b.n	81055b2 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 81055a6:	4b1d      	ldr	r3, [pc, #116]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055a8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 81055aa:	f003 0302 	and.w	r3, r3, #2
 81055ae:	2b00      	cmp	r3, #0
 81055b0:	d0eb      	beq.n	810558a <HAL_RCCEx_PeriphCLKConfig+0x882>
          }
        }
      }

      if (ret == HAL_OK)
 81055b2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81055b6:	2b00      	cmp	r3, #0
 81055b8:	d12b      	bne.n	8105612 <HAL_RCCEx_PeriphCLKConfig+0x90a>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 81055ba:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81055be:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 81055c2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 81055c6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 81055ca:	d110      	bne.n	81055ee <HAL_RCCEx_PeriphCLKConfig+0x8e6>
 81055cc:	4b13      	ldr	r3, [pc, #76]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055ce:	691b      	ldr	r3, [r3, #16]
 81055d0:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
 81055d4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81055d8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 81055dc:	091b      	lsrs	r3, r3, #4
 81055de:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 81055e2:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 81055e6:	4a0d      	ldr	r2, [pc, #52]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055e8:	430b      	orrs	r3, r1
 81055ea:	6113      	str	r3, [r2, #16]
 81055ec:	e005      	b.n	81055fa <HAL_RCCEx_PeriphCLKConfig+0x8f2>
 81055ee:	4b0b      	ldr	r3, [pc, #44]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055f0:	691b      	ldr	r3, [r3, #16]
 81055f2:	4a0a      	ldr	r2, [pc, #40]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055f4:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 81055f8:	6113      	str	r3, [r2, #16]
 81055fa:	4b08      	ldr	r3, [pc, #32]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81055fc:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 81055fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105602:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8105606:	f3c3 030b 	ubfx	r3, r3, #0, #12
 810560a:	4a04      	ldr	r2, [pc, #16]	@ (810561c <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810560c:	430b      	orrs	r3, r1
 810560e:	6713      	str	r3, [r2, #112]	@ 0x70
 8105610:	e00c      	b.n	810562c <HAL_RCCEx_PeriphCLKConfig+0x924>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8105612:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105616:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
 810561a:	e007      	b.n	810562c <HAL_RCCEx_PeriphCLKConfig+0x924>
 810561c:	58024400 	.word	0x58024400
 8105620:	58024800 	.word	0x58024800
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105624:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105628:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 810562c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105630:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105634:	f002 0301 	and.w	r3, r2, #1
 8105638:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 810563c:	2300      	movs	r3, #0
 810563e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8105642:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 8105646:	460b      	mov	r3, r1
 8105648:	4313      	orrs	r3, r2
 810564a:	f000 8089 	beq.w	8105760 <HAL_RCCEx_PeriphCLKConfig+0xa58>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
 810564e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105652:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8105654:	2b28      	cmp	r3, #40	@ 0x28
 8105656:	d86b      	bhi.n	8105730 <HAL_RCCEx_PeriphCLKConfig+0xa28>
 8105658:	a201      	add	r2, pc, #4	@ (adr r2, 8105660 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 810565a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810565e:	bf00      	nop
 8105660:	08105739 	.word	0x08105739
 8105664:	08105731 	.word	0x08105731
 8105668:	08105731 	.word	0x08105731
 810566c:	08105731 	.word	0x08105731
 8105670:	08105731 	.word	0x08105731
 8105674:	08105731 	.word	0x08105731
 8105678:	08105731 	.word	0x08105731
 810567c:	08105731 	.word	0x08105731
 8105680:	08105705 	.word	0x08105705
 8105684:	08105731 	.word	0x08105731
 8105688:	08105731 	.word	0x08105731
 810568c:	08105731 	.word	0x08105731
 8105690:	08105731 	.word	0x08105731
 8105694:	08105731 	.word	0x08105731
 8105698:	08105731 	.word	0x08105731
 810569c:	08105731 	.word	0x08105731
 81056a0:	0810571b 	.word	0x0810571b
 81056a4:	08105731 	.word	0x08105731
 81056a8:	08105731 	.word	0x08105731
 81056ac:	08105731 	.word	0x08105731
 81056b0:	08105731 	.word	0x08105731
 81056b4:	08105731 	.word	0x08105731
 81056b8:	08105731 	.word	0x08105731
 81056bc:	08105731 	.word	0x08105731
 81056c0:	08105739 	.word	0x08105739
 81056c4:	08105731 	.word	0x08105731
 81056c8:	08105731 	.word	0x08105731
 81056cc:	08105731 	.word	0x08105731
 81056d0:	08105731 	.word	0x08105731
 81056d4:	08105731 	.word	0x08105731
 81056d8:	08105731 	.word	0x08105731
 81056dc:	08105731 	.word	0x08105731
 81056e0:	08105739 	.word	0x08105739
 81056e4:	08105731 	.word	0x08105731
 81056e8:	08105731 	.word	0x08105731
 81056ec:	08105731 	.word	0x08105731
 81056f0:	08105731 	.word	0x08105731
 81056f4:	08105731 	.word	0x08105731
 81056f8:	08105731 	.word	0x08105731
 81056fc:	08105731 	.word	0x08105731
 8105700:	08105739 	.word	0x08105739
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8105704:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105708:	3308      	adds	r3, #8
 810570a:	2101      	movs	r1, #1
 810570c:	4618      	mov	r0, r3
 810570e:	f001 fe95 	bl	810743c <RCCEx_PLL2_Config>
 8105712:	4603      	mov	r3, r0
 8105714:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8105718:	e00f      	b.n	810573a <HAL_RCCEx_PeriphCLKConfig+0xa32>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 810571a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810571e:	3328      	adds	r3, #40	@ 0x28
 8105720:	2101      	movs	r1, #1
 8105722:	4618      	mov	r0, r3
 8105724:	f001 ff3c 	bl	81075a0 <RCCEx_PLL3_Config>
 8105728:	4603      	mov	r3, r0
 810572a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 810572e:	e004      	b.n	810573a <HAL_RCCEx_PeriphCLKConfig+0xa32>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105730:	2301      	movs	r3, #1
 8105732:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105736:	e000      	b.n	810573a <HAL_RCCEx_PeriphCLKConfig+0xa32>
        break;
 8105738:	bf00      	nop
    }

    if (ret == HAL_OK)
 810573a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810573e:	2b00      	cmp	r3, #0
 8105740:	d10a      	bne.n	8105758 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8105742:	4bbf      	ldr	r3, [pc, #764]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8105744:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105746:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 810574a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810574e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8105750:	4abb      	ldr	r2, [pc, #748]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8105752:	430b      	orrs	r3, r1
 8105754:	6553      	str	r3, [r2, #84]	@ 0x54
 8105756:	e003      	b.n	8105760 <HAL_RCCEx_PeriphCLKConfig+0xa58>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105758:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810575c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8105760:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105764:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105768:	f002 0302 	and.w	r3, r2, #2
 810576c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8105770:	2300      	movs	r3, #0
 8105772:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8105776:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 810577a:	460b      	mov	r3, r1
 810577c:	4313      	orrs	r3, r2
 810577e:	d041      	beq.n	8105804 <HAL_RCCEx_PeriphCLKConfig+0xafc>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
 8105780:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105784:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8105786:	2b05      	cmp	r3, #5
 8105788:	d824      	bhi.n	81057d4 <HAL_RCCEx_PeriphCLKConfig+0xacc>
 810578a:	a201      	add	r2, pc, #4	@ (adr r2, 8105790 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 810578c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8105790:	081057dd 	.word	0x081057dd
 8105794:	081057a9 	.word	0x081057a9
 8105798:	081057bf 	.word	0x081057bf
 810579c:	081057dd 	.word	0x081057dd
 81057a0:	081057dd 	.word	0x081057dd
 81057a4:	081057dd 	.word	0x081057dd
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 81057a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81057ac:	3308      	adds	r3, #8
 81057ae:	2101      	movs	r1, #1
 81057b0:	4618      	mov	r0, r3
 81057b2:	f001 fe43 	bl	810743c <RCCEx_PLL2_Config>
 81057b6:	4603      	mov	r3, r0
 81057b8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 81057bc:	e00f      	b.n	81057de <HAL_RCCEx_PeriphCLKConfig+0xad6>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 81057be:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81057c2:	3328      	adds	r3, #40	@ 0x28
 81057c4:	2101      	movs	r1, #1
 81057c6:	4618      	mov	r0, r3
 81057c8:	f001 feea 	bl	81075a0 <RCCEx_PLL3_Config>
 81057cc:	4603      	mov	r3, r0
 81057ce:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 81057d2:	e004      	b.n	81057de <HAL_RCCEx_PeriphCLKConfig+0xad6>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81057d4:	2301      	movs	r3, #1
 81057d6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81057da:	e000      	b.n	81057de <HAL_RCCEx_PeriphCLKConfig+0xad6>
        break;
 81057dc:	bf00      	nop
    }

    if (ret == HAL_OK)
 81057de:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81057e2:	2b00      	cmp	r3, #0
 81057e4:	d10a      	bne.n	81057fc <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 81057e6:	4b96      	ldr	r3, [pc, #600]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 81057e8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 81057ea:	f023 0107 	bic.w	r1, r3, #7
 81057ee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81057f2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 81057f4:	4a92      	ldr	r2, [pc, #584]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 81057f6:	430b      	orrs	r3, r1
 81057f8:	6553      	str	r3, [r2, #84]	@ 0x54
 81057fa:	e003      	b.n	8105804 <HAL_RCCEx_PeriphCLKConfig+0xafc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81057fc:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105800:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8105804:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105808:	e9d3 2300 	ldrd	r2, r3, [r3]
 810580c:	f002 0304 	and.w	r3, r2, #4
 8105810:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8105814:	2300      	movs	r3, #0
 8105816:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 810581a:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 810581e:	460b      	mov	r3, r1
 8105820:	4313      	orrs	r3, r2
 8105822:	d044      	beq.n	81058ae <HAL_RCCEx_PeriphCLKConfig+0xba6>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8105824:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105828:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 810582c:	2b05      	cmp	r3, #5
 810582e:	d825      	bhi.n	810587c <HAL_RCCEx_PeriphCLKConfig+0xb74>
 8105830:	a201      	add	r2, pc, #4	@ (adr r2, 8105838 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
 8105832:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8105836:	bf00      	nop
 8105838:	08105885 	.word	0x08105885
 810583c:	08105851 	.word	0x08105851
 8105840:	08105867 	.word	0x08105867
 8105844:	08105885 	.word	0x08105885
 8105848:	08105885 	.word	0x08105885
 810584c:	08105885 	.word	0x08105885
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8105850:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105854:	3308      	adds	r3, #8
 8105856:	2101      	movs	r1, #1
 8105858:	4618      	mov	r0, r3
 810585a:	f001 fdef 	bl	810743c <RCCEx_PLL2_Config>
 810585e:	4603      	mov	r3, r0
 8105860:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8105864:	e00f      	b.n	8105886 <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8105866:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810586a:	3328      	adds	r3, #40	@ 0x28
 810586c:	2101      	movs	r1, #1
 810586e:	4618      	mov	r0, r3
 8105870:	f001 fe96 	bl	81075a0 <RCCEx_PLL3_Config>
 8105874:	4603      	mov	r3, r0
 8105876:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 810587a:	e004      	b.n	8105886 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810587c:	2301      	movs	r3, #1
 810587e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105882:	e000      	b.n	8105886 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
 8105884:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105886:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810588a:	2b00      	cmp	r3, #0
 810588c:	d10b      	bne.n	81058a6 <HAL_RCCEx_PeriphCLKConfig+0xb9e>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 810588e:	4b6c      	ldr	r3, [pc, #432]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8105890:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105892:	f023 0107 	bic.w	r1, r3, #7
 8105896:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810589a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 810589e:	4a68      	ldr	r2, [pc, #416]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 81058a0:	430b      	orrs	r3, r1
 81058a2:	6593      	str	r3, [r2, #88]	@ 0x58
 81058a4:	e003      	b.n	81058ae <HAL_RCCEx_PeriphCLKConfig+0xba6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81058a6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81058aa:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 81058ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81058b2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81058b6:	f002 0320 	and.w	r3, r2, #32
 81058ba:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 81058be:	2300      	movs	r3, #0
 81058c0:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 81058c4:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 81058c8:	460b      	mov	r3, r1
 81058ca:	4313      	orrs	r3, r2
 81058cc:	d055      	beq.n	810597a <HAL_RCCEx_PeriphCLKConfig+0xc72>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
 81058ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81058d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 81058d6:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 81058da:	d033      	beq.n	8105944 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
 81058dc:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 81058e0:	d82c      	bhi.n	810593c <HAL_RCCEx_PeriphCLKConfig+0xc34>
 81058e2:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 81058e6:	d02f      	beq.n	8105948 <HAL_RCCEx_PeriphCLKConfig+0xc40>
 81058e8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 81058ec:	d826      	bhi.n	810593c <HAL_RCCEx_PeriphCLKConfig+0xc34>
 81058ee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 81058f2:	d02b      	beq.n	810594c <HAL_RCCEx_PeriphCLKConfig+0xc44>
 81058f4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 81058f8:	d820      	bhi.n	810593c <HAL_RCCEx_PeriphCLKConfig+0xc34>
 81058fa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81058fe:	d012      	beq.n	8105926 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
 8105900:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8105904:	d81a      	bhi.n	810593c <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8105906:	2b00      	cmp	r3, #0
 8105908:	d022      	beq.n	8105950 <HAL_RCCEx_PeriphCLKConfig+0xc48>
 810590a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810590e:	d115      	bne.n	810593c <HAL_RCCEx_PeriphCLKConfig+0xc34>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8105910:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105914:	3308      	adds	r3, #8
 8105916:	2100      	movs	r1, #0
 8105918:	4618      	mov	r0, r3
 810591a:	f001 fd8f 	bl	810743c <RCCEx_PLL2_Config>
 810591e:	4603      	mov	r3, r0
 8105920:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8105924:	e015      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8105926:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810592a:	3328      	adds	r3, #40	@ 0x28
 810592c:	2102      	movs	r1, #2
 810592e:	4618      	mov	r0, r3
 8105930:	f001 fe36 	bl	81075a0 <RCCEx_PLL3_Config>
 8105934:	4603      	mov	r3, r0
 8105936:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 810593a:	e00a      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810593c:	2301      	movs	r3, #1
 810593e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105942:	e006      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8105944:	bf00      	nop
 8105946:	e004      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8105948:	bf00      	nop
 810594a:	e002      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 810594c:	bf00      	nop
 810594e:	e000      	b.n	8105952 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8105950:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105952:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105956:	2b00      	cmp	r3, #0
 8105958:	d10b      	bne.n	8105972 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 810595a:	4b39      	ldr	r3, [pc, #228]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 810595c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 810595e:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 8105962:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105966:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 810596a:	4a35      	ldr	r2, [pc, #212]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 810596c:	430b      	orrs	r3, r1
 810596e:	6553      	str	r3, [r2, #84]	@ 0x54
 8105970:	e003      	b.n	810597a <HAL_RCCEx_PeriphCLKConfig+0xc72>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105972:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105976:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 810597a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810597e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105982:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 8105986:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 810598a:	2300      	movs	r3, #0
 810598c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8105990:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 8105994:	460b      	mov	r3, r1
 8105996:	4313      	orrs	r3, r2
 8105998:	d058      	beq.n	8105a4c <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
 810599a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810599e:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 81059a2:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 81059a6:	d033      	beq.n	8105a10 <HAL_RCCEx_PeriphCLKConfig+0xd08>
 81059a8:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 81059ac:	d82c      	bhi.n	8105a08 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 81059ae:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81059b2:	d02f      	beq.n	8105a14 <HAL_RCCEx_PeriphCLKConfig+0xd0c>
 81059b4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81059b8:	d826      	bhi.n	8105a08 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 81059ba:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 81059be:	d02b      	beq.n	8105a18 <HAL_RCCEx_PeriphCLKConfig+0xd10>
 81059c0:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 81059c4:	d820      	bhi.n	8105a08 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 81059c6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 81059ca:	d012      	beq.n	81059f2 <HAL_RCCEx_PeriphCLKConfig+0xcea>
 81059cc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 81059d0:	d81a      	bhi.n	8105a08 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 81059d2:	2b00      	cmp	r3, #0
 81059d4:	d022      	beq.n	8105a1c <HAL_RCCEx_PeriphCLKConfig+0xd14>
 81059d6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 81059da:	d115      	bne.n	8105a08 <HAL_RCCEx_PeriphCLKConfig+0xd00>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81059dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81059e0:	3308      	adds	r3, #8
 81059e2:	2100      	movs	r1, #0
 81059e4:	4618      	mov	r0, r3
 81059e6:	f001 fd29 	bl	810743c <RCCEx_PLL2_Config>
 81059ea:	4603      	mov	r3, r0
 81059ec:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 81059f0:	e015      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 81059f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81059f6:	3328      	adds	r3, #40	@ 0x28
 81059f8:	2102      	movs	r1, #2
 81059fa:	4618      	mov	r0, r3
 81059fc:	f001 fdd0 	bl	81075a0 <RCCEx_PLL3_Config>
 8105a00:	4603      	mov	r3, r0
 8105a02:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 8105a06:	e00a      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105a08:	2301      	movs	r3, #1
 8105a0a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105a0e:	e006      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8105a10:	bf00      	nop
 8105a12:	e004      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8105a14:	bf00      	nop
 8105a16:	e002      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8105a18:	bf00      	nop
 8105a1a:	e000      	b.n	8105a1e <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8105a1c:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105a1e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105a22:	2b00      	cmp	r3, #0
 8105a24:	d10e      	bne.n	8105a44 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8105a26:	4b06      	ldr	r3, [pc, #24]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8105a28:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105a2a:	f423 51e0 	bic.w	r1, r3, #7168	@ 0x1c00
 8105a2e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105a32:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8105a36:	4a02      	ldr	r2, [pc, #8]	@ (8105a40 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8105a38:	430b      	orrs	r3, r1
 8105a3a:	6593      	str	r3, [r2, #88]	@ 0x58
 8105a3c:	e006      	b.n	8105a4c <HAL_RCCEx_PeriphCLKConfig+0xd44>
 8105a3e:	bf00      	nop
 8105a40:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105a44:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105a48:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8105a4c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105a50:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105a54:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 8105a58:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 8105a5c:	2300      	movs	r3, #0
 8105a5e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8105a62:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 8105a66:	460b      	mov	r3, r1
 8105a68:	4313      	orrs	r3, r2
 8105a6a:	d055      	beq.n	8105b18 <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
 8105a6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105a70:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8105a74:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8105a78:	d033      	beq.n	8105ae2 <HAL_RCCEx_PeriphCLKConfig+0xdda>
 8105a7a:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8105a7e:	d82c      	bhi.n	8105ada <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8105a80:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8105a84:	d02f      	beq.n	8105ae6 <HAL_RCCEx_PeriphCLKConfig+0xdde>
 8105a86:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8105a8a:	d826      	bhi.n	8105ada <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8105a8c:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8105a90:	d02b      	beq.n	8105aea <HAL_RCCEx_PeriphCLKConfig+0xde2>
 8105a92:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8105a96:	d820      	bhi.n	8105ada <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8105a98:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8105a9c:	d012      	beq.n	8105ac4 <HAL_RCCEx_PeriphCLKConfig+0xdbc>
 8105a9e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8105aa2:	d81a      	bhi.n	8105ada <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8105aa4:	2b00      	cmp	r3, #0
 8105aa6:	d022      	beq.n	8105aee <HAL_RCCEx_PeriphCLKConfig+0xde6>
 8105aa8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8105aac:	d115      	bne.n	8105ada <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8105aae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105ab2:	3308      	adds	r3, #8
 8105ab4:	2100      	movs	r1, #0
 8105ab6:	4618      	mov	r0, r3
 8105ab8:	f001 fcc0 	bl	810743c <RCCEx_PLL2_Config>
 8105abc:	4603      	mov	r3, r0
 8105abe:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8105ac2:	e015      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8105ac4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105ac8:	3328      	adds	r3, #40	@ 0x28
 8105aca:	2102      	movs	r1, #2
 8105acc:	4618      	mov	r0, r3
 8105ace:	f001 fd67 	bl	81075a0 <RCCEx_PLL3_Config>
 8105ad2:	4603      	mov	r3, r0
 8105ad4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8105ad8:	e00a      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105ada:	2301      	movs	r3, #1
 8105adc:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105ae0:	e006      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8105ae2:	bf00      	nop
 8105ae4:	e004      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8105ae6:	bf00      	nop
 8105ae8:	e002      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8105aea:	bf00      	nop
 8105aec:	e000      	b.n	8105af0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8105aee:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105af0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105af4:	2b00      	cmp	r3, #0
 8105af6:	d10b      	bne.n	8105b10 <HAL_RCCEx_PeriphCLKConfig+0xe08>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 8105af8:	4ba1      	ldr	r3, [pc, #644]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105afa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105afc:	f423 4160 	bic.w	r1, r3, #57344	@ 0xe000
 8105b00:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b04:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8105b08:	4a9d      	ldr	r2, [pc, #628]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105b0a:	430b      	orrs	r3, r1
 8105b0c:	6593      	str	r3, [r2, #88]	@ 0x58
 8105b0e:	e003      	b.n	8105b18 <HAL_RCCEx_PeriphCLKConfig+0xe10>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105b10:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105b14:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 8105b18:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105b20:	f002 0308 	and.w	r3, r2, #8
 8105b24:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8105b28:	2300      	movs	r3, #0
 8105b2a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8105b2e:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 8105b32:	460b      	mov	r3, r1
 8105b34:	4313      	orrs	r3, r2
 8105b36:	d01e      	beq.n	8105b76 <HAL_RCCEx_PeriphCLKConfig+0xe6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 8105b38:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b3c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8105b40:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8105b44:	d10c      	bne.n	8105b60 <HAL_RCCEx_PeriphCLKConfig+0xe58>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8105b46:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b4a:	3328      	adds	r3, #40	@ 0x28
 8105b4c:	2102      	movs	r1, #2
 8105b4e:	4618      	mov	r0, r3
 8105b50:	f001 fd26 	bl	81075a0 <RCCEx_PLL3_Config>
 8105b54:	4603      	mov	r3, r0
 8105b56:	2b00      	cmp	r3, #0
 8105b58:	d002      	beq.n	8105b60 <HAL_RCCEx_PeriphCLKConfig+0xe58>
      {
        status = HAL_ERROR;
 8105b5a:	2301      	movs	r3, #1
 8105b5c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8105b60:	4b87      	ldr	r3, [pc, #540]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105b62:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105b64:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 8105b68:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b6c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8105b70:	4a83      	ldr	r2, [pc, #524]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105b72:	430b      	orrs	r3, r1
 8105b74:	6553      	str	r3, [r2, #84]	@ 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8105b76:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105b7e:	f002 0310 	and.w	r3, r2, #16
 8105b82:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8105b86:	2300      	movs	r3, #0
 8105b88:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8105b8c:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 8105b90:	460b      	mov	r3, r1
 8105b92:	4313      	orrs	r3, r2
 8105b94:	d01e      	beq.n	8105bd4 <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 8105b96:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105b9a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8105b9e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8105ba2:	d10c      	bne.n	8105bbe <HAL_RCCEx_PeriphCLKConfig+0xeb6>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8105ba4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105ba8:	3328      	adds	r3, #40	@ 0x28
 8105baa:	2102      	movs	r1, #2
 8105bac:	4618      	mov	r0, r3
 8105bae:	f001 fcf7 	bl	81075a0 <RCCEx_PLL3_Config>
 8105bb2:	4603      	mov	r3, r0
 8105bb4:	2b00      	cmp	r3, #0
 8105bb6:	d002      	beq.n	8105bbe <HAL_RCCEx_PeriphCLKConfig+0xeb6>
      {
        status = HAL_ERROR;
 8105bb8:	2301      	movs	r3, #1
 8105bba:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8105bbe:	4b70      	ldr	r3, [pc, #448]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105bc0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105bc2:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8105bc6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105bca:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8105bce:	4a6c      	ldr	r2, [pc, #432]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105bd0:	430b      	orrs	r3, r1
 8105bd2:	6593      	str	r3, [r2, #88]	@ 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8105bd4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105bd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105bdc:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 8105be0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8105be4:	2300      	movs	r3, #0
 8105be6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8105bea:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 8105bee:	460b      	mov	r3, r1
 8105bf0:	4313      	orrs	r3, r2
 8105bf2:	d03e      	beq.n	8105c72 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
  {
    switch (PeriphClkInit->AdcClockSelection)
 8105bf4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105bf8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8105bfc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8105c00:	d022      	beq.n	8105c48 <HAL_RCCEx_PeriphCLKConfig+0xf40>
 8105c02:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8105c06:	d81b      	bhi.n	8105c40 <HAL_RCCEx_PeriphCLKConfig+0xf38>
 8105c08:	2b00      	cmp	r3, #0
 8105c0a:	d003      	beq.n	8105c14 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
 8105c0c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8105c10:	d00b      	beq.n	8105c2a <HAL_RCCEx_PeriphCLKConfig+0xf22>
 8105c12:	e015      	b.n	8105c40 <HAL_RCCEx_PeriphCLKConfig+0xf38>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8105c14:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105c18:	3308      	adds	r3, #8
 8105c1a:	2100      	movs	r1, #0
 8105c1c:	4618      	mov	r0, r3
 8105c1e:	f001 fc0d 	bl	810743c <RCCEx_PLL2_Config>
 8105c22:	4603      	mov	r3, r0
 8105c24:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 8105c28:	e00f      	b.n	8105c4a <HAL_RCCEx_PeriphCLKConfig+0xf42>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8105c2a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105c2e:	3328      	adds	r3, #40	@ 0x28
 8105c30:	2102      	movs	r1, #2
 8105c32:	4618      	mov	r0, r3
 8105c34:	f001 fcb4 	bl	81075a0 <RCCEx_PLL3_Config>
 8105c38:	4603      	mov	r3, r0
 8105c3a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 8105c3e:	e004      	b.n	8105c4a <HAL_RCCEx_PeriphCLKConfig+0xf42>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105c40:	2301      	movs	r3, #1
 8105c42:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105c46:	e000      	b.n	8105c4a <HAL_RCCEx_PeriphCLKConfig+0xf42>
        break;
 8105c48:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105c4a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105c4e:	2b00      	cmp	r3, #0
 8105c50:	d10b      	bne.n	8105c6a <HAL_RCCEx_PeriphCLKConfig+0xf62>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8105c52:	4b4b      	ldr	r3, [pc, #300]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105c54:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8105c56:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
 8105c5a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105c5e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8105c62:	4a47      	ldr	r2, [pc, #284]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105c64:	430b      	orrs	r3, r1
 8105c66:	6593      	str	r3, [r2, #88]	@ 0x58
 8105c68:	e003      	b.n	8105c72 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105c6a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105c6e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8105c72:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105c76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105c7a:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 8105c7e:	67bb      	str	r3, [r7, #120]	@ 0x78
 8105c80:	2300      	movs	r3, #0
 8105c82:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8105c84:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 8105c88:	460b      	mov	r3, r1
 8105c8a:	4313      	orrs	r3, r2
 8105c8c:	d03b      	beq.n	8105d06 <HAL_RCCEx_PeriphCLKConfig+0xffe>
  {

    switch (PeriphClkInit->UsbClockSelection)
 8105c8e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105c92:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8105c96:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8105c9a:	d01f      	beq.n	8105cdc <HAL_RCCEx_PeriphCLKConfig+0xfd4>
 8105c9c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8105ca0:	d818      	bhi.n	8105cd4 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
 8105ca2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8105ca6:	d003      	beq.n	8105cb0 <HAL_RCCEx_PeriphCLKConfig+0xfa8>
 8105ca8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8105cac:	d007      	beq.n	8105cbe <HAL_RCCEx_PeriphCLKConfig+0xfb6>
 8105cae:	e011      	b.n	8105cd4 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8105cb0:	4b33      	ldr	r3, [pc, #204]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105cb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8105cb4:	4a32      	ldr	r2, [pc, #200]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105cb6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8105cba:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
 8105cbc:	e00f      	b.n	8105cde <HAL_RCCEx_PeriphCLKConfig+0xfd6>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8105cbe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105cc2:	3328      	adds	r3, #40	@ 0x28
 8105cc4:	2101      	movs	r1, #1
 8105cc6:	4618      	mov	r0, r3
 8105cc8:	f001 fc6a 	bl	81075a0 <RCCEx_PLL3_Config>
 8105ccc:	4603      	mov	r3, r0
 8105cce:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* USB clock source configuration done later after clock selection check */
        break;
 8105cd2:	e004      	b.n	8105cde <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105cd4:	2301      	movs	r3, #1
 8105cd6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105cda:	e000      	b.n	8105cde <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        break;
 8105cdc:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105cde:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105ce2:	2b00      	cmp	r3, #0
 8105ce4:	d10b      	bne.n	8105cfe <HAL_RCCEx_PeriphCLKConfig+0xff6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8105ce6:	4b26      	ldr	r3, [pc, #152]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105ce8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105cea:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 8105cee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105cf2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8105cf6:	4a22      	ldr	r2, [pc, #136]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105cf8:	430b      	orrs	r3, r1
 8105cfa:	6553      	str	r3, [r2, #84]	@ 0x54
 8105cfc:	e003      	b.n	8105d06 <HAL_RCCEx_PeriphCLKConfig+0xffe>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105cfe:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105d02:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 8105d06:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105d0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105d0e:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 8105d12:	673b      	str	r3, [r7, #112]	@ 0x70
 8105d14:	2300      	movs	r3, #0
 8105d16:	677b      	str	r3, [r7, #116]	@ 0x74
 8105d18:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 8105d1c:	460b      	mov	r3, r1
 8105d1e:	4313      	orrs	r3, r2
 8105d20:	d034      	beq.n	8105d8c <HAL_RCCEx_PeriphCLKConfig+0x1084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
 8105d22:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105d26:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8105d28:	2b00      	cmp	r3, #0
 8105d2a:	d003      	beq.n	8105d34 <HAL_RCCEx_PeriphCLKConfig+0x102c>
 8105d2c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8105d30:	d007      	beq.n	8105d42 <HAL_RCCEx_PeriphCLKConfig+0x103a>
 8105d32:	e011      	b.n	8105d58 <HAL_RCCEx_PeriphCLKConfig+0x1050>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8105d34:	4b12      	ldr	r3, [pc, #72]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105d36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8105d38:	4a11      	ldr	r2, [pc, #68]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105d3a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8105d3e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 8105d40:	e00e      	b.n	8105d60 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8105d42:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105d46:	3308      	adds	r3, #8
 8105d48:	2102      	movs	r1, #2
 8105d4a:	4618      	mov	r0, r3
 8105d4c:	f001 fb76 	bl	810743c <RCCEx_PLL2_Config>
 8105d50:	4603      	mov	r3, r0
 8105d52:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 8105d56:	e003      	b.n	8105d60 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      default:
        ret = HAL_ERROR;
 8105d58:	2301      	movs	r3, #1
 8105d5a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105d5e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105d60:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105d64:	2b00      	cmp	r3, #0
 8105d66:	d10d      	bne.n	8105d84 <HAL_RCCEx_PeriphCLKConfig+0x107c>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8105d68:	4b05      	ldr	r3, [pc, #20]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105d6a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8105d6c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 8105d70:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105d74:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8105d76:	4a02      	ldr	r2, [pc, #8]	@ (8105d80 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8105d78:	430b      	orrs	r3, r1
 8105d7a:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8105d7c:	e006      	b.n	8105d8c <HAL_RCCEx_PeriphCLKConfig+0x1084>
 8105d7e:	bf00      	nop
 8105d80:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105d84:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105d88:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8105d8c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105d90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105d94:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
 8105d98:	66bb      	str	r3, [r7, #104]	@ 0x68
 8105d9a:	2300      	movs	r3, #0
 8105d9c:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8105d9e:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 8105da2:	460b      	mov	r3, r1
 8105da4:	4313      	orrs	r3, r2
 8105da6:	d00c      	beq.n	8105dc2 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8105da8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105dac:	3328      	adds	r3, #40	@ 0x28
 8105dae:	2102      	movs	r1, #2
 8105db0:	4618      	mov	r0, r3
 8105db2:	f001 fbf5 	bl	81075a0 <RCCEx_PLL3_Config>
 8105db6:	4603      	mov	r3, r0
 8105db8:	2b00      	cmp	r3, #0
 8105dba:	d002      	beq.n	8105dc2 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
    {
      status = HAL_ERROR;
 8105dbc:	2301      	movs	r3, #1
 8105dbe:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8105dc2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105dc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105dca:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 8105dce:	663b      	str	r3, [r7, #96]	@ 0x60
 8105dd0:	2300      	movs	r3, #0
 8105dd2:	667b      	str	r3, [r7, #100]	@ 0x64
 8105dd4:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 8105dd8:	460b      	mov	r3, r1
 8105dda:	4313      	orrs	r3, r2
 8105ddc:	d038      	beq.n	8105e50 <HAL_RCCEx_PeriphCLKConfig+0x1148>
  {

    switch (PeriphClkInit->RngClockSelection)
 8105dde:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105de2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8105de6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8105dea:	d018      	beq.n	8105e1e <HAL_RCCEx_PeriphCLKConfig+0x1116>
 8105dec:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8105df0:	d811      	bhi.n	8105e16 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 8105df2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8105df6:	d014      	beq.n	8105e22 <HAL_RCCEx_PeriphCLKConfig+0x111a>
 8105df8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8105dfc:	d80b      	bhi.n	8105e16 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 8105dfe:	2b00      	cmp	r3, #0
 8105e00:	d011      	beq.n	8105e26 <HAL_RCCEx_PeriphCLKConfig+0x111e>
 8105e02:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8105e06:	d106      	bne.n	8105e16 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8105e08:	4bc3      	ldr	r3, [pc, #780]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8105e0c:	4ac2      	ldr	r2, [pc, #776]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e0e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8105e12:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
 8105e14:	e008      	b.n	8105e28 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8105e16:	2301      	movs	r3, #1
 8105e18:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8105e1c:	e004      	b.n	8105e28 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8105e1e:	bf00      	nop
 8105e20:	e002      	b.n	8105e28 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8105e22:	bf00      	nop
 8105e24:	e000      	b.n	8105e28 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8105e26:	bf00      	nop
    }

    if (ret == HAL_OK)
 8105e28:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105e2c:	2b00      	cmp	r3, #0
 8105e2e:	d10b      	bne.n	8105e48 <HAL_RCCEx_PeriphCLKConfig+0x1140>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8105e30:	4bb9      	ldr	r3, [pc, #740]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e32:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105e34:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8105e38:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105e3c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8105e40:	4ab5      	ldr	r2, [pc, #724]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e42:	430b      	orrs	r3, r1
 8105e44:	6553      	str	r3, [r2, #84]	@ 0x54
 8105e46:	e003      	b.n	8105e50 <HAL_RCCEx_PeriphCLKConfig+0x1148>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105e48:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105e4c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8105e50:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105e54:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105e58:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 8105e5c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8105e5e:	2300      	movs	r3, #0
 8105e60:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8105e62:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 8105e66:	460b      	mov	r3, r1
 8105e68:	4313      	orrs	r3, r2
 8105e6a:	d009      	beq.n	8105e80 <HAL_RCCEx_PeriphCLKConfig+0x1178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8105e6c:	4baa      	ldr	r3, [pc, #680]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e6e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8105e70:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 8105e74:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105e78:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8105e7a:	4aa7      	ldr	r2, [pc, #668]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e7c:	430b      	orrs	r3, r1
 8105e7e:	6513      	str	r3, [r2, #80]	@ 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 8105e80:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105e84:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105e88:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 8105e8c:	653b      	str	r3, [r7, #80]	@ 0x50
 8105e8e:	2300      	movs	r3, #0
 8105e90:	657b      	str	r3, [r7, #84]	@ 0x54
 8105e92:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 8105e96:	460b      	mov	r3, r1
 8105e98:	4313      	orrs	r3, r2
 8105e9a:	d00a      	beq.n	8105eb2 <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 8105e9c:	4b9e      	ldr	r3, [pc, #632]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105e9e:	691b      	ldr	r3, [r3, #16]
 8105ea0:	f423 4180 	bic.w	r1, r3, #16384	@ 0x4000
 8105ea4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105ea8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 8105eac:	4a9a      	ldr	r2, [pc, #616]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105eae:	430b      	orrs	r3, r1
 8105eb0:	6113      	str	r3, [r2, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8105eb2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105eb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105eba:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 8105ebe:	64bb      	str	r3, [r7, #72]	@ 0x48
 8105ec0:	2300      	movs	r3, #0
 8105ec2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8105ec4:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 8105ec8:	460b      	mov	r3, r1
 8105eca:	4313      	orrs	r3, r2
 8105ecc:	d009      	beq.n	8105ee2 <HAL_RCCEx_PeriphCLKConfig+0x11da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8105ece:	4b92      	ldr	r3, [pc, #584]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105ed0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8105ed2:	f023 7180 	bic.w	r1, r3, #16777216	@ 0x1000000
 8105ed6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105eda:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8105edc:	4a8e      	ldr	r2, [pc, #568]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105ede:	430b      	orrs	r3, r1
 8105ee0:	6513      	str	r3, [r2, #80]	@ 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8105ee2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105ee6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105eea:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
 8105eee:	643b      	str	r3, [r7, #64]	@ 0x40
 8105ef0:	2300      	movs	r3, #0
 8105ef2:	647b      	str	r3, [r7, #68]	@ 0x44
 8105ef4:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 8105ef8:	460b      	mov	r3, r1
 8105efa:	4313      	orrs	r3, r2
 8105efc:	d00e      	beq.n	8105f1c <HAL_RCCEx_PeriphCLKConfig+0x1214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8105efe:	4b86      	ldr	r3, [pc, #536]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f00:	691b      	ldr	r3, [r3, #16]
 8105f02:	4a85      	ldr	r2, [pc, #532]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f04:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8105f08:	6113      	str	r3, [r2, #16]
 8105f0a:	4b83      	ldr	r3, [pc, #524]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f0c:	6919      	ldr	r1, [r3, #16]
 8105f0e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f12:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8105f16:	4a80      	ldr	r2, [pc, #512]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f18:	430b      	orrs	r3, r1
 8105f1a:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8105f1c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f20:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105f24:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
 8105f28:	63bb      	str	r3, [r7, #56]	@ 0x38
 8105f2a:	2300      	movs	r3, #0
 8105f2c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8105f2e:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8105f32:	460b      	mov	r3, r1
 8105f34:	4313      	orrs	r3, r2
 8105f36:	d009      	beq.n	8105f4c <HAL_RCCEx_PeriphCLKConfig+0x1244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 8105f38:	4b77      	ldr	r3, [pc, #476]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f3a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8105f3c:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8105f40:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f44:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105f46:	4a74      	ldr	r2, [pc, #464]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f48:	430b      	orrs	r3, r1
 8105f4a:	64d3      	str	r3, [r2, #76]	@ 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8105f4c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f50:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105f54:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 8105f58:	633b      	str	r3, [r7, #48]	@ 0x30
 8105f5a:	2300      	movs	r3, #0
 8105f5c:	637b      	str	r3, [r7, #52]	@ 0x34
 8105f5e:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 8105f62:	460b      	mov	r3, r1
 8105f64:	4313      	orrs	r3, r2
 8105f66:	d00a      	beq.n	8105f7e <HAL_RCCEx_PeriphCLKConfig+0x1276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8105f68:	4b6b      	ldr	r3, [pc, #428]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f6a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8105f6c:	f423 0140 	bic.w	r1, r3, #12582912	@ 0xc00000
 8105f70:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f74:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8105f78:	4a67      	ldr	r2, [pc, #412]	@ (8106118 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8105f7a:	430b      	orrs	r3, r1
 8105f7c:	6553      	str	r3, [r2, #84]	@ 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 8105f7e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105f86:	2100      	movs	r1, #0
 8105f88:	62b9      	str	r1, [r7, #40]	@ 0x28
 8105f8a:	f003 0301 	and.w	r3, r3, #1
 8105f8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8105f90:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 8105f94:	460b      	mov	r3, r1
 8105f96:	4313      	orrs	r3, r2
 8105f98:	d011      	beq.n	8105fbe <HAL_RCCEx_PeriphCLKConfig+0x12b6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8105f9a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105f9e:	3308      	adds	r3, #8
 8105fa0:	2100      	movs	r1, #0
 8105fa2:	4618      	mov	r0, r3
 8105fa4:	f001 fa4a 	bl	810743c <RCCEx_PLL2_Config>
 8105fa8:	4603      	mov	r3, r0
 8105faa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 8105fae:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105fb2:	2b00      	cmp	r3, #0
 8105fb4:	d003      	beq.n	8105fbe <HAL_RCCEx_PeriphCLKConfig+0x12b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105fb6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105fba:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 8105fbe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105fc2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8105fc6:	2100      	movs	r1, #0
 8105fc8:	6239      	str	r1, [r7, #32]
 8105fca:	f003 0302 	and.w	r3, r3, #2
 8105fce:	627b      	str	r3, [r7, #36]	@ 0x24
 8105fd0:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8105fd4:	460b      	mov	r3, r1
 8105fd6:	4313      	orrs	r3, r2
 8105fd8:	d011      	beq.n	8105ffe <HAL_RCCEx_PeriphCLKConfig+0x12f6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8105fda:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8105fde:	3308      	adds	r3, #8
 8105fe0:	2101      	movs	r1, #1
 8105fe2:	4618      	mov	r0, r3
 8105fe4:	f001 fa2a 	bl	810743c <RCCEx_PLL2_Config>
 8105fe8:	4603      	mov	r3, r0
 8105fea:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 8105fee:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105ff2:	2b00      	cmp	r3, #0
 8105ff4:	d003      	beq.n	8105ffe <HAL_RCCEx_PeriphCLKConfig+0x12f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8105ff6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8105ffa:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 8105ffe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8106002:	e9d3 2300 	ldrd	r2, r3, [r3]
 8106006:	2100      	movs	r1, #0
 8106008:	61b9      	str	r1, [r7, #24]
 810600a:	f003 0304 	and.w	r3, r3, #4
 810600e:	61fb      	str	r3, [r7, #28]
 8106010:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8106014:	460b      	mov	r3, r1
 8106016:	4313      	orrs	r3, r2
 8106018:	d011      	beq.n	810603e <HAL_RCCEx_PeriphCLKConfig+0x1336>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 810601a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810601e:	3308      	adds	r3, #8
 8106020:	2102      	movs	r1, #2
 8106022:	4618      	mov	r0, r3
 8106024:	f001 fa0a 	bl	810743c <RCCEx_PLL2_Config>
 8106028:	4603      	mov	r3, r0
 810602a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 810602e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8106032:	2b00      	cmp	r3, #0
 8106034:	d003      	beq.n	810603e <HAL_RCCEx_PeriphCLKConfig+0x1336>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8106036:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810603a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 810603e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8106042:	e9d3 2300 	ldrd	r2, r3, [r3]
 8106046:	2100      	movs	r1, #0
 8106048:	6139      	str	r1, [r7, #16]
 810604a:	f003 0308 	and.w	r3, r3, #8
 810604e:	617b      	str	r3, [r7, #20]
 8106050:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8106054:	460b      	mov	r3, r1
 8106056:	4313      	orrs	r3, r2
 8106058:	d011      	beq.n	810607e <HAL_RCCEx_PeriphCLKConfig+0x1376>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 810605a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810605e:	3328      	adds	r3, #40	@ 0x28
 8106060:	2100      	movs	r1, #0
 8106062:	4618      	mov	r0, r3
 8106064:	f001 fa9c 	bl	81075a0 <RCCEx_PLL3_Config>
 8106068:	4603      	mov	r3, r0
 810606a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  
    if (ret == HAL_OK)
 810606e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8106072:	2b00      	cmp	r3, #0
 8106074:	d003      	beq.n	810607e <HAL_RCCEx_PeriphCLKConfig+0x1376>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8106076:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810607a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 810607e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8106082:	e9d3 2300 	ldrd	r2, r3, [r3]
 8106086:	2100      	movs	r1, #0
 8106088:	60b9      	str	r1, [r7, #8]
 810608a:	f003 0310 	and.w	r3, r3, #16
 810608e:	60fb      	str	r3, [r7, #12]
 8106090:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8106094:	460b      	mov	r3, r1
 8106096:	4313      	orrs	r3, r2
 8106098:	d011      	beq.n	81060be <HAL_RCCEx_PeriphCLKConfig+0x13b6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 810609a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810609e:	3328      	adds	r3, #40	@ 0x28
 81060a0:	2101      	movs	r1, #1
 81060a2:	4618      	mov	r0, r3
 81060a4:	f001 fa7c 	bl	81075a0 <RCCEx_PLL3_Config>
 81060a8:	4603      	mov	r3, r0
 81060aa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 81060ae:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81060b2:	2b00      	cmp	r3, #0
 81060b4:	d003      	beq.n	81060be <HAL_RCCEx_PeriphCLKConfig+0x13b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81060b6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81060ba:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 81060be:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81060c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81060c6:	2100      	movs	r1, #0
 81060c8:	6039      	str	r1, [r7, #0]
 81060ca:	f003 0320 	and.w	r3, r3, #32
 81060ce:	607b      	str	r3, [r7, #4]
 81060d0:	e9d7 1200 	ldrd	r1, r2, [r7]
 81060d4:	460b      	mov	r3, r1
 81060d6:	4313      	orrs	r3, r2
 81060d8:	d011      	beq.n	81060fe <HAL_RCCEx_PeriphCLKConfig+0x13f6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 81060da:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81060de:	3328      	adds	r3, #40	@ 0x28
 81060e0:	2102      	movs	r1, #2
 81060e2:	4618      	mov	r0, r3
 81060e4:	f001 fa5c 	bl	81075a0 <RCCEx_PLL3_Config>
 81060e8:	4603      	mov	r3, r0
 81060ea:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 81060ee:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81060f2:	2b00      	cmp	r3, #0
 81060f4:	d003      	beq.n	81060fe <HAL_RCCEx_PeriphCLKConfig+0x13f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81060f6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81060fa:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }

  if (status == HAL_OK)
 81060fe:	f897 3126 	ldrb.w	r3, [r7, #294]	@ 0x126
 8106102:	2b00      	cmp	r3, #0
 8106104:	d101      	bne.n	810610a <HAL_RCCEx_PeriphCLKConfig+0x1402>
  {
    return HAL_OK;
 8106106:	2300      	movs	r3, #0
 8106108:	e000      	b.n	810610c <HAL_RCCEx_PeriphCLKConfig+0x1404>
  }
  return HAL_ERROR;
 810610a:	2301      	movs	r3, #1
}
 810610c:	4618      	mov	r0, r3
 810610e:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 8106112:	46bd      	mov	sp, r7
 8106114:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8106118:	58024400 	.word	0x58024400

0810611c <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 810611c:	b580      	push	{r7, lr}
 810611e:	b090      	sub	sp, #64	@ 0x40
 8106120:	af00      	add	r7, sp, #0
 8106122:	e9c7 0100 	strd	r0, r1, [r7]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8106126:	e9d7 2300 	ldrd	r2, r3, [r7]
 810612a:	f5a2 7180 	sub.w	r1, r2, #256	@ 0x100
 810612e:	430b      	orrs	r3, r1
 8106130:	f040 8094 	bne.w	810625c <HAL_RCCEx_GetPeriphCLKFreq+0x140>
  {

    saiclocksource = __HAL_RCC_GET_SAI1_SOURCE();
 8106134:	4b9e      	ldr	r3, [pc, #632]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106136:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8106138:	f003 0307 	and.w	r3, r3, #7
 810613c:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 810613e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106140:	2b04      	cmp	r3, #4
 8106142:	f200 8087 	bhi.w	8106254 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
 8106146:	a201      	add	r2, pc, #4	@ (adr r2, 810614c <HAL_RCCEx_GetPeriphCLKFreq+0x30>)
 8106148:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810614c:	08106161 	.word	0x08106161
 8106150:	08106189 	.word	0x08106189
 8106154:	081061b1 	.word	0x081061b1
 8106158:	0810624d 	.word	0x0810624d
 810615c:	081061d9 	.word	0x081061d9
    {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8106160:	4b93      	ldr	r3, [pc, #588]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106162:	681b      	ldr	r3, [r3, #0]
 8106164:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8106168:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 810616c:	d108      	bne.n	8106180 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 810616e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8106172:	4618      	mov	r0, r3
 8106174:	f001 f810 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8106178:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810617a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810617c:	f000 bd45 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106180:	2300      	movs	r3, #0
 8106182:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106184:	f000 bd41 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8106188:	4b89      	ldr	r3, [pc, #548]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810618a:	681b      	ldr	r3, [r3, #0]
 810618c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106190:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106194:	d108      	bne.n	81061a8 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8106196:	f107 0318 	add.w	r3, r7, #24
 810619a:	4618      	mov	r0, r3
 810619c:	f000 fd54 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 81061a0:	69bb      	ldr	r3, [r7, #24]
 81061a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81061a4:	f000 bd31 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81061a8:	2300      	movs	r3, #0
 81061aa:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81061ac:	f000 bd2d 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 81061b0:	4b7f      	ldr	r3, [pc, #508]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81061b2:	681b      	ldr	r3, [r3, #0]
 81061b4:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 81061b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81061bc:	d108      	bne.n	81061d0 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 81061be:	f107 030c 	add.w	r3, r7, #12
 81061c2:	4618      	mov	r0, r3
 81061c4:	f000 fe94 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 81061c8:	68fb      	ldr	r3, [r7, #12]
 81061ca:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81061cc:	f000 bd1d 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81061d0:	2300      	movs	r3, #0
 81061d2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81061d4:	f000 bd19 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 81061d8:	4b75      	ldr	r3, [pc, #468]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81061da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81061dc:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 81061e0:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 81061e2:	4b73      	ldr	r3, [pc, #460]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81061e4:	681b      	ldr	r3, [r3, #0]
 81061e6:	f003 0304 	and.w	r3, r3, #4
 81061ea:	2b04      	cmp	r3, #4
 81061ec:	d10c      	bne.n	8106208 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 81061ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81061f0:	2b00      	cmp	r3, #0
 81061f2:	d109      	bne.n	8106208 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81061f4:	4b6e      	ldr	r3, [pc, #440]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81061f6:	681b      	ldr	r3, [r3, #0]
 81061f8:	08db      	lsrs	r3, r3, #3
 81061fa:	f003 0303 	and.w	r3, r3, #3
 81061fe:	4a6d      	ldr	r2, [pc, #436]	@ (81063b4 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 8106200:	fa22 f303 	lsr.w	r3, r2, r3
 8106204:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106206:	e01f      	b.n	8106248 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8106208:	4b69      	ldr	r3, [pc, #420]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810620a:	681b      	ldr	r3, [r3, #0]
 810620c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8106210:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106214:	d106      	bne.n	8106224 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
 8106216:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106218:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810621c:	d102      	bne.n	8106224 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 810621e:	4b66      	ldr	r3, [pc, #408]	@ (81063b8 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 8106220:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106222:	e011      	b.n	8106248 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8106224:	4b62      	ldr	r3, [pc, #392]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106226:	681b      	ldr	r3, [r3, #0]
 8106228:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 810622c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106230:	d106      	bne.n	8106240 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
 8106232:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106234:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106238:	d102      	bne.n	8106240 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 810623a:	4b60      	ldr	r3, [pc, #384]	@ (81063bc <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 810623c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 810623e:	e003      	b.n	8106248 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8106240:	2300      	movs	r3, #0
 8106242:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8106244:	f000 bce1 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8106248:	f000 bcdf 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 810624c:	4b5c      	ldr	r3, [pc, #368]	@ (81063c0 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 810624e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106250:	f000 bcdb 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8106254:	2300      	movs	r3, #0
 8106256:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106258:	f000 bcd7 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
 810625c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8106260:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
 8106264:	430b      	orrs	r3, r1
 8106266:	f040 80ad 	bne.w	81063c4 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>
  {

    saiclocksource = __HAL_RCC_GET_SAI23_SOURCE();
 810626a:	4b51      	ldr	r3, [pc, #324]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810626c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810626e:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
 8106272:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 8106274:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106276:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 810627a:	d056      	beq.n	810632a <HAL_RCCEx_GetPeriphCLKFreq+0x20e>
 810627c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810627e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106282:	f200 8090 	bhi.w	81063a6 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 8106286:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106288:	2bc0      	cmp	r3, #192	@ 0xc0
 810628a:	f000 8088 	beq.w	810639e <HAL_RCCEx_GetPeriphCLKFreq+0x282>
 810628e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106290:	2bc0      	cmp	r3, #192	@ 0xc0
 8106292:	f200 8088 	bhi.w	81063a6 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 8106296:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106298:	2b80      	cmp	r3, #128	@ 0x80
 810629a:	d032      	beq.n	8106302 <HAL_RCCEx_GetPeriphCLKFreq+0x1e6>
 810629c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810629e:	2b80      	cmp	r3, #128	@ 0x80
 81062a0:	f200 8081 	bhi.w	81063a6 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 81062a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81062a6:	2b00      	cmp	r3, #0
 81062a8:	d003      	beq.n	81062b2 <HAL_RCCEx_GetPeriphCLKFreq+0x196>
 81062aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81062ac:	2b40      	cmp	r3, #64	@ 0x40
 81062ae:	d014      	beq.n	81062da <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
 81062b0:	e079      	b.n	81063a6 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
    {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 81062b2:	4b3f      	ldr	r3, [pc, #252]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81062b4:	681b      	ldr	r3, [r3, #0]
 81062b6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 81062ba:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81062be:	d108      	bne.n	81062d2 <HAL_RCCEx_GetPeriphCLKFreq+0x1b6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81062c0:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 81062c4:	4618      	mov	r0, r3
 81062c6:	f000 ff67 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 81062ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81062cc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81062ce:	f000 bc9c 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81062d2:	2300      	movs	r3, #0
 81062d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81062d6:	f000 bc98 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 81062da:	4b35      	ldr	r3, [pc, #212]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81062dc:	681b      	ldr	r3, [r3, #0]
 81062de:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 81062e2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 81062e6:	d108      	bne.n	81062fa <HAL_RCCEx_GetPeriphCLKFreq+0x1de>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81062e8:	f107 0318 	add.w	r3, r7, #24
 81062ec:	4618      	mov	r0, r3
 81062ee:	f000 fcab 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 81062f2:	69bb      	ldr	r3, [r7, #24]
 81062f4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81062f6:	f000 bc88 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81062fa:	2300      	movs	r3, #0
 81062fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81062fe:	f000 bc84 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8106302:	4b2b      	ldr	r3, [pc, #172]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106304:	681b      	ldr	r3, [r3, #0]
 8106306:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 810630a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 810630e:	d108      	bne.n	8106322 <HAL_RCCEx_GetPeriphCLKFreq+0x206>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8106310:	f107 030c 	add.w	r3, r7, #12
 8106314:	4618      	mov	r0, r3
 8106316:	f000 fdeb 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 810631a:	68fb      	ldr	r3, [r7, #12]
 810631c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810631e:	f000 bc74 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106322:	2300      	movs	r3, #0
 8106324:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106326:	f000 bc70 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 810632a:	4b21      	ldr	r3, [pc, #132]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810632c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810632e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8106332:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8106334:	4b1e      	ldr	r3, [pc, #120]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106336:	681b      	ldr	r3, [r3, #0]
 8106338:	f003 0304 	and.w	r3, r3, #4
 810633c:	2b04      	cmp	r3, #4
 810633e:	d10c      	bne.n	810635a <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
 8106340:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106342:	2b00      	cmp	r3, #0
 8106344:	d109      	bne.n	810635a <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106346:	4b1a      	ldr	r3, [pc, #104]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106348:	681b      	ldr	r3, [r3, #0]
 810634a:	08db      	lsrs	r3, r3, #3
 810634c:	f003 0303 	and.w	r3, r3, #3
 8106350:	4a18      	ldr	r2, [pc, #96]	@ (81063b4 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 8106352:	fa22 f303 	lsr.w	r3, r2, r3
 8106356:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106358:	e01f      	b.n	810639a <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 810635a:	4b15      	ldr	r3, [pc, #84]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810635c:	681b      	ldr	r3, [r3, #0]
 810635e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8106362:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106366:	d106      	bne.n	8106376 <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
 8106368:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810636a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810636e:	d102      	bne.n	8106376 <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8106370:	4b11      	ldr	r3, [pc, #68]	@ (81063b8 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 8106372:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106374:	e011      	b.n	810639a <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8106376:	4b0e      	ldr	r3, [pc, #56]	@ (81063b0 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8106378:	681b      	ldr	r3, [r3, #0]
 810637a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 810637e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106382:	d106      	bne.n	8106392 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
 8106384:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106386:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 810638a:	d102      	bne.n	8106392 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 810638c:	4b0b      	ldr	r3, [pc, #44]	@ (81063bc <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 810638e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106390:	e003      	b.n	810639a <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8106392:	2300      	movs	r3, #0
 8106394:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8106396:	f000 bc38 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 810639a:	f000 bc36 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 810639e:	4b08      	ldr	r3, [pc, #32]	@ (81063c0 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 81063a0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81063a2:	f000 bc32 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 81063a6:	2300      	movs	r3, #0
 81063a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81063aa:	f000 bc2e 	b.w	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 81063ae:	bf00      	nop
 81063b0:	58024400 	.word	0x58024400
 81063b4:	03d09000 	.word	0x03d09000
 81063b8:	003d0900 	.word	0x003d0900
 81063bc:	017d7840 	.word	0x017d7840
 81063c0:	00bb8000 	.word	0x00bb8000
    }
  }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
 81063c4:	e9d7 2300 	ldrd	r2, r3, [r7]
 81063c8:	f5a2 6180 	sub.w	r1, r2, #1024	@ 0x400
 81063cc:	430b      	orrs	r3, r1
 81063ce:	f040 809c 	bne.w	810650a <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
  {

    saiclocksource = __HAL_RCC_GET_SAI4A_SOURCE();
 81063d2:	4b9e      	ldr	r3, [pc, #632]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81063d4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81063d6:	f403 0360 	and.w	r3, r3, #14680064	@ 0xe00000
 81063da:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 81063dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81063de:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 81063e2:	d054      	beq.n	810648e <HAL_RCCEx_GetPeriphCLKFreq+0x372>
 81063e4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81063e6:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 81063ea:	f200 808b 	bhi.w	8106504 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 81063ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81063f0:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 81063f4:	f000 8083 	beq.w	81064fe <HAL_RCCEx_GetPeriphCLKFreq+0x3e2>
 81063f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 81063fa:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 81063fe:	f200 8081 	bhi.w	8106504 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 8106402:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106404:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8106408:	d02f      	beq.n	810646a <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
 810640a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810640c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8106410:	d878      	bhi.n	8106504 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 8106412:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106414:	2b00      	cmp	r3, #0
 8106416:	d004      	beq.n	8106422 <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 8106418:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810641a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 810641e:	d012      	beq.n	8106446 <HAL_RCCEx_GetPeriphCLKFreq+0x32a>
 8106420:	e070      	b.n	8106504 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
    {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8106422:	4b8a      	ldr	r3, [pc, #552]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106424:	681b      	ldr	r3, [r3, #0]
 8106426:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 810642a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 810642e:	d107      	bne.n	8106440 <HAL_RCCEx_GetPeriphCLKFreq+0x324>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8106430:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8106434:	4618      	mov	r0, r3
 8106436:	f000 feaf 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 810643a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810643c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810643e:	e3e4      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106440:	2300      	movs	r3, #0
 8106442:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106444:	e3e1      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8106446:	4b81      	ldr	r3, [pc, #516]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106448:	681b      	ldr	r3, [r3, #0]
 810644a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 810644e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106452:	d107      	bne.n	8106464 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8106454:	f107 0318 	add.w	r3, r7, #24
 8106458:	4618      	mov	r0, r3
 810645a:	f000 fbf5 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 810645e:	69bb      	ldr	r3, [r7, #24]
 8106460:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106462:	e3d2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106464:	2300      	movs	r3, #0
 8106466:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106468:	e3cf      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 810646a:	4b78      	ldr	r3, [pc, #480]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 810646c:	681b      	ldr	r3, [r3, #0]
 810646e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8106472:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106476:	d107      	bne.n	8106488 <HAL_RCCEx_GetPeriphCLKFreq+0x36c>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8106478:	f107 030c 	add.w	r3, r7, #12
 810647c:	4618      	mov	r0, r3
 810647e:	f000 fd37 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8106482:	68fb      	ldr	r3, [r7, #12]
 8106484:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106486:	e3c0      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106488:	2300      	movs	r3, #0
 810648a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810648c:	e3bd      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 810648e:	4b6f      	ldr	r3, [pc, #444]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106490:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8106492:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8106496:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8106498:	4b6c      	ldr	r3, [pc, #432]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 810649a:	681b      	ldr	r3, [r3, #0]
 810649c:	f003 0304 	and.w	r3, r3, #4
 81064a0:	2b04      	cmp	r3, #4
 81064a2:	d10c      	bne.n	81064be <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
 81064a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81064a6:	2b00      	cmp	r3, #0
 81064a8:	d109      	bne.n	81064be <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81064aa:	4b68      	ldr	r3, [pc, #416]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81064ac:	681b      	ldr	r3, [r3, #0]
 81064ae:	08db      	lsrs	r3, r3, #3
 81064b0:	f003 0303 	and.w	r3, r3, #3
 81064b4:	4a66      	ldr	r2, [pc, #408]	@ (8106650 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 81064b6:	fa22 f303 	lsr.w	r3, r2, r3
 81064ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81064bc:	e01e      	b.n	81064fc <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 81064be:	4b63      	ldr	r3, [pc, #396]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81064c0:	681b      	ldr	r3, [r3, #0]
 81064c2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 81064c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81064ca:	d106      	bne.n	81064da <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
 81064cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81064ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 81064d2:	d102      	bne.n	81064da <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 81064d4:	4b5f      	ldr	r3, [pc, #380]	@ (8106654 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 81064d6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81064d8:	e010      	b.n	81064fc <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 81064da:	4b5c      	ldr	r3, [pc, #368]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81064dc:	681b      	ldr	r3, [r3, #0]
 81064de:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 81064e2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81064e6:	d106      	bne.n	81064f6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 81064e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81064ea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81064ee:	d102      	bne.n	81064f6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 81064f0:	4b59      	ldr	r3, [pc, #356]	@ (8106658 <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 81064f2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81064f4:	e002      	b.n	81064fc <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 81064f6:	2300      	movs	r3, #0
 81064f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 81064fa:	e386      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 81064fc:	e385      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 81064fe:	4b57      	ldr	r3, [pc, #348]	@ (810665c <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 8106500:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106502:	e382      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8106504:	2300      	movs	r3, #0
 8106506:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106508:	e37f      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
 810650a:	e9d7 2300 	ldrd	r2, r3, [r7]
 810650e:	f5a2 6100 	sub.w	r1, r2, #2048	@ 0x800
 8106512:	430b      	orrs	r3, r1
 8106514:	f040 80a7 	bne.w	8106666 <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
  {

    saiclocksource = __HAL_RCC_GET_SAI4B_SOURCE();
 8106518:	4b4c      	ldr	r3, [pc, #304]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 810651a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 810651c:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
 8106520:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 8106522:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106524:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8106528:	d055      	beq.n	81065d6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ba>
 810652a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810652c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8106530:	f200 8096 	bhi.w	8106660 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 8106534:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106536:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 810653a:	f000 8084 	beq.w	8106646 <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
 810653e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106540:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8106544:	f200 808c 	bhi.w	8106660 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 8106548:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810654a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 810654e:	d030      	beq.n	81065b2 <HAL_RCCEx_GetPeriphCLKFreq+0x496>
 8106550:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106552:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8106556:	f200 8083 	bhi.w	8106660 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 810655a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810655c:	2b00      	cmp	r3, #0
 810655e:	d004      	beq.n	810656a <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8106560:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8106562:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8106566:	d012      	beq.n	810658e <HAL_RCCEx_GetPeriphCLKFreq+0x472>
 8106568:	e07a      	b.n	8106660 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
    {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 810656a:	4b38      	ldr	r3, [pc, #224]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 810656c:	681b      	ldr	r3, [r3, #0]
 810656e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8106572:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8106576:	d107      	bne.n	8106588 <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8106578:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 810657c:	4618      	mov	r0, r3
 810657e:	f000 fe0b 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8106582:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8106584:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106586:	e340      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106588:	2300      	movs	r3, #0
 810658a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810658c:	e33d      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 810658e:	4b2f      	ldr	r3, [pc, #188]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106590:	681b      	ldr	r3, [r3, #0]
 8106592:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106596:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 810659a:	d107      	bne.n	81065ac <HAL_RCCEx_GetPeriphCLKFreq+0x490>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810659c:	f107 0318 	add.w	r3, r7, #24
 81065a0:	4618      	mov	r0, r3
 81065a2:	f000 fb51 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 81065a6:	69bb      	ldr	r3, [r7, #24]
 81065a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81065aa:	e32e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81065ac:	2300      	movs	r3, #0
 81065ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81065b0:	e32b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 81065b2:	4b26      	ldr	r3, [pc, #152]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81065b4:	681b      	ldr	r3, [r3, #0]
 81065b6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 81065ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81065be:	d107      	bne.n	81065d0 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 81065c0:	f107 030c 	add.w	r3, r7, #12
 81065c4:	4618      	mov	r0, r3
 81065c6:	f000 fc93 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 81065ca:	68fb      	ldr	r3, [r7, #12]
 81065cc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81065ce:	e31c      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81065d0:	2300      	movs	r3, #0
 81065d2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81065d4:	e319      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 81065d6:	4b1d      	ldr	r3, [pc, #116]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81065d8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81065da:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 81065de:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 81065e0:	4b1a      	ldr	r3, [pc, #104]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81065e2:	681b      	ldr	r3, [r3, #0]
 81065e4:	f003 0304 	and.w	r3, r3, #4
 81065e8:	2b04      	cmp	r3, #4
 81065ea:	d10c      	bne.n	8106606 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
 81065ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81065ee:	2b00      	cmp	r3, #0
 81065f0:	d109      	bne.n	8106606 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81065f2:	4b16      	ldr	r3, [pc, #88]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81065f4:	681b      	ldr	r3, [r3, #0]
 81065f6:	08db      	lsrs	r3, r3, #3
 81065f8:	f003 0303 	and.w	r3, r3, #3
 81065fc:	4a14      	ldr	r2, [pc, #80]	@ (8106650 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 81065fe:	fa22 f303 	lsr.w	r3, r2, r3
 8106602:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106604:	e01e      	b.n	8106644 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8106606:	4b11      	ldr	r3, [pc, #68]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106608:	681b      	ldr	r3, [r3, #0]
 810660a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810660e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106612:	d106      	bne.n	8106622 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
 8106614:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106616:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810661a:	d102      	bne.n	8106622 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 810661c:	4b0d      	ldr	r3, [pc, #52]	@ (8106654 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 810661e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106620:	e010      	b.n	8106644 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8106622:	4b0a      	ldr	r3, [pc, #40]	@ (810664c <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8106624:	681b      	ldr	r3, [r3, #0]
 8106626:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 810662a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 810662e:	d106      	bne.n	810663e <HAL_RCCEx_GetPeriphCLKFreq+0x522>
 8106630:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106632:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106636:	d102      	bne.n	810663e <HAL_RCCEx_GetPeriphCLKFreq+0x522>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8106638:	4b07      	ldr	r3, [pc, #28]	@ (8106658 <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 810663a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 810663c:	e002      	b.n	8106644 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 810663e:	2300      	movs	r3, #0
 8106640:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8106642:	e2e2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8106644:	e2e1      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8106646:	4b05      	ldr	r3, [pc, #20]	@ (810665c <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 8106648:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810664a:	e2de      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 810664c:	58024400 	.word	0x58024400
 8106650:	03d09000 	.word	0x03d09000
 8106654:	003d0900 	.word	0x003d0900
 8106658:	017d7840 	.word	0x017d7840
 810665c:	00bb8000 	.word	0x00bb8000
      }

      default :
      {
        frequency = 0;
 8106660:	2300      	movs	r3, #0
 8106662:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106664:	e2d1      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 8106666:	e9d7 2300 	ldrd	r2, r3, [r7]
 810666a:	f5a2 5180 	sub.w	r1, r2, #4096	@ 0x1000
 810666e:	430b      	orrs	r3, r1
 8106670:	f040 809c 	bne.w	81067ac <HAL_RCCEx_GetPeriphCLKFreq+0x690>
  {
    /* Get SPI1/2/3 clock source */
    srcclk = __HAL_RCC_GET_SPI123_SOURCE();
 8106674:	4b93      	ldr	r3, [pc, #588]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106676:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8106678:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 810667c:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 810667e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106680:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8106684:	d054      	beq.n	8106730 <HAL_RCCEx_GetPeriphCLKFreq+0x614>
 8106686:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106688:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 810668c:	f200 808b 	bhi.w	81067a6 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8106690:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106692:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8106696:	f000 8083 	beq.w	81067a0 <HAL_RCCEx_GetPeriphCLKFreq+0x684>
 810669a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810669c:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 81066a0:	f200 8081 	bhi.w	81067a6 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 81066a4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81066a6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 81066aa:	d02f      	beq.n	810670c <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>
 81066ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81066ae:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 81066b2:	d878      	bhi.n	81067a6 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 81066b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81066b6:	2b00      	cmp	r3, #0
 81066b8:	d004      	beq.n	81066c4 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
 81066ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81066bc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81066c0:	d012      	beq.n	81066e8 <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
 81066c2:	e070      	b.n	81067a6 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
    {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 81066c4:	4b7f      	ldr	r3, [pc, #508]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 81066c6:	681b      	ldr	r3, [r3, #0]
 81066c8:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 81066cc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81066d0:	d107      	bne.n	81066e2 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81066d2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 81066d6:	4618      	mov	r0, r3
 81066d8:	f000 fd5e 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 81066dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81066de:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81066e0:	e293      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81066e2:	2300      	movs	r3, #0
 81066e4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81066e6:	e290      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 81066e8:	4b76      	ldr	r3, [pc, #472]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 81066ea:	681b      	ldr	r3, [r3, #0]
 81066ec:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 81066f0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 81066f4:	d107      	bne.n	8106706 <HAL_RCCEx_GetPeriphCLKFreq+0x5ea>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81066f6:	f107 0318 	add.w	r3, r7, #24
 81066fa:	4618      	mov	r0, r3
 81066fc:	f000 faa4 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8106700:	69bb      	ldr	r3, [r7, #24]
 8106702:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106704:	e281      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106706:	2300      	movs	r3, #0
 8106708:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810670a:	e27e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 810670c:	4b6d      	ldr	r3, [pc, #436]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810670e:	681b      	ldr	r3, [r3, #0]
 8106710:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8106714:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106718:	d107      	bne.n	810672a <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810671a:	f107 030c 	add.w	r3, r7, #12
 810671e:	4618      	mov	r0, r3
 8106720:	f000 fbe6 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8106724:	68fb      	ldr	r3, [r7, #12]
 8106726:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106728:	e26f      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810672a:	2300      	movs	r3, #0
 810672c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810672e:	e26c      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8106730:	4b64      	ldr	r3, [pc, #400]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106732:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8106734:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8106738:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 810673a:	4b62      	ldr	r3, [pc, #392]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810673c:	681b      	ldr	r3, [r3, #0]
 810673e:	f003 0304 	and.w	r3, r3, #4
 8106742:	2b04      	cmp	r3, #4
 8106744:	d10c      	bne.n	8106760 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
 8106746:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106748:	2b00      	cmp	r3, #0
 810674a:	d109      	bne.n	8106760 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810674c:	4b5d      	ldr	r3, [pc, #372]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810674e:	681b      	ldr	r3, [r3, #0]
 8106750:	08db      	lsrs	r3, r3, #3
 8106752:	f003 0303 	and.w	r3, r3, #3
 8106756:	4a5c      	ldr	r2, [pc, #368]	@ (81068c8 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 8106758:	fa22 f303 	lsr.w	r3, r2, r3
 810675c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 810675e:	e01e      	b.n	810679e <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8106760:	4b58      	ldr	r3, [pc, #352]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106762:	681b      	ldr	r3, [r3, #0]
 8106764:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8106768:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 810676c:	d106      	bne.n	810677c <HAL_RCCEx_GetPeriphCLKFreq+0x660>
 810676e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106770:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8106774:	d102      	bne.n	810677c <HAL_RCCEx_GetPeriphCLKFreq+0x660>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8106776:	4b55      	ldr	r3, [pc, #340]	@ (81068cc <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 8106778:	63fb      	str	r3, [r7, #60]	@ 0x3c
 810677a:	e010      	b.n	810679e <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 810677c:	4b51      	ldr	r3, [pc, #324]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810677e:	681b      	ldr	r3, [r3, #0]
 8106780:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8106784:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106788:	d106      	bne.n	8106798 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
 810678a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810678c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106790:	d102      	bne.n	8106798 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8106792:	4b4f      	ldr	r3, [pc, #316]	@ (81068d0 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 8106794:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106796:	e002      	b.n	810679e <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8106798:	2300      	movs	r3, #0
 810679a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 810679c:	e235      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 810679e:	e234      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 81067a0:	4b4c      	ldr	r3, [pc, #304]	@ (81068d4 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
 81067a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81067a4:	e231      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 81067a6:	2300      	movs	r3, #0
 81067a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81067aa:	e22e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI45)
 81067ac:	e9d7 2300 	ldrd	r2, r3, [r7]
 81067b0:	f5a2 5100 	sub.w	r1, r2, #8192	@ 0x2000
 81067b4:	430b      	orrs	r3, r1
 81067b6:	f040 808f 	bne.w	81068d8 <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>
  {
    /* Get SPI45 clock source */
    srcclk = __HAL_RCC_GET_SPI45_SOURCE();
 81067ba:	4b42      	ldr	r3, [pc, #264]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 81067bc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81067be:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 81067c2:	63bb      	str	r3, [r7, #56]	@ 0x38
    switch (srcclk)
 81067c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067c6:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 81067ca:	d06b      	beq.n	81068a4 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
 81067cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067ce:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 81067d2:	d874      	bhi.n	81068be <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 81067d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067d6:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81067da:	d056      	beq.n	810688a <HAL_RCCEx_GetPeriphCLKFreq+0x76e>
 81067dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067de:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81067e2:	d86c      	bhi.n	81068be <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 81067e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067e6:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 81067ea:	d03b      	beq.n	8106864 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
 81067ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067ee:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 81067f2:	d864      	bhi.n	81068be <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 81067f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067f6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81067fa:	d021      	beq.n	8106840 <HAL_RCCEx_GetPeriphCLKFreq+0x724>
 81067fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81067fe:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106802:	d85c      	bhi.n	81068be <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8106804:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106806:	2b00      	cmp	r3, #0
 8106808:	d004      	beq.n	8106814 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
 810680a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810680c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8106810:	d004      	beq.n	810681c <HAL_RCCEx_GetPeriphCLKFreq+0x700>
 8106812:	e054      	b.n	81068be <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
    {
      case RCC_SPI45CLKSOURCE_PCLK2: /* CD/D2 PCLK2 is the clock source for SPI4/5 */
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 8106814:	f7fe fa20 	bl	8104c58 <HAL_RCC_GetPCLK1Freq>
 8106818:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 810681a:	e1f6      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 810681c:	4b29      	ldr	r3, [pc, #164]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810681e:	681b      	ldr	r3, [r3, #0]
 8106820:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106824:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106828:	d107      	bne.n	810683a <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810682a:	f107 0318 	add.w	r3, r7, #24
 810682e:	4618      	mov	r0, r3
 8106830:	f000 fa0a 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8106834:	69fb      	ldr	r3, [r7, #28]
 8106836:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106838:	e1e7      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810683a:	2300      	movs	r3, #0
 810683c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 810683e:	e1e4      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8106840:	4b20      	ldr	r3, [pc, #128]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106842:	681b      	ldr	r3, [r3, #0]
 8106844:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8106848:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 810684c:	d107      	bne.n	810685e <HAL_RCCEx_GetPeriphCLKFreq+0x742>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810684e:	f107 030c 	add.w	r3, r7, #12
 8106852:	4618      	mov	r0, r3
 8106854:	f000 fb4c 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8106858:	693b      	ldr	r3, [r7, #16]
 810685a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810685c:	e1d5      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810685e:	2300      	movs	r3, #0
 8106860:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106862:	e1d2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSI: /* HSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8106864:	4b17      	ldr	r3, [pc, #92]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106866:	681b      	ldr	r3, [r3, #0]
 8106868:	f003 0304 	and.w	r3, r3, #4
 810686c:	2b04      	cmp	r3, #4
 810686e:	d109      	bne.n	8106884 <HAL_RCCEx_GetPeriphCLKFreq+0x768>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106870:	4b14      	ldr	r3, [pc, #80]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8106872:	681b      	ldr	r3, [r3, #0]
 8106874:	08db      	lsrs	r3, r3, #3
 8106876:	f003 0303 	and.w	r3, r3, #3
 810687a:	4a13      	ldr	r2, [pc, #76]	@ (81068c8 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 810687c:	fa22 f303 	lsr.w	r3, r2, r3
 8106880:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106882:	e1c2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106884:	2300      	movs	r3, #0
 8106886:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106888:	e1bf      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_CSI: /* CSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 810688a:	4b0e      	ldr	r3, [pc, #56]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 810688c:	681b      	ldr	r3, [r3, #0]
 810688e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8106892:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106896:	d102      	bne.n	810689e <HAL_RCCEx_GetPeriphCLKFreq+0x782>
        {
          frequency = CSI_VALUE;
 8106898:	4b0c      	ldr	r3, [pc, #48]	@ (81068cc <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 810689a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810689c:	e1b5      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810689e:	2300      	movs	r3, #0
 81068a0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81068a2:	e1b2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSE: /* HSE is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 81068a4:	4b07      	ldr	r3, [pc, #28]	@ (81068c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 81068a6:	681b      	ldr	r3, [r3, #0]
 81068a8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 81068ac:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81068b0:	d102      	bne.n	81068b8 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>
        {
          frequency = HSE_VALUE;
 81068b2:	4b07      	ldr	r3, [pc, #28]	@ (81068d0 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 81068b4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81068b6:	e1a8      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81068b8:	2300      	movs	r3, #0
 81068ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81068bc:	e1a5      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 81068be:	2300      	movs	r3, #0
 81068c0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81068c2:	e1a2      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 81068c4:	58024400 	.word	0x58024400
 81068c8:	03d09000 	.word	0x03d09000
 81068cc:	003d0900 	.word	0x003d0900
 81068d0:	017d7840 	.word	0x017d7840
 81068d4:	00bb8000 	.word	0x00bb8000
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 81068d8:	e9d7 2300 	ldrd	r2, r3, [r7]
 81068dc:	f5a2 2100 	sub.w	r1, r2, #524288	@ 0x80000
 81068e0:	430b      	orrs	r3, r1
 81068e2:	d173      	bne.n	81069cc <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
  {
    /* Get ADC clock source */
    srcclk = __HAL_RCC_GET_ADC_SOURCE();
 81068e4:	4b9c      	ldr	r3, [pc, #624]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 81068e6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81068e8:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 81068ec:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 81068ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81068f0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81068f4:	d02f      	beq.n	8106956 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
 81068f6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81068f8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81068fc:	d863      	bhi.n	81069c6 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
 81068fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106900:	2b00      	cmp	r3, #0
 8106902:	d004      	beq.n	810690e <HAL_RCCEx_GetPeriphCLKFreq+0x7f2>
 8106904:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106906:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 810690a:	d012      	beq.n	8106932 <HAL_RCCEx_GetPeriphCLKFreq+0x816>
 810690c:	e05b      	b.n	81069c6 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
    {
      case RCC_ADCCLKSOURCE_PLL2:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 810690e:	4b92      	ldr	r3, [pc, #584]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106910:	681b      	ldr	r3, [r3, #0]
 8106912:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106916:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 810691a:	d107      	bne.n	810692c <HAL_RCCEx_GetPeriphCLKFreq+0x810>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810691c:	f107 0318 	add.w	r3, r7, #24
 8106920:	4618      	mov	r0, r3
 8106922:	f000 f991 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8106926:	69bb      	ldr	r3, [r7, #24]
 8106928:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810692a:	e16e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810692c:	2300      	movs	r3, #0
 810692e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106930:	e16b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_ADCCLKSOURCE_PLL3:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8106932:	4b89      	ldr	r3, [pc, #548]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106934:	681b      	ldr	r3, [r3, #0]
 8106936:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 810693a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 810693e:	d107      	bne.n	8106950 <HAL_RCCEx_GetPeriphCLKFreq+0x834>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8106940:	f107 030c 	add.w	r3, r7, #12
 8106944:	4618      	mov	r0, r3
 8106946:	f000 fad3 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 810694a:	697b      	ldr	r3, [r7, #20]
 810694c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810694e:	e15c      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106950:	2300      	movs	r3, #0
 8106952:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106954:	e159      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_ADCCLKSOURCE_CLKP:
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8106956:	4b80      	ldr	r3, [pc, #512]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106958:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810695a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 810695e:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8106960:	4b7d      	ldr	r3, [pc, #500]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106962:	681b      	ldr	r3, [r3, #0]
 8106964:	f003 0304 	and.w	r3, r3, #4
 8106968:	2b04      	cmp	r3, #4
 810696a:	d10c      	bne.n	8106986 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
 810696c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810696e:	2b00      	cmp	r3, #0
 8106970:	d109      	bne.n	8106986 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106972:	4b79      	ldr	r3, [pc, #484]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106974:	681b      	ldr	r3, [r3, #0]
 8106976:	08db      	lsrs	r3, r3, #3
 8106978:	f003 0303 	and.w	r3, r3, #3
 810697c:	4a77      	ldr	r2, [pc, #476]	@ (8106b5c <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 810697e:	fa22 f303 	lsr.w	r3, r2, r3
 8106982:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8106984:	e01e      	b.n	81069c4 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8106986:	4b74      	ldr	r3, [pc, #464]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106988:	681b      	ldr	r3, [r3, #0]
 810698a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810698e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106992:	d106      	bne.n	81069a2 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
 8106994:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8106996:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 810699a:	d102      	bne.n	81069a2 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 810699c:	4b70      	ldr	r3, [pc, #448]	@ (8106b60 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 810699e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81069a0:	e010      	b.n	81069c4 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 81069a2:	4b6d      	ldr	r3, [pc, #436]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 81069a4:	681b      	ldr	r3, [r3, #0]
 81069a6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 81069aa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81069ae:	d106      	bne.n	81069be <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
 81069b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81069b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81069b6:	d102      	bne.n	81069be <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 81069b8:	4b6a      	ldr	r3, [pc, #424]	@ (8106b64 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 81069ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81069bc:	e002      	b.n	81069c4 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 81069be:	2300      	movs	r3, #0
 81069c0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 81069c2:	e122      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 81069c4:	e121      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 81069c6:	2300      	movs	r3, #0
 81069c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 81069ca:	e11e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 81069cc:	e9d7 2300 	ldrd	r2, r3, [r7]
 81069d0:	f5a2 3180 	sub.w	r1, r2, #65536	@ 0x10000
 81069d4:	430b      	orrs	r3, r1
 81069d6:	d133      	bne.n	8106a40 <HAL_RCCEx_GetPeriphCLKFreq+0x924>
  {
    /* Get SDMMC clock source */
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 81069d8:	4b5f      	ldr	r3, [pc, #380]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 81069da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81069dc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 81069e0:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 81069e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81069e4:	2b00      	cmp	r3, #0
 81069e6:	d004      	beq.n	81069f2 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
 81069e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81069ea:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 81069ee:	d012      	beq.n	8106a16 <HAL_RCCEx_GetPeriphCLKFreq+0x8fa>
 81069f0:	e023      	b.n	8106a3a <HAL_RCCEx_GetPeriphCLKFreq+0x91e>
    {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 81069f2:	4b59      	ldr	r3, [pc, #356]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 81069f4:	681b      	ldr	r3, [r3, #0]
 81069f6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 81069fa:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81069fe:	d107      	bne.n	8106a10 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8106a00:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8106a04:	4618      	mov	r0, r3
 8106a06:	f000 fbc7 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8106a0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8106a0c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106a0e:	e0fc      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106a10:	2300      	movs	r3, #0
 8106a12:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106a14:	e0f9      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8106a16:	4b50      	ldr	r3, [pc, #320]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106a18:	681b      	ldr	r3, [r3, #0]
 8106a1a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106a1e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106a22:	d107      	bne.n	8106a34 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8106a24:	f107 0318 	add.w	r3, r7, #24
 8106a28:	4618      	mov	r0, r3
 8106a2a:	f000 f90d 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8106a2e:	6a3b      	ldr	r3, [r7, #32]
 8106a30:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106a32:	e0ea      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106a34:	2300      	movs	r3, #0
 8106a36:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106a38:	e0e7      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8106a3a:	2300      	movs	r3, #0
 8106a3c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106a3e:	e0e4      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 8106a40:	e9d7 2300 	ldrd	r2, r3, [r7]
 8106a44:	f5a2 4180 	sub.w	r1, r2, #16384	@ 0x4000
 8106a48:	430b      	orrs	r3, r1
 8106a4a:	f040 808d 	bne.w	8106b68 <HAL_RCCEx_GetPeriphCLKFreq+0xa4c>
  {
    /* Get SPI6 clock source */
    srcclk = __HAL_RCC_GET_SPI6_SOURCE();
 8106a4e:	4b42      	ldr	r3, [pc, #264]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106a50:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8106a52:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
 8106a56:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8106a58:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a5a:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8106a5e:	d06b      	beq.n	8106b38 <HAL_RCCEx_GetPeriphCLKFreq+0xa1c>
 8106a60:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a62:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8106a66:	d874      	bhi.n	8106b52 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8106a68:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a6a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8106a6e:	d056      	beq.n	8106b1e <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 8106a70:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a72:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8106a76:	d86c      	bhi.n	8106b52 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8106a78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a7a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8106a7e:	d03b      	beq.n	8106af8 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
 8106a80:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a82:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8106a86:	d864      	bhi.n	8106b52 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8106a88:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a8a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106a8e:	d021      	beq.n	8106ad4 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
 8106a90:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a92:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106a96:	d85c      	bhi.n	8106b52 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8106a98:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106a9a:	2b00      	cmp	r3, #0
 8106a9c:	d004      	beq.n	8106aa8 <HAL_RCCEx_GetPeriphCLKFreq+0x98c>
 8106a9e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106aa0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8106aa4:	d004      	beq.n	8106ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x994>
 8106aa6:	e054      	b.n	8106b52 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
    {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
      {
        frequency = HAL_RCCEx_GetD3PCLK1Freq();
 8106aa8:	f000 f8b8 	bl	8106c1c <HAL_RCCEx_GetD3PCLK1Freq>
 8106aac:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 8106aae:	e0ac      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8106ab0:	4b29      	ldr	r3, [pc, #164]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106ab2:	681b      	ldr	r3, [r3, #0]
 8106ab4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106ab8:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106abc:	d107      	bne.n	8106ace <HAL_RCCEx_GetPeriphCLKFreq+0x9b2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8106abe:	f107 0318 	add.w	r3, r7, #24
 8106ac2:	4618      	mov	r0, r3
 8106ac4:	f000 f8c0 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8106ac8:	69fb      	ldr	r3, [r7, #28]
 8106aca:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106acc:	e09d      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106ace:	2300      	movs	r3, #0
 8106ad0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106ad2:	e09a      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8106ad4:	4b20      	ldr	r3, [pc, #128]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106ad6:	681b      	ldr	r3, [r3, #0]
 8106ad8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8106adc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106ae0:	d107      	bne.n	8106af2 <HAL_RCCEx_GetPeriphCLKFreq+0x9d6>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8106ae2:	f107 030c 	add.w	r3, r7, #12
 8106ae6:	4618      	mov	r0, r3
 8106ae8:	f000 fa02 	bl	8106ef0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8106aec:	693b      	ldr	r3, [r7, #16]
 8106aee:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106af0:	e08b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106af2:	2300      	movs	r3, #0
 8106af4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106af6:	e088      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8106af8:	4b17      	ldr	r3, [pc, #92]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106afa:	681b      	ldr	r3, [r3, #0]
 8106afc:	f003 0304 	and.w	r3, r3, #4
 8106b00:	2b04      	cmp	r3, #4
 8106b02:	d109      	bne.n	8106b18 <HAL_RCCEx_GetPeriphCLKFreq+0x9fc>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106b04:	4b14      	ldr	r3, [pc, #80]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106b06:	681b      	ldr	r3, [r3, #0]
 8106b08:	08db      	lsrs	r3, r3, #3
 8106b0a:	f003 0303 	and.w	r3, r3, #3
 8106b0e:	4a13      	ldr	r2, [pc, #76]	@ (8106b5c <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 8106b10:	fa22 f303 	lsr.w	r3, r2, r3
 8106b14:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106b16:	e078      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106b18:	2300      	movs	r3, #0
 8106b1a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106b1c:	e075      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 8106b1e:	4b0e      	ldr	r3, [pc, #56]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106b20:	681b      	ldr	r3, [r3, #0]
 8106b22:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8106b26:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8106b2a:	d102      	bne.n	8106b32 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
        {
          frequency = CSI_VALUE;
 8106b2c:	4b0c      	ldr	r3, [pc, #48]	@ (8106b60 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 8106b2e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106b30:	e06b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106b32:	2300      	movs	r3, #0
 8106b34:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106b36:	e068      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8106b38:	4b07      	ldr	r3, [pc, #28]	@ (8106b58 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8106b3a:	681b      	ldr	r3, [r3, #0]
 8106b3c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8106b40:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106b44:	d102      	bne.n	8106b4c <HAL_RCCEx_GetPeriphCLKFreq+0xa30>
        {
          frequency = HSE_VALUE;
 8106b46:	4b07      	ldr	r3, [pc, #28]	@ (8106b64 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 8106b48:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106b4a:	e05e      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106b4c:	2300      	movs	r3, #0
 8106b4e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106b50:	e05b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
        break;
      }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
      {
        frequency = 0;
 8106b52:	2300      	movs	r3, #0
 8106b54:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106b56:	e058      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8106b58:	58024400 	.word	0x58024400
 8106b5c:	03d09000 	.word	0x03d09000
 8106b60:	003d0900 	.word	0x003d0900
 8106b64:	017d7840 	.word	0x017d7840
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
 8106b68:	e9d7 2300 	ldrd	r2, r3, [r7]
 8106b6c:	f5a2 4100 	sub.w	r1, r2, #32768	@ 0x8000
 8106b70:	430b      	orrs	r3, r1
 8106b72:	d148      	bne.n	8106c06 <HAL_RCCEx_GetPeriphCLKFreq+0xaea>
  {
    /* Get FDCAN clock source */
    srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
 8106b74:	4b27      	ldr	r3, [pc, #156]	@ (8106c14 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8106b76:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8106b78:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8106b7c:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8106b7e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106b80:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106b84:	d02a      	beq.n	8106bdc <HAL_RCCEx_GetPeriphCLKFreq+0xac0>
 8106b86:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106b88:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8106b8c:	d838      	bhi.n	8106c00 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
 8106b8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106b90:	2b00      	cmp	r3, #0
 8106b92:	d004      	beq.n	8106b9e <HAL_RCCEx_GetPeriphCLKFreq+0xa82>
 8106b94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8106b96:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8106b9a:	d00d      	beq.n	8106bb8 <HAL_RCCEx_GetPeriphCLKFreq+0xa9c>
 8106b9c:	e030      	b.n	8106c00 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
    {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8106b9e:	4b1d      	ldr	r3, [pc, #116]	@ (8106c14 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8106ba0:	681b      	ldr	r3, [r3, #0]
 8106ba2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8106ba6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8106baa:	d102      	bne.n	8106bb2 <HAL_RCCEx_GetPeriphCLKFreq+0xa96>
        {
          frequency = HSE_VALUE;
 8106bac:	4b1a      	ldr	r3, [pc, #104]	@ (8106c18 <HAL_RCCEx_GetPeriphCLKFreq+0xafc>)
 8106bae:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106bb0:	e02b      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106bb2:	2300      	movs	r3, #0
 8106bb4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106bb6:	e028      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8106bb8:	4b16      	ldr	r3, [pc, #88]	@ (8106c14 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8106bba:	681b      	ldr	r3, [r3, #0]
 8106bbc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8106bc0:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8106bc4:	d107      	bne.n	8106bd6 <HAL_RCCEx_GetPeriphCLKFreq+0xaba>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8106bc6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8106bca:	4618      	mov	r0, r3
 8106bcc:	f000 fae4 	bl	8107198 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8106bd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8106bd2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106bd4:	e019      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106bd6:	2300      	movs	r3, #0
 8106bd8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106bda:	e016      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8106bdc:	4b0d      	ldr	r3, [pc, #52]	@ (8106c14 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8106bde:	681b      	ldr	r3, [r3, #0]
 8106be0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8106be4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8106be8:	d107      	bne.n	8106bfa <HAL_RCCEx_GetPeriphCLKFreq+0xade>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8106bea:	f107 0318 	add.w	r3, r7, #24
 8106bee:	4618      	mov	r0, r3
 8106bf0:	f000 f82a 	bl	8106c48 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8106bf4:	69fb      	ldr	r3, [r7, #28]
 8106bf6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8106bf8:	e007      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8106bfa:	2300      	movs	r3, #0
 8106bfc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106bfe:	e004      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8106c00:	2300      	movs	r3, #0
 8106c02:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8106c04:	e001      	b.n	8106c0a <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else
  {
    frequency = 0;
 8106c06:	2300      	movs	r3, #0
 8106c08:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  return frequency;
 8106c0a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
}
 8106c0c:	4618      	mov	r0, r3
 8106c0e:	3740      	adds	r7, #64	@ 0x40
 8106c10:	46bd      	mov	sp, r7
 8106c12:	bd80      	pop	{r7, pc}
 8106c14:	58024400 	.word	0x58024400
 8106c18:	017d7840 	.word	0x017d7840

08106c1c <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 8106c1c:	b580      	push	{r7, lr}
 8106c1e:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 8106c20:	f7fd ffe8 	bl	8104bf4 <HAL_RCC_GetHCLKFreq>
 8106c24:	4602      	mov	r2, r0
 8106c26:	4b06      	ldr	r3, [pc, #24]	@ (8106c40 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 8106c28:	6a1b      	ldr	r3, [r3, #32]
 8106c2a:	091b      	lsrs	r3, r3, #4
 8106c2c:	f003 0307 	and.w	r3, r3, #7
 8106c30:	4904      	ldr	r1, [pc, #16]	@ (8106c44 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 8106c32:	5ccb      	ldrb	r3, [r1, r3]
 8106c34:	f003 031f 	and.w	r3, r3, #31
 8106c38:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 8106c3c:	4618      	mov	r0, r3
 8106c3e:	bd80      	pop	{r7, pc}
 8106c40:	58024400 	.word	0x58024400
 8106c44:	0810d9fc 	.word	0x0810d9fc

08106c48 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 8106c48:	b480      	push	{r7}
 8106c4a:	b089      	sub	sp, #36	@ 0x24
 8106c4c:	af00      	add	r7, sp, #0
 8106c4e:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8106c50:	4ba1      	ldr	r3, [pc, #644]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106c52:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8106c54:	f003 0303 	and.w	r3, r3, #3
 8106c58:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 8106c5a:	4b9f      	ldr	r3, [pc, #636]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106c5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8106c5e:	0b1b      	lsrs	r3, r3, #12
 8106c60:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8106c64:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8106c66:	4b9c      	ldr	r3, [pc, #624]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106c68:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8106c6a:	091b      	lsrs	r3, r3, #4
 8106c6c:	f003 0301 	and.w	r3, r3, #1
 8106c70:	613b      	str	r3, [r7, #16]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 8106c72:	4b99      	ldr	r3, [pc, #612]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106c74:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8106c76:	08db      	lsrs	r3, r3, #3
 8106c78:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8106c7c:	693a      	ldr	r2, [r7, #16]
 8106c7e:	fb02 f303 	mul.w	r3, r2, r3
 8106c82:	ee07 3a90 	vmov	s15, r3
 8106c86:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106c8a:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 8106c8e:	697b      	ldr	r3, [r7, #20]
 8106c90:	2b00      	cmp	r3, #0
 8106c92:	f000 8111 	beq.w	8106eb8 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 8106c96:	69bb      	ldr	r3, [r7, #24]
 8106c98:	2b02      	cmp	r3, #2
 8106c9a:	f000 8083 	beq.w	8106da4 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 8106c9e:	69bb      	ldr	r3, [r7, #24]
 8106ca0:	2b02      	cmp	r3, #2
 8106ca2:	f200 80a1 	bhi.w	8106de8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 8106ca6:	69bb      	ldr	r3, [r7, #24]
 8106ca8:	2b00      	cmp	r3, #0
 8106caa:	d003      	beq.n	8106cb4 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 8106cac:	69bb      	ldr	r3, [r7, #24]
 8106cae:	2b01      	cmp	r3, #1
 8106cb0:	d056      	beq.n	8106d60 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 8106cb2:	e099      	b.n	8106de8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8106cb4:	4b88      	ldr	r3, [pc, #544]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106cb6:	681b      	ldr	r3, [r3, #0]
 8106cb8:	f003 0320 	and.w	r3, r3, #32
 8106cbc:	2b00      	cmp	r3, #0
 8106cbe:	d02d      	beq.n	8106d1c <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106cc0:	4b85      	ldr	r3, [pc, #532]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106cc2:	681b      	ldr	r3, [r3, #0]
 8106cc4:	08db      	lsrs	r3, r3, #3
 8106cc6:	f003 0303 	and.w	r3, r3, #3
 8106cca:	4a84      	ldr	r2, [pc, #528]	@ (8106edc <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 8106ccc:	fa22 f303 	lsr.w	r3, r2, r3
 8106cd0:	60bb      	str	r3, [r7, #8]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8106cd2:	68bb      	ldr	r3, [r7, #8]
 8106cd4:	ee07 3a90 	vmov	s15, r3
 8106cd8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106cdc:	697b      	ldr	r3, [r7, #20]
 8106cde:	ee07 3a90 	vmov	s15, r3
 8106ce2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106ce6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106cea:	4b7b      	ldr	r3, [pc, #492]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106cec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106cee:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106cf2:	ee07 3a90 	vmov	s15, r3
 8106cf6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106cfa:	ed97 6a03 	vldr	s12, [r7, #12]
 8106cfe:	eddf 5a78 	vldr	s11, [pc, #480]	@ 8106ee0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8106d02:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106d06:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106d0a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106d0e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106d12:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106d16:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        }
        break;
 8106d1a:	e087      	b.n	8106e2c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8106d1c:	697b      	ldr	r3, [r7, #20]
 8106d1e:	ee07 3a90 	vmov	s15, r3
 8106d22:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106d26:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 8106ee4 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 8106d2a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106d2e:	4b6a      	ldr	r3, [pc, #424]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106d30:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106d32:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106d36:	ee07 3a90 	vmov	s15, r3
 8106d3a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106d3e:	ed97 6a03 	vldr	s12, [r7, #12]
 8106d42:	eddf 5a67 	vldr	s11, [pc, #412]	@ 8106ee0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8106d46:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106d4a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106d4e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106d52:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106d56:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106d5a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8106d5e:	e065      	b.n	8106e2c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8106d60:	697b      	ldr	r3, [r7, #20]
 8106d62:	ee07 3a90 	vmov	s15, r3
 8106d66:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106d6a:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8106ee8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8106d6e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106d72:	4b59      	ldr	r3, [pc, #356]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106d74:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106d76:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106d7a:	ee07 3a90 	vmov	s15, r3
 8106d7e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106d82:	ed97 6a03 	vldr	s12, [r7, #12]
 8106d86:	eddf 5a56 	vldr	s11, [pc, #344]	@ 8106ee0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8106d8a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106d8e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106d92:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106d96:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106d9a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106d9e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8106da2:	e043      	b.n	8106e2c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8106da4:	697b      	ldr	r3, [r7, #20]
 8106da6:	ee07 3a90 	vmov	s15, r3
 8106daa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106dae:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 8106eec <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 8106db2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106db6:	4b48      	ldr	r3, [pc, #288]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106db8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106dba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106dbe:	ee07 3a90 	vmov	s15, r3
 8106dc2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106dc6:	ed97 6a03 	vldr	s12, [r7, #12]
 8106dca:	eddf 5a45 	vldr	s11, [pc, #276]	@ 8106ee0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8106dce:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106dd2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106dd6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106dda:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106dde:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106de2:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8106de6:	e021      	b.n	8106e2c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8106de8:	697b      	ldr	r3, [r7, #20]
 8106dea:	ee07 3a90 	vmov	s15, r3
 8106dee:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106df2:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 8106ee8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8106df6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106dfa:	4b37      	ldr	r3, [pc, #220]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106dfc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106dfe:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106e02:	ee07 3a90 	vmov	s15, r3
 8106e06:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106e0a:	ed97 6a03 	vldr	s12, [r7, #12]
 8106e0e:	eddf 5a34 	vldr	s11, [pc, #208]	@ 8106ee0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8106e12:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106e16:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106e1a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106e1e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106e22:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106e26:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8106e2a:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 8106e2c:	4b2a      	ldr	r3, [pc, #168]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106e2e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106e30:	0a5b      	lsrs	r3, r3, #9
 8106e32:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8106e36:	ee07 3a90 	vmov	s15, r3
 8106e3a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106e3e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8106e42:	ee37 7a87 	vadd.f32	s14, s15, s14
 8106e46:	edd7 6a07 	vldr	s13, [r7, #28]
 8106e4a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8106e4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8106e52:	ee17 2a90 	vmov	r2, s15
 8106e56:	687b      	ldr	r3, [r7, #4]
 8106e58:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 8106e5a:	4b1f      	ldr	r3, [pc, #124]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106e5c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106e5e:	0c1b      	lsrs	r3, r3, #16
 8106e60:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8106e64:	ee07 3a90 	vmov	s15, r3
 8106e68:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106e6c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8106e70:	ee37 7a87 	vadd.f32	s14, s15, s14
 8106e74:	edd7 6a07 	vldr	s13, [r7, #28]
 8106e78:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8106e7c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8106e80:	ee17 2a90 	vmov	r2, s15
 8106e84:	687b      	ldr	r3, [r7, #4]
 8106e86:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 8106e88:	4b13      	ldr	r3, [pc, #76]	@ (8106ed8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8106e8a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8106e8c:	0e1b      	lsrs	r3, r3, #24
 8106e8e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8106e92:	ee07 3a90 	vmov	s15, r3
 8106e96:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106e9a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8106e9e:	ee37 7a87 	vadd.f32	s14, s15, s14
 8106ea2:	edd7 6a07 	vldr	s13, [r7, #28]
 8106ea6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8106eaa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8106eae:	ee17 2a90 	vmov	r2, s15
 8106eb2:	687b      	ldr	r3, [r7, #4]
 8106eb4:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8106eb6:	e008      	b.n	8106eca <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 8106eb8:	687b      	ldr	r3, [r7, #4]
 8106eba:	2200      	movs	r2, #0
 8106ebc:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8106ebe:	687b      	ldr	r3, [r7, #4]
 8106ec0:	2200      	movs	r2, #0
 8106ec2:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8106ec4:	687b      	ldr	r3, [r7, #4]
 8106ec6:	2200      	movs	r2, #0
 8106ec8:	609a      	str	r2, [r3, #8]
}
 8106eca:	bf00      	nop
 8106ecc:	3724      	adds	r7, #36	@ 0x24
 8106ece:	46bd      	mov	sp, r7
 8106ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106ed4:	4770      	bx	lr
 8106ed6:	bf00      	nop
 8106ed8:	58024400 	.word	0x58024400
 8106edc:	03d09000 	.word	0x03d09000
 8106ee0:	46000000 	.word	0x46000000
 8106ee4:	4c742400 	.word	0x4c742400
 8106ee8:	4a742400 	.word	0x4a742400
 8106eec:	4bbebc20 	.word	0x4bbebc20

08106ef0 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 8106ef0:	b480      	push	{r7}
 8106ef2:	b089      	sub	sp, #36	@ 0x24
 8106ef4:	af00      	add	r7, sp, #0
 8106ef6:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8106ef8:	4ba1      	ldr	r3, [pc, #644]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106efa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8106efc:	f003 0303 	and.w	r3, r3, #3
 8106f00:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 8106f02:	4b9f      	ldr	r3, [pc, #636]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f04:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8106f06:	0d1b      	lsrs	r3, r3, #20
 8106f08:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8106f0c:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 8106f0e:	4b9c      	ldr	r3, [pc, #624]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8106f12:	0a1b      	lsrs	r3, r3, #8
 8106f14:	f003 0301 	and.w	r3, r3, #1
 8106f18:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 8106f1a:	4b99      	ldr	r3, [pc, #612]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f1c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8106f1e:	08db      	lsrs	r3, r3, #3
 8106f20:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8106f24:	693a      	ldr	r2, [r7, #16]
 8106f26:	fb02 f303 	mul.w	r3, r2, r3
 8106f2a:	ee07 3a90 	vmov	s15, r3
 8106f2e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106f32:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 8106f36:	697b      	ldr	r3, [r7, #20]
 8106f38:	2b00      	cmp	r3, #0
 8106f3a:	f000 8111 	beq.w	8107160 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 8106f3e:	69bb      	ldr	r3, [r7, #24]
 8106f40:	2b02      	cmp	r3, #2
 8106f42:	f000 8083 	beq.w	810704c <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 8106f46:	69bb      	ldr	r3, [r7, #24]
 8106f48:	2b02      	cmp	r3, #2
 8106f4a:	f200 80a1 	bhi.w	8107090 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 8106f4e:	69bb      	ldr	r3, [r7, #24]
 8106f50:	2b00      	cmp	r3, #0
 8106f52:	d003      	beq.n	8106f5c <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 8106f54:	69bb      	ldr	r3, [r7, #24]
 8106f56:	2b01      	cmp	r3, #1
 8106f58:	d056      	beq.n	8107008 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 8106f5a:	e099      	b.n	8107090 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8106f5c:	4b88      	ldr	r3, [pc, #544]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f5e:	681b      	ldr	r3, [r3, #0]
 8106f60:	f003 0320 	and.w	r3, r3, #32
 8106f64:	2b00      	cmp	r3, #0
 8106f66:	d02d      	beq.n	8106fc4 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106f68:	4b85      	ldr	r3, [pc, #532]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f6a:	681b      	ldr	r3, [r3, #0]
 8106f6c:	08db      	lsrs	r3, r3, #3
 8106f6e:	f003 0303 	and.w	r3, r3, #3
 8106f72:	4a84      	ldr	r2, [pc, #528]	@ (8107184 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 8106f74:	fa22 f303 	lsr.w	r3, r2, r3
 8106f78:	60bb      	str	r3, [r7, #8]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8106f7a:	68bb      	ldr	r3, [r7, #8]
 8106f7c:	ee07 3a90 	vmov	s15, r3
 8106f80:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106f84:	697b      	ldr	r3, [r7, #20]
 8106f86:	ee07 3a90 	vmov	s15, r3
 8106f8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106f8e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106f92:	4b7b      	ldr	r3, [pc, #492]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106f94:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8106f96:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106f9a:	ee07 3a90 	vmov	s15, r3
 8106f9e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106fa2:	ed97 6a03 	vldr	s12, [r7, #12]
 8106fa6:	eddf 5a78 	vldr	s11, [pc, #480]	@ 8107188 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8106faa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106fae:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106fb2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106fb6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106fba:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106fbe:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        }
        break;
 8106fc2:	e087      	b.n	81070d4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8106fc4:	697b      	ldr	r3, [r7, #20]
 8106fc6:	ee07 3a90 	vmov	s15, r3
 8106fca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106fce:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 810718c <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 8106fd2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106fd6:	4b6a      	ldr	r3, [pc, #424]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8106fd8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8106fda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106fde:	ee07 3a90 	vmov	s15, r3
 8106fe2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106fe6:	ed97 6a03 	vldr	s12, [r7, #12]
 8106fea:	eddf 5a67 	vldr	s11, [pc, #412]	@ 8107188 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8106fee:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106ff2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106ff6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8106ffa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106ffe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107002:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8107006:	e065      	b.n	81070d4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8107008:	697b      	ldr	r3, [r7, #20]
 810700a:	ee07 3a90 	vmov	s15, r3
 810700e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107012:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8107190 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 8107016:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810701a:	4b59      	ldr	r3, [pc, #356]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 810701c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810701e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107022:	ee07 3a90 	vmov	s15, r3
 8107026:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810702a:	ed97 6a03 	vldr	s12, [r7, #12]
 810702e:	eddf 5a56 	vldr	s11, [pc, #344]	@ 8107188 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8107032:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8107036:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810703a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 810703e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107042:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107046:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810704a:	e043      	b.n	81070d4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 810704c:	697b      	ldr	r3, [r7, #20]
 810704e:	ee07 3a90 	vmov	s15, r3
 8107052:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107056:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 8107194 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 810705a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810705e:	4b48      	ldr	r3, [pc, #288]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8107060:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8107062:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107066:	ee07 3a90 	vmov	s15, r3
 810706a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810706e:	ed97 6a03 	vldr	s12, [r7, #12]
 8107072:	eddf 5a45 	vldr	s11, [pc, #276]	@ 8107188 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8107076:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810707a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810707e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8107082:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107086:	ee67 7a27 	vmul.f32	s15, s14, s15
 810708a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810708e:	e021      	b.n	81070d4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8107090:	697b      	ldr	r3, [r7, #20]
 8107092:	ee07 3a90 	vmov	s15, r3
 8107096:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810709a:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 8107190 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 810709e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81070a2:	4b37      	ldr	r3, [pc, #220]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 81070a4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 81070a6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81070aa:	ee07 3a90 	vmov	s15, r3
 81070ae:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81070b2:	ed97 6a03 	vldr	s12, [r7, #12]
 81070b6:	eddf 5a34 	vldr	s11, [pc, #208]	@ 8107188 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 81070ba:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81070be:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81070c2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 81070c6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81070ca:	ee67 7a27 	vmul.f32	s15, s14, s15
 81070ce:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81070d2:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 81070d4:	4b2a      	ldr	r3, [pc, #168]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 81070d6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 81070d8:	0a5b      	lsrs	r3, r3, #9
 81070da:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81070de:	ee07 3a90 	vmov	s15, r3
 81070e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81070e6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 81070ea:	ee37 7a87 	vadd.f32	s14, s15, s14
 81070ee:	edd7 6a07 	vldr	s13, [r7, #28]
 81070f2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81070f6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81070fa:	ee17 2a90 	vmov	r2, s15
 81070fe:	687b      	ldr	r3, [r7, #4]
 8107100:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 8107102:	4b1f      	ldr	r3, [pc, #124]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8107104:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8107106:	0c1b      	lsrs	r3, r3, #16
 8107108:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810710c:	ee07 3a90 	vmov	s15, r3
 8107110:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107114:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8107118:	ee37 7a87 	vadd.f32	s14, s15, s14
 810711c:	edd7 6a07 	vldr	s13, [r7, #28]
 8107120:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8107124:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8107128:	ee17 2a90 	vmov	r2, s15
 810712c:	687b      	ldr	r3, [r7, #4]
 810712e:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 8107130:	4b13      	ldr	r3, [pc, #76]	@ (8107180 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8107132:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8107134:	0e1b      	lsrs	r3, r3, #24
 8107136:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810713a:	ee07 3a90 	vmov	s15, r3
 810713e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107142:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8107146:	ee37 7a87 	vadd.f32	s14, s15, s14
 810714a:	edd7 6a07 	vldr	s13, [r7, #28]
 810714e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8107152:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8107156:	ee17 2a90 	vmov	r2, s15
 810715a:	687b      	ldr	r3, [r7, #4]
 810715c:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 810715e:	e008      	b.n	8107172 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 8107160:	687b      	ldr	r3, [r7, #4]
 8107162:	2200      	movs	r2, #0
 8107164:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 8107166:	687b      	ldr	r3, [r7, #4]
 8107168:	2200      	movs	r2, #0
 810716a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 810716c:	687b      	ldr	r3, [r7, #4]
 810716e:	2200      	movs	r2, #0
 8107170:	609a      	str	r2, [r3, #8]
}
 8107172:	bf00      	nop
 8107174:	3724      	adds	r7, #36	@ 0x24
 8107176:	46bd      	mov	sp, r7
 8107178:	f85d 7b04 	ldr.w	r7, [sp], #4
 810717c:	4770      	bx	lr
 810717e:	bf00      	nop
 8107180:	58024400 	.word	0x58024400
 8107184:	03d09000 	.word	0x03d09000
 8107188:	46000000 	.word	0x46000000
 810718c:	4c742400 	.word	0x4c742400
 8107190:	4a742400 	.word	0x4a742400
 8107194:	4bbebc20 	.word	0x4bbebc20

08107198 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 8107198:	b480      	push	{r7}
 810719a:	b089      	sub	sp, #36	@ 0x24
 810719c:	af00      	add	r7, sp, #0
 810719e:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 81071a0:	4ba0      	ldr	r3, [pc, #640]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81071a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81071a4:	f003 0303 	and.w	r3, r3, #3
 81071a8:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4);
 81071aa:	4b9e      	ldr	r3, [pc, #632]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81071ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81071ae:	091b      	lsrs	r3, r3, #4
 81071b0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 81071b4:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 81071b6:	4b9b      	ldr	r3, [pc, #620]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81071b8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81071ba:	f003 0301 	and.w	r3, r3, #1
 81071be:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 81071c0:	4b98      	ldr	r3, [pc, #608]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81071c2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81071c4:	08db      	lsrs	r3, r3, #3
 81071c6:	f3c3 030c 	ubfx	r3, r3, #0, #13
 81071ca:	693a      	ldr	r2, [r7, #16]
 81071cc:	fb02 f303 	mul.w	r3, r2, r3
 81071d0:	ee07 3a90 	vmov	s15, r3
 81071d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81071d8:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
 81071dc:	697b      	ldr	r3, [r7, #20]
 81071de:	2b00      	cmp	r3, #0
 81071e0:	f000 8111 	beq.w	8107406 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
 81071e4:	69bb      	ldr	r3, [r7, #24]
 81071e6:	2b02      	cmp	r3, #2
 81071e8:	f000 8083 	beq.w	81072f2 <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
 81071ec:	69bb      	ldr	r3, [r7, #24]
 81071ee:	2b02      	cmp	r3, #2
 81071f0:	f200 80a1 	bhi.w	8107336 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
 81071f4:	69bb      	ldr	r3, [r7, #24]
 81071f6:	2b00      	cmp	r3, #0
 81071f8:	d003      	beq.n	8107202 <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
 81071fa:	69bb      	ldr	r3, [r7, #24]
 81071fc:	2b01      	cmp	r3, #1
 81071fe:	d056      	beq.n	81072ae <HAL_RCCEx_GetPLL1ClockFreq+0x116>
 8107200:	e099      	b.n	8107336 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8107202:	4b88      	ldr	r3, [pc, #544]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8107204:	681b      	ldr	r3, [r3, #0]
 8107206:	f003 0320 	and.w	r3, r3, #32
 810720a:	2b00      	cmp	r3, #0
 810720c:	d02d      	beq.n	810726a <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810720e:	4b85      	ldr	r3, [pc, #532]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8107210:	681b      	ldr	r3, [r3, #0]
 8107212:	08db      	lsrs	r3, r3, #3
 8107214:	f003 0303 	and.w	r3, r3, #3
 8107218:	4a83      	ldr	r2, [pc, #524]	@ (8107428 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
 810721a:	fa22 f303 	lsr.w	r3, r2, r3
 810721e:	60bb      	str	r3, [r7, #8]
          pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8107220:	68bb      	ldr	r3, [r7, #8]
 8107222:	ee07 3a90 	vmov	s15, r3
 8107226:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810722a:	697b      	ldr	r3, [r7, #20]
 810722c:	ee07 3a90 	vmov	s15, r3
 8107230:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107234:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8107238:	4b7a      	ldr	r3, [pc, #488]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810723a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810723c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107240:	ee07 3a90 	vmov	s15, r3
 8107244:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8107248:	ed97 6a03 	vldr	s12, [r7, #12]
 810724c:	eddf 5a77 	vldr	s11, [pc, #476]	@ 810742c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8107250:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8107254:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8107258:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 810725c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107260:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107264:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
        }
        break;
 8107268:	e087      	b.n	810737a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810726a:	697b      	ldr	r3, [r7, #20]
 810726c:	ee07 3a90 	vmov	s15, r3
 8107270:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107274:	eddf 6a6e 	vldr	s13, [pc, #440]	@ 8107430 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 8107278:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810727c:	4b69      	ldr	r3, [pc, #420]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810727e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8107280:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107284:	ee07 3a90 	vmov	s15, r3
 8107288:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810728c:	ed97 6a03 	vldr	s12, [r7, #12]
 8107290:	eddf 5a66 	vldr	s11, [pc, #408]	@ 810742c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8107294:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8107298:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810729c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 81072a0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81072a4:	ee67 7a27 	vmul.f32	s15, s14, s15
 81072a8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81072ac:	e065      	b.n	810737a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81072ae:	697b      	ldr	r3, [r7, #20]
 81072b0:	ee07 3a90 	vmov	s15, r3
 81072b4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81072b8:	eddf 6a5e 	vldr	s13, [pc, #376]	@ 8107434 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
 81072bc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81072c0:	4b58      	ldr	r3, [pc, #352]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81072c2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81072c4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81072c8:	ee07 3a90 	vmov	s15, r3
 81072cc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81072d0:	ed97 6a03 	vldr	s12, [r7, #12]
 81072d4:	eddf 5a55 	vldr	s11, [pc, #340]	@ 810742c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 81072d8:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81072dc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81072e0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 81072e4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81072e8:	ee67 7a27 	vmul.f32	s15, s14, s15
 81072ec:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81072f0:	e043      	b.n	810737a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81072f2:	697b      	ldr	r3, [r7, #20]
 81072f4:	ee07 3a90 	vmov	s15, r3
 81072f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81072fc:	eddf 6a4e 	vldr	s13, [pc, #312]	@ 8107438 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
 8107300:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8107304:	4b47      	ldr	r3, [pc, #284]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8107306:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8107308:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810730c:	ee07 3a90 	vmov	s15, r3
 8107310:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8107314:	ed97 6a03 	vldr	s12, [r7, #12]
 8107318:	eddf 5a44 	vldr	s11, [pc, #272]	@ 810742c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 810731c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8107320:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8107324:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8107328:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810732c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107330:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8107334:	e021      	b.n	810737a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      default:
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8107336:	697b      	ldr	r3, [r7, #20]
 8107338:	ee07 3a90 	vmov	s15, r3
 810733c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107340:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 8107430 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 8107344:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8107348:	4b36      	ldr	r3, [pc, #216]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810734a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810734c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107350:	ee07 3a90 	vmov	s15, r3
 8107354:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8107358:	ed97 6a03 	vldr	s12, [r7, #12]
 810735c:	eddf 5a33 	vldr	s11, [pc, #204]	@ 810742c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8107360:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8107364:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8107368:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 810736c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107370:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107374:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8107378:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9)  + (float_t)1)) ;
 810737a:	4b2a      	ldr	r3, [pc, #168]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810737c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810737e:	0a5b      	lsrs	r3, r3, #9
 8107380:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8107384:	ee07 3a90 	vmov	s15, r3
 8107388:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810738c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8107390:	ee37 7a87 	vadd.f32	s14, s15, s14
 8107394:	edd7 6a07 	vldr	s13, [r7, #28]
 8107398:	eec6 7a87 	vdiv.f32	s15, s13, s14
 810739c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81073a0:	ee17 2a90 	vmov	r2, s15
 81073a4:	687b      	ldr	r3, [r7, #4]
 81073a6:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> 16) + (float_t)1)) ;
 81073a8:	4b1e      	ldr	r3, [pc, #120]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81073aa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81073ac:	0c1b      	lsrs	r3, r3, #16
 81073ae:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81073b2:	ee07 3a90 	vmov	s15, r3
 81073b6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81073ba:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 81073be:	ee37 7a87 	vadd.f32	s14, s15, s14
 81073c2:	edd7 6a07 	vldr	s13, [r7, #28]
 81073c6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81073ca:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81073ce:	ee17 2a90 	vmov	r2, s15
 81073d2:	687b      	ldr	r3, [r7, #4]
 81073d4:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> 24) + (float_t)1)) ;
 81073d6:	4b13      	ldr	r3, [pc, #76]	@ (8107424 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81073d8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81073da:	0e1b      	lsrs	r3, r3, #24
 81073dc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81073e0:	ee07 3a90 	vmov	s15, r3
 81073e4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81073e8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 81073ec:	ee37 7a87 	vadd.f32	s14, s15, s14
 81073f0:	edd7 6a07 	vldr	s13, [r7, #28]
 81073f4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81073f8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81073fc:	ee17 2a90 	vmov	r2, s15
 8107400:	687b      	ldr	r3, [r7, #4]
 8107402:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 8107404:	e008      	b.n	8107418 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 8107406:	687b      	ldr	r3, [r7, #4]
 8107408:	2200      	movs	r2, #0
 810740a:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 810740c:	687b      	ldr	r3, [r7, #4]
 810740e:	2200      	movs	r2, #0
 8107410:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 8107412:	687b      	ldr	r3, [r7, #4]
 8107414:	2200      	movs	r2, #0
 8107416:	609a      	str	r2, [r3, #8]
}
 8107418:	bf00      	nop
 810741a:	3724      	adds	r7, #36	@ 0x24
 810741c:	46bd      	mov	sp, r7
 810741e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107422:	4770      	bx	lr
 8107424:	58024400 	.word	0x58024400
 8107428:	03d09000 	.word	0x03d09000
 810742c:	46000000 	.word	0x46000000
 8107430:	4c742400 	.word	0x4c742400
 8107434:	4a742400 	.word	0x4a742400
 8107438:	4bbebc20 	.word	0x4bbebc20

0810743c <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 810743c:	b580      	push	{r7, lr}
 810743e:	b084      	sub	sp, #16
 8107440:	af00      	add	r7, sp, #0
 8107442:	6078      	str	r0, [r7, #4]
 8107444:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8107446:	2300      	movs	r3, #0
 8107448:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 810744a:	4b54      	ldr	r3, [pc, #336]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810744c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810744e:	f003 0303 	and.w	r3, r3, #3
 8107452:	2b03      	cmp	r3, #3
 8107454:	d101      	bne.n	810745a <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 8107456:	2301      	movs	r3, #1
 8107458:	e09b      	b.n	8107592 <RCCEx_PLL2_Config+0x156>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 810745a:	4b50      	ldr	r3, [pc, #320]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810745c:	681b      	ldr	r3, [r3, #0]
 810745e:	4a4f      	ldr	r2, [pc, #316]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107460:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8107464:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8107466:	f7fa fa7f 	bl	8101968 <HAL_GetTick>
 810746a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 810746c:	e008      	b.n	8107480 <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 810746e:	f7fa fa7b 	bl	8101968 <HAL_GetTick>
 8107472:	4602      	mov	r2, r0
 8107474:	68bb      	ldr	r3, [r7, #8]
 8107476:	1ad3      	subs	r3, r2, r3
 8107478:	2b02      	cmp	r3, #2
 810747a:	d901      	bls.n	8107480 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 810747c:	2303      	movs	r3, #3
 810747e:	e088      	b.n	8107592 <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8107480:	4b46      	ldr	r3, [pc, #280]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107482:	681b      	ldr	r3, [r3, #0]
 8107484:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8107488:	2b00      	cmp	r3, #0
 810748a:	d1f0      	bne.n	810746e <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 810748c:	4b43      	ldr	r3, [pc, #268]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810748e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8107490:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 8107494:	687b      	ldr	r3, [r7, #4]
 8107496:	681b      	ldr	r3, [r3, #0]
 8107498:	031b      	lsls	r3, r3, #12
 810749a:	4940      	ldr	r1, [pc, #256]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810749c:	4313      	orrs	r3, r2
 810749e:	628b      	str	r3, [r1, #40]	@ 0x28
 81074a0:	687b      	ldr	r3, [r7, #4]
 81074a2:	685b      	ldr	r3, [r3, #4]
 81074a4:	3b01      	subs	r3, #1
 81074a6:	f3c3 0208 	ubfx	r2, r3, #0, #9
 81074aa:	687b      	ldr	r3, [r7, #4]
 81074ac:	689b      	ldr	r3, [r3, #8]
 81074ae:	3b01      	subs	r3, #1
 81074b0:	025b      	lsls	r3, r3, #9
 81074b2:	b29b      	uxth	r3, r3
 81074b4:	431a      	orrs	r2, r3
 81074b6:	687b      	ldr	r3, [r7, #4]
 81074b8:	68db      	ldr	r3, [r3, #12]
 81074ba:	3b01      	subs	r3, #1
 81074bc:	041b      	lsls	r3, r3, #16
 81074be:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 81074c2:	431a      	orrs	r2, r3
 81074c4:	687b      	ldr	r3, [r7, #4]
 81074c6:	691b      	ldr	r3, [r3, #16]
 81074c8:	3b01      	subs	r3, #1
 81074ca:	061b      	lsls	r3, r3, #24
 81074cc:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 81074d0:	4932      	ldr	r1, [pc, #200]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074d2:	4313      	orrs	r3, r2
 81074d4:	638b      	str	r3, [r1, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 81074d6:	4b31      	ldr	r3, [pc, #196]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074d8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81074da:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 81074de:	687b      	ldr	r3, [r7, #4]
 81074e0:	695b      	ldr	r3, [r3, #20]
 81074e2:	492e      	ldr	r1, [pc, #184]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074e4:	4313      	orrs	r3, r2
 81074e6:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 81074e8:	4b2c      	ldr	r3, [pc, #176]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81074ec:	f023 0220 	bic.w	r2, r3, #32
 81074f0:	687b      	ldr	r3, [r7, #4]
 81074f2:	699b      	ldr	r3, [r3, #24]
 81074f4:	4929      	ldr	r1, [pc, #164]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074f6:	4313      	orrs	r3, r2
 81074f8:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 81074fa:	4b28      	ldr	r3, [pc, #160]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 81074fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81074fe:	4a27      	ldr	r2, [pc, #156]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107500:	f023 0310 	bic.w	r3, r3, #16
 8107504:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8107506:	4b25      	ldr	r3, [pc, #148]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107508:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810750a:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 810750e:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8107512:	687a      	ldr	r2, [r7, #4]
 8107514:	69d2      	ldr	r2, [r2, #28]
 8107516:	00d2      	lsls	r2, r2, #3
 8107518:	4920      	ldr	r1, [pc, #128]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810751a:	4313      	orrs	r3, r2
 810751c:	63cb      	str	r3, [r1, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 810751e:	4b1f      	ldr	r3, [pc, #124]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107520:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107522:	4a1e      	ldr	r2, [pc, #120]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107524:	f043 0310 	orr.w	r3, r3, #16
 8107528:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 810752a:	683b      	ldr	r3, [r7, #0]
 810752c:	2b00      	cmp	r3, #0
 810752e:	d106      	bne.n	810753e <RCCEx_PLL2_Config+0x102>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 8107530:	4b1a      	ldr	r3, [pc, #104]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107532:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107534:	4a19      	ldr	r2, [pc, #100]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107536:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810753a:	62d3      	str	r3, [r2, #44]	@ 0x2c
 810753c:	e00f      	b.n	810755e <RCCEx_PLL2_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 810753e:	683b      	ldr	r3, [r7, #0]
 8107540:	2b01      	cmp	r3, #1
 8107542:	d106      	bne.n	8107552 <RCCEx_PLL2_Config+0x116>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 8107544:	4b15      	ldr	r3, [pc, #84]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107546:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107548:	4a14      	ldr	r2, [pc, #80]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 810754a:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 810754e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8107550:	e005      	b.n	810755e <RCCEx_PLL2_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 8107552:	4b12      	ldr	r3, [pc, #72]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107554:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107556:	4a11      	ldr	r2, [pc, #68]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107558:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 810755c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 810755e:	4b0f      	ldr	r3, [pc, #60]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107560:	681b      	ldr	r3, [r3, #0]
 8107562:	4a0e      	ldr	r2, [pc, #56]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107564:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8107568:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 810756a:	f7fa f9fd 	bl	8101968 <HAL_GetTick>
 810756e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8107570:	e008      	b.n	8107584 <RCCEx_PLL2_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8107572:	f7fa f9f9 	bl	8101968 <HAL_GetTick>
 8107576:	4602      	mov	r2, r0
 8107578:	68bb      	ldr	r3, [r7, #8]
 810757a:	1ad3      	subs	r3, r2, r3
 810757c:	2b02      	cmp	r3, #2
 810757e:	d901      	bls.n	8107584 <RCCEx_PLL2_Config+0x148>
      {
        return HAL_TIMEOUT;
 8107580:	2303      	movs	r3, #3
 8107582:	e006      	b.n	8107592 <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8107584:	4b05      	ldr	r3, [pc, #20]	@ (810759c <RCCEx_PLL2_Config+0x160>)
 8107586:	681b      	ldr	r3, [r3, #0]
 8107588:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 810758c:	2b00      	cmp	r3, #0
 810758e:	d0f0      	beq.n	8107572 <RCCEx_PLL2_Config+0x136>
    }

  }


  return status;
 8107590:	7bfb      	ldrb	r3, [r7, #15]
}
 8107592:	4618      	mov	r0, r3
 8107594:	3710      	adds	r7, #16
 8107596:	46bd      	mov	sp, r7
 8107598:	bd80      	pop	{r7, pc}
 810759a:	bf00      	nop
 810759c:	58024400 	.word	0x58024400

081075a0 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 81075a0:	b580      	push	{r7, lr}
 81075a2:	b084      	sub	sp, #16
 81075a4:	af00      	add	r7, sp, #0
 81075a6:	6078      	str	r0, [r7, #4]
 81075a8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 81075aa:	2300      	movs	r3, #0
 81075ac:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 81075ae:	4b54      	ldr	r3, [pc, #336]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81075b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81075b2:	f003 0303 	and.w	r3, r3, #3
 81075b6:	2b03      	cmp	r3, #3
 81075b8:	d101      	bne.n	81075be <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 81075ba:	2301      	movs	r3, #1
 81075bc:	e09b      	b.n	81076f6 <RCCEx_PLL3_Config+0x156>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 81075be:	4b50      	ldr	r3, [pc, #320]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81075c0:	681b      	ldr	r3, [r3, #0]
 81075c2:	4a4f      	ldr	r2, [pc, #316]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81075c4:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 81075c8:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 81075ca:	f7fa f9cd 	bl	8101968 <HAL_GetTick>
 81075ce:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 81075d0:	e008      	b.n	81075e4 <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 81075d2:	f7fa f9c9 	bl	8101968 <HAL_GetTick>
 81075d6:	4602      	mov	r2, r0
 81075d8:	68bb      	ldr	r3, [r7, #8]
 81075da:	1ad3      	subs	r3, r2, r3
 81075dc:	2b02      	cmp	r3, #2
 81075de:	d901      	bls.n	81075e4 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 81075e0:	2303      	movs	r3, #3
 81075e2:	e088      	b.n	81076f6 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 81075e4:	4b46      	ldr	r3, [pc, #280]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81075e6:	681b      	ldr	r3, [r3, #0]
 81075e8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 81075ec:	2b00      	cmp	r3, #0
 81075ee:	d1f0      	bne.n	81075d2 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 81075f0:	4b43      	ldr	r3, [pc, #268]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81075f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81075f4:	f023 727c 	bic.w	r2, r3, #66060288	@ 0x3f00000
 81075f8:	687b      	ldr	r3, [r7, #4]
 81075fa:	681b      	ldr	r3, [r3, #0]
 81075fc:	051b      	lsls	r3, r3, #20
 81075fe:	4940      	ldr	r1, [pc, #256]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107600:	4313      	orrs	r3, r2
 8107602:	628b      	str	r3, [r1, #40]	@ 0x28
 8107604:	687b      	ldr	r3, [r7, #4]
 8107606:	685b      	ldr	r3, [r3, #4]
 8107608:	3b01      	subs	r3, #1
 810760a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 810760e:	687b      	ldr	r3, [r7, #4]
 8107610:	689b      	ldr	r3, [r3, #8]
 8107612:	3b01      	subs	r3, #1
 8107614:	025b      	lsls	r3, r3, #9
 8107616:	b29b      	uxth	r3, r3
 8107618:	431a      	orrs	r2, r3
 810761a:	687b      	ldr	r3, [r7, #4]
 810761c:	68db      	ldr	r3, [r3, #12]
 810761e:	3b01      	subs	r3, #1
 8107620:	041b      	lsls	r3, r3, #16
 8107622:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 8107626:	431a      	orrs	r2, r3
 8107628:	687b      	ldr	r3, [r7, #4]
 810762a:	691b      	ldr	r3, [r3, #16]
 810762c:	3b01      	subs	r3, #1
 810762e:	061b      	lsls	r3, r3, #24
 8107630:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 8107634:	4932      	ldr	r1, [pc, #200]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107636:	4313      	orrs	r3, r2
 8107638:	640b      	str	r3, [r1, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 810763a:	4b31      	ldr	r3, [pc, #196]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810763c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810763e:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
 8107642:	687b      	ldr	r3, [r7, #4]
 8107644:	695b      	ldr	r3, [r3, #20]
 8107646:	492e      	ldr	r1, [pc, #184]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107648:	4313      	orrs	r3, r2
 810764a:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 810764c:	4b2c      	ldr	r3, [pc, #176]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810764e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107650:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 8107654:	687b      	ldr	r3, [r7, #4]
 8107656:	699b      	ldr	r3, [r3, #24]
 8107658:	4929      	ldr	r1, [pc, #164]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810765a:	4313      	orrs	r3, r2
 810765c:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 810765e:	4b28      	ldr	r3, [pc, #160]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107660:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107662:	4a27      	ldr	r2, [pc, #156]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107664:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8107668:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 810766a:	4b25      	ldr	r3, [pc, #148]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810766c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 810766e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8107672:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8107676:	687a      	ldr	r2, [r7, #4]
 8107678:	69d2      	ldr	r2, [r2, #28]
 810767a:	00d2      	lsls	r2, r2, #3
 810767c:	4920      	ldr	r1, [pc, #128]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810767e:	4313      	orrs	r3, r2
 8107680:	644b      	str	r3, [r1, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 8107682:	4b1f      	ldr	r3, [pc, #124]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107684:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107686:	4a1e      	ldr	r2, [pc, #120]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107688:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 810768c:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 810768e:	683b      	ldr	r3, [r7, #0]
 8107690:	2b00      	cmp	r3, #0
 8107692:	d106      	bne.n	81076a2 <RCCEx_PLL3_Config+0x102>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8107694:	4b1a      	ldr	r3, [pc, #104]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 8107696:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8107698:	4a19      	ldr	r2, [pc, #100]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 810769a:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 810769e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 81076a0:	e00f      	b.n	81076c2 <RCCEx_PLL3_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 81076a2:	683b      	ldr	r3, [r7, #0]
 81076a4:	2b01      	cmp	r3, #1
 81076a6:	d106      	bne.n	81076b6 <RCCEx_PLL3_Config+0x116>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 81076a8:	4b15      	ldr	r3, [pc, #84]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81076ac:	4a14      	ldr	r2, [pc, #80]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076ae:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 81076b2:	62d3      	str	r3, [r2, #44]	@ 0x2c
 81076b4:	e005      	b.n	81076c2 <RCCEx_PLL3_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 81076b6:	4b12      	ldr	r3, [pc, #72]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076b8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81076ba:	4a11      	ldr	r2, [pc, #68]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076bc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 81076c0:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 81076c2:	4b0f      	ldr	r3, [pc, #60]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076c4:	681b      	ldr	r3, [r3, #0]
 81076c6:	4a0e      	ldr	r2, [pc, #56]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076c8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 81076cc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 81076ce:	f7fa f94b 	bl	8101968 <HAL_GetTick>
 81076d2:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 81076d4:	e008      	b.n	81076e8 <RCCEx_PLL3_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 81076d6:	f7fa f947 	bl	8101968 <HAL_GetTick>
 81076da:	4602      	mov	r2, r0
 81076dc:	68bb      	ldr	r3, [r7, #8]
 81076de:	1ad3      	subs	r3, r2, r3
 81076e0:	2b02      	cmp	r3, #2
 81076e2:	d901      	bls.n	81076e8 <RCCEx_PLL3_Config+0x148>
      {
        return HAL_TIMEOUT;
 81076e4:	2303      	movs	r3, #3
 81076e6:	e006      	b.n	81076f6 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 81076e8:	4b05      	ldr	r3, [pc, #20]	@ (8107700 <RCCEx_PLL3_Config+0x160>)
 81076ea:	681b      	ldr	r3, [r3, #0]
 81076ec:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 81076f0:	2b00      	cmp	r3, #0
 81076f2:	d0f0      	beq.n	81076d6 <RCCEx_PLL3_Config+0x136>
    }

  }


  return status;
 81076f4:	7bfb      	ldrb	r3, [r7, #15]
}
 81076f6:	4618      	mov	r0, r3
 81076f8:	3710      	adds	r7, #16
 81076fa:	46bd      	mov	sp, r7
 81076fc:	bd80      	pop	{r7, pc}
 81076fe:	bf00      	nop
 8107700:	58024400 	.word	0x58024400

08107704 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8107704:	b580      	push	{r7, lr}
 8107706:	b082      	sub	sp, #8
 8107708:	af00      	add	r7, sp, #0
 810770a:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 810770c:	687b      	ldr	r3, [r7, #4]
 810770e:	2b00      	cmp	r3, #0
 8107710:	d101      	bne.n	8107716 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8107712:	2301      	movs	r3, #1
 8107714:	e049      	b.n	81077aa <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8107716:	687b      	ldr	r3, [r7, #4]
 8107718:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 810771c:	b2db      	uxtb	r3, r3
 810771e:	2b00      	cmp	r3, #0
 8107720:	d106      	bne.n	8107730 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8107722:	687b      	ldr	r3, [r7, #4]
 8107724:	2200      	movs	r2, #0
 8107726:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 810772a:	6878      	ldr	r0, [r7, #4]
 810772c:	f000 f841 	bl	81077b2 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8107730:	687b      	ldr	r3, [r7, #4]
 8107732:	2202      	movs	r2, #2
 8107734:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8107738:	687b      	ldr	r3, [r7, #4]
 810773a:	681a      	ldr	r2, [r3, #0]
 810773c:	687b      	ldr	r3, [r7, #4]
 810773e:	3304      	adds	r3, #4
 8107740:	4619      	mov	r1, r3
 8107742:	4610      	mov	r0, r2
 8107744:	f000 f9e8 	bl	8107b18 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8107748:	687b      	ldr	r3, [r7, #4]
 810774a:	2201      	movs	r2, #1
 810774c:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8107750:	687b      	ldr	r3, [r7, #4]
 8107752:	2201      	movs	r2, #1
 8107754:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8107758:	687b      	ldr	r3, [r7, #4]
 810775a:	2201      	movs	r2, #1
 810775c:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8107760:	687b      	ldr	r3, [r7, #4]
 8107762:	2201      	movs	r2, #1
 8107764:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8107768:	687b      	ldr	r3, [r7, #4]
 810776a:	2201      	movs	r2, #1
 810776c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 8107770:	687b      	ldr	r3, [r7, #4]
 8107772:	2201      	movs	r2, #1
 8107774:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8107778:	687b      	ldr	r3, [r7, #4]
 810777a:	2201      	movs	r2, #1
 810777c:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8107780:	687b      	ldr	r3, [r7, #4]
 8107782:	2201      	movs	r2, #1
 8107784:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 8107788:	687b      	ldr	r3, [r7, #4]
 810778a:	2201      	movs	r2, #1
 810778c:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 8107790:	687b      	ldr	r3, [r7, #4]
 8107792:	2201      	movs	r2, #1
 8107794:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 8107798:	687b      	ldr	r3, [r7, #4]
 810779a:	2201      	movs	r2, #1
 810779c:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 81077a0:	687b      	ldr	r3, [r7, #4]
 81077a2:	2201      	movs	r2, #1
 81077a4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 81077a8:	2300      	movs	r3, #0
}
 81077aa:	4618      	mov	r0, r3
 81077ac:	3708      	adds	r7, #8
 81077ae:	46bd      	mov	sp, r7
 81077b0:	bd80      	pop	{r7, pc}

081077b2 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 81077b2:	b480      	push	{r7}
 81077b4:	b083      	sub	sp, #12
 81077b6:	af00      	add	r7, sp, #0
 81077b8:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 81077ba:	bf00      	nop
 81077bc:	370c      	adds	r7, #12
 81077be:	46bd      	mov	sp, r7
 81077c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81077c4:	4770      	bx	lr
	...

081077c8 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 81077c8:	b480      	push	{r7}
 81077ca:	b085      	sub	sp, #20
 81077cc:	af00      	add	r7, sp, #0
 81077ce:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 81077d0:	687b      	ldr	r3, [r7, #4]
 81077d2:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 81077d6:	b2db      	uxtb	r3, r3
 81077d8:	2b01      	cmp	r3, #1
 81077da:	d001      	beq.n	81077e0 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 81077dc:	2301      	movs	r3, #1
 81077de:	e054      	b.n	810788a <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 81077e0:	687b      	ldr	r3, [r7, #4]
 81077e2:	2202      	movs	r2, #2
 81077e4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 81077e8:	687b      	ldr	r3, [r7, #4]
 81077ea:	681b      	ldr	r3, [r3, #0]
 81077ec:	68da      	ldr	r2, [r3, #12]
 81077ee:	687b      	ldr	r3, [r7, #4]
 81077f0:	681b      	ldr	r3, [r3, #0]
 81077f2:	f042 0201 	orr.w	r2, r2, #1
 81077f6:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 81077f8:	687b      	ldr	r3, [r7, #4]
 81077fa:	681b      	ldr	r3, [r3, #0]
 81077fc:	4a26      	ldr	r2, [pc, #152]	@ (8107898 <HAL_TIM_Base_Start_IT+0xd0>)
 81077fe:	4293      	cmp	r3, r2
 8107800:	d022      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 8107802:	687b      	ldr	r3, [r7, #4]
 8107804:	681b      	ldr	r3, [r3, #0]
 8107806:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 810780a:	d01d      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 810780c:	687b      	ldr	r3, [r7, #4]
 810780e:	681b      	ldr	r3, [r3, #0]
 8107810:	4a22      	ldr	r2, [pc, #136]	@ (810789c <HAL_TIM_Base_Start_IT+0xd4>)
 8107812:	4293      	cmp	r3, r2
 8107814:	d018      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 8107816:	687b      	ldr	r3, [r7, #4]
 8107818:	681b      	ldr	r3, [r3, #0]
 810781a:	4a21      	ldr	r2, [pc, #132]	@ (81078a0 <HAL_TIM_Base_Start_IT+0xd8>)
 810781c:	4293      	cmp	r3, r2
 810781e:	d013      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 8107820:	687b      	ldr	r3, [r7, #4]
 8107822:	681b      	ldr	r3, [r3, #0]
 8107824:	4a1f      	ldr	r2, [pc, #124]	@ (81078a4 <HAL_TIM_Base_Start_IT+0xdc>)
 8107826:	4293      	cmp	r3, r2
 8107828:	d00e      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 810782a:	687b      	ldr	r3, [r7, #4]
 810782c:	681b      	ldr	r3, [r3, #0]
 810782e:	4a1e      	ldr	r2, [pc, #120]	@ (81078a8 <HAL_TIM_Base_Start_IT+0xe0>)
 8107830:	4293      	cmp	r3, r2
 8107832:	d009      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 8107834:	687b      	ldr	r3, [r7, #4]
 8107836:	681b      	ldr	r3, [r3, #0]
 8107838:	4a1c      	ldr	r2, [pc, #112]	@ (81078ac <HAL_TIM_Base_Start_IT+0xe4>)
 810783a:	4293      	cmp	r3, r2
 810783c:	d004      	beq.n	8107848 <HAL_TIM_Base_Start_IT+0x80>
 810783e:	687b      	ldr	r3, [r7, #4]
 8107840:	681b      	ldr	r3, [r3, #0]
 8107842:	4a1b      	ldr	r2, [pc, #108]	@ (81078b0 <HAL_TIM_Base_Start_IT+0xe8>)
 8107844:	4293      	cmp	r3, r2
 8107846:	d115      	bne.n	8107874 <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8107848:	687b      	ldr	r3, [r7, #4]
 810784a:	681b      	ldr	r3, [r3, #0]
 810784c:	689a      	ldr	r2, [r3, #8]
 810784e:	4b19      	ldr	r3, [pc, #100]	@ (81078b4 <HAL_TIM_Base_Start_IT+0xec>)
 8107850:	4013      	ands	r3, r2
 8107852:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8107854:	68fb      	ldr	r3, [r7, #12]
 8107856:	2b06      	cmp	r3, #6
 8107858:	d015      	beq.n	8107886 <HAL_TIM_Base_Start_IT+0xbe>
 810785a:	68fb      	ldr	r3, [r7, #12]
 810785c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8107860:	d011      	beq.n	8107886 <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
 8107862:	687b      	ldr	r3, [r7, #4]
 8107864:	681b      	ldr	r3, [r3, #0]
 8107866:	681a      	ldr	r2, [r3, #0]
 8107868:	687b      	ldr	r3, [r7, #4]
 810786a:	681b      	ldr	r3, [r3, #0]
 810786c:	f042 0201 	orr.w	r2, r2, #1
 8107870:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8107872:	e008      	b.n	8107886 <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8107874:	687b      	ldr	r3, [r7, #4]
 8107876:	681b      	ldr	r3, [r3, #0]
 8107878:	681a      	ldr	r2, [r3, #0]
 810787a:	687b      	ldr	r3, [r7, #4]
 810787c:	681b      	ldr	r3, [r3, #0]
 810787e:	f042 0201 	orr.w	r2, r2, #1
 8107882:	601a      	str	r2, [r3, #0]
 8107884:	e000      	b.n	8107888 <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8107886:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8107888:	2300      	movs	r3, #0
}
 810788a:	4618      	mov	r0, r3
 810788c:	3714      	adds	r7, #20
 810788e:	46bd      	mov	sp, r7
 8107890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107894:	4770      	bx	lr
 8107896:	bf00      	nop
 8107898:	40010000 	.word	0x40010000
 810789c:	40000400 	.word	0x40000400
 81078a0:	40000800 	.word	0x40000800
 81078a4:	40000c00 	.word	0x40000c00
 81078a8:	40010400 	.word	0x40010400
 81078ac:	40001800 	.word	0x40001800
 81078b0:	40014000 	.word	0x40014000
 81078b4:	00010007 	.word	0x00010007

081078b8 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 81078b8:	b580      	push	{r7, lr}
 81078ba:	b084      	sub	sp, #16
 81078bc:	af00      	add	r7, sp, #0
 81078be:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 81078c0:	687b      	ldr	r3, [r7, #4]
 81078c2:	681b      	ldr	r3, [r3, #0]
 81078c4:	68db      	ldr	r3, [r3, #12]
 81078c6:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 81078c8:	687b      	ldr	r3, [r7, #4]
 81078ca:	681b      	ldr	r3, [r3, #0]
 81078cc:	691b      	ldr	r3, [r3, #16]
 81078ce:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 81078d0:	68bb      	ldr	r3, [r7, #8]
 81078d2:	f003 0302 	and.w	r3, r3, #2
 81078d6:	2b00      	cmp	r3, #0
 81078d8:	d020      	beq.n	810791c <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 81078da:	68fb      	ldr	r3, [r7, #12]
 81078dc:	f003 0302 	and.w	r3, r3, #2
 81078e0:	2b00      	cmp	r3, #0
 81078e2:	d01b      	beq.n	810791c <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 81078e4:	687b      	ldr	r3, [r7, #4]
 81078e6:	681b      	ldr	r3, [r3, #0]
 81078e8:	f06f 0202 	mvn.w	r2, #2
 81078ec:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 81078ee:	687b      	ldr	r3, [r7, #4]
 81078f0:	2201      	movs	r2, #1
 81078f2:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 81078f4:	687b      	ldr	r3, [r7, #4]
 81078f6:	681b      	ldr	r3, [r3, #0]
 81078f8:	699b      	ldr	r3, [r3, #24]
 81078fa:	f003 0303 	and.w	r3, r3, #3
 81078fe:	2b00      	cmp	r3, #0
 8107900:	d003      	beq.n	810790a <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8107902:	6878      	ldr	r0, [r7, #4]
 8107904:	f000 f8e9 	bl	8107ada <HAL_TIM_IC_CaptureCallback>
 8107908:	e005      	b.n	8107916 <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 810790a:	6878      	ldr	r0, [r7, #4]
 810790c:	f000 f8db 	bl	8107ac6 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8107910:	6878      	ldr	r0, [r7, #4]
 8107912:	f000 f8ec 	bl	8107aee <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8107916:	687b      	ldr	r3, [r7, #4]
 8107918:	2200      	movs	r2, #0
 810791a:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 810791c:	68bb      	ldr	r3, [r7, #8]
 810791e:	f003 0304 	and.w	r3, r3, #4
 8107922:	2b00      	cmp	r3, #0
 8107924:	d020      	beq.n	8107968 <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8107926:	68fb      	ldr	r3, [r7, #12]
 8107928:	f003 0304 	and.w	r3, r3, #4
 810792c:	2b00      	cmp	r3, #0
 810792e:	d01b      	beq.n	8107968 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8107930:	687b      	ldr	r3, [r7, #4]
 8107932:	681b      	ldr	r3, [r3, #0]
 8107934:	f06f 0204 	mvn.w	r2, #4
 8107938:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 810793a:	687b      	ldr	r3, [r7, #4]
 810793c:	2202      	movs	r2, #2
 810793e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8107940:	687b      	ldr	r3, [r7, #4]
 8107942:	681b      	ldr	r3, [r3, #0]
 8107944:	699b      	ldr	r3, [r3, #24]
 8107946:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 810794a:	2b00      	cmp	r3, #0
 810794c:	d003      	beq.n	8107956 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 810794e:	6878      	ldr	r0, [r7, #4]
 8107950:	f000 f8c3 	bl	8107ada <HAL_TIM_IC_CaptureCallback>
 8107954:	e005      	b.n	8107962 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8107956:	6878      	ldr	r0, [r7, #4]
 8107958:	f000 f8b5 	bl	8107ac6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 810795c:	6878      	ldr	r0, [r7, #4]
 810795e:	f000 f8c6 	bl	8107aee <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8107962:	687b      	ldr	r3, [r7, #4]
 8107964:	2200      	movs	r2, #0
 8107966:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8107968:	68bb      	ldr	r3, [r7, #8]
 810796a:	f003 0308 	and.w	r3, r3, #8
 810796e:	2b00      	cmp	r3, #0
 8107970:	d020      	beq.n	81079b4 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8107972:	68fb      	ldr	r3, [r7, #12]
 8107974:	f003 0308 	and.w	r3, r3, #8
 8107978:	2b00      	cmp	r3, #0
 810797a:	d01b      	beq.n	81079b4 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 810797c:	687b      	ldr	r3, [r7, #4]
 810797e:	681b      	ldr	r3, [r3, #0]
 8107980:	f06f 0208 	mvn.w	r2, #8
 8107984:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8107986:	687b      	ldr	r3, [r7, #4]
 8107988:	2204      	movs	r2, #4
 810798a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 810798c:	687b      	ldr	r3, [r7, #4]
 810798e:	681b      	ldr	r3, [r3, #0]
 8107990:	69db      	ldr	r3, [r3, #28]
 8107992:	f003 0303 	and.w	r3, r3, #3
 8107996:	2b00      	cmp	r3, #0
 8107998:	d003      	beq.n	81079a2 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 810799a:	6878      	ldr	r0, [r7, #4]
 810799c:	f000 f89d 	bl	8107ada <HAL_TIM_IC_CaptureCallback>
 81079a0:	e005      	b.n	81079ae <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 81079a2:	6878      	ldr	r0, [r7, #4]
 81079a4:	f000 f88f 	bl	8107ac6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 81079a8:	6878      	ldr	r0, [r7, #4]
 81079aa:	f000 f8a0 	bl	8107aee <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 81079ae:	687b      	ldr	r3, [r7, #4]
 81079b0:	2200      	movs	r2, #0
 81079b2:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 81079b4:	68bb      	ldr	r3, [r7, #8]
 81079b6:	f003 0310 	and.w	r3, r3, #16
 81079ba:	2b00      	cmp	r3, #0
 81079bc:	d020      	beq.n	8107a00 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 81079be:	68fb      	ldr	r3, [r7, #12]
 81079c0:	f003 0310 	and.w	r3, r3, #16
 81079c4:	2b00      	cmp	r3, #0
 81079c6:	d01b      	beq.n	8107a00 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 81079c8:	687b      	ldr	r3, [r7, #4]
 81079ca:	681b      	ldr	r3, [r3, #0]
 81079cc:	f06f 0210 	mvn.w	r2, #16
 81079d0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 81079d2:	687b      	ldr	r3, [r7, #4]
 81079d4:	2208      	movs	r2, #8
 81079d6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 81079d8:	687b      	ldr	r3, [r7, #4]
 81079da:	681b      	ldr	r3, [r3, #0]
 81079dc:	69db      	ldr	r3, [r3, #28]
 81079de:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 81079e2:	2b00      	cmp	r3, #0
 81079e4:	d003      	beq.n	81079ee <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 81079e6:	6878      	ldr	r0, [r7, #4]
 81079e8:	f000 f877 	bl	8107ada <HAL_TIM_IC_CaptureCallback>
 81079ec:	e005      	b.n	81079fa <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 81079ee:	6878      	ldr	r0, [r7, #4]
 81079f0:	f000 f869 	bl	8107ac6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 81079f4:	6878      	ldr	r0, [r7, #4]
 81079f6:	f000 f87a 	bl	8107aee <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 81079fa:	687b      	ldr	r3, [r7, #4]
 81079fc:	2200      	movs	r2, #0
 81079fe:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8107a00:	68bb      	ldr	r3, [r7, #8]
 8107a02:	f003 0301 	and.w	r3, r3, #1
 8107a06:	2b00      	cmp	r3, #0
 8107a08:	d00c      	beq.n	8107a24 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8107a0a:	68fb      	ldr	r3, [r7, #12]
 8107a0c:	f003 0301 	and.w	r3, r3, #1
 8107a10:	2b00      	cmp	r3, #0
 8107a12:	d007      	beq.n	8107a24 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8107a14:	687b      	ldr	r3, [r7, #4]
 8107a16:	681b      	ldr	r3, [r3, #0]
 8107a18:	f06f 0201 	mvn.w	r2, #1
 8107a1c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8107a1e:	6878      	ldr	r0, [r7, #4]
 8107a20:	f7f9 fd1e 	bl	8101460 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8107a24:	68bb      	ldr	r3, [r7, #8]
 8107a26:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8107a2a:	2b00      	cmp	r3, #0
 8107a2c:	d104      	bne.n	8107a38 <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 8107a2e:	68bb      	ldr	r3, [r7, #8]
 8107a30:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8107a34:	2b00      	cmp	r3, #0
 8107a36:	d00c      	beq.n	8107a52 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8107a38:	68fb      	ldr	r3, [r7, #12]
 8107a3a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8107a3e:	2b00      	cmp	r3, #0
 8107a40:	d007      	beq.n	8107a52 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 8107a42:	687b      	ldr	r3, [r7, #4]
 8107a44:	681b      	ldr	r3, [r3, #0]
 8107a46:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 8107a4a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8107a4c:	6878      	ldr	r0, [r7, #4]
 8107a4e:	f000 f90d 	bl	8107c6c <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8107a52:	68bb      	ldr	r3, [r7, #8]
 8107a54:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8107a58:	2b00      	cmp	r3, #0
 8107a5a:	d00c      	beq.n	8107a76 <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8107a5c:	68fb      	ldr	r3, [r7, #12]
 8107a5e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8107a62:	2b00      	cmp	r3, #0
 8107a64:	d007      	beq.n	8107a76 <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8107a66:	687b      	ldr	r3, [r7, #4]
 8107a68:	681b      	ldr	r3, [r3, #0]
 8107a6a:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 8107a6e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8107a70:	6878      	ldr	r0, [r7, #4]
 8107a72:	f000 f905 	bl	8107c80 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8107a76:	68bb      	ldr	r3, [r7, #8]
 8107a78:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8107a7c:	2b00      	cmp	r3, #0
 8107a7e:	d00c      	beq.n	8107a9a <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8107a80:	68fb      	ldr	r3, [r7, #12]
 8107a82:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8107a86:	2b00      	cmp	r3, #0
 8107a88:	d007      	beq.n	8107a9a <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8107a8a:	687b      	ldr	r3, [r7, #4]
 8107a8c:	681b      	ldr	r3, [r3, #0]
 8107a8e:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 8107a92:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8107a94:	6878      	ldr	r0, [r7, #4]
 8107a96:	f000 f834 	bl	8107b02 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 8107a9a:	68bb      	ldr	r3, [r7, #8]
 8107a9c:	f003 0320 	and.w	r3, r3, #32
 8107aa0:	2b00      	cmp	r3, #0
 8107aa2:	d00c      	beq.n	8107abe <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8107aa4:	68fb      	ldr	r3, [r7, #12]
 8107aa6:	f003 0320 	and.w	r3, r3, #32
 8107aaa:	2b00      	cmp	r3, #0
 8107aac:	d007      	beq.n	8107abe <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8107aae:	687b      	ldr	r3, [r7, #4]
 8107ab0:	681b      	ldr	r3, [r3, #0]
 8107ab2:	f06f 0220 	mvn.w	r2, #32
 8107ab6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8107ab8:	6878      	ldr	r0, [r7, #4]
 8107aba:	f000 f8cd 	bl	8107c58 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8107abe:	bf00      	nop
 8107ac0:	3710      	adds	r7, #16
 8107ac2:	46bd      	mov	sp, r7
 8107ac4:	bd80      	pop	{r7, pc}

08107ac6 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8107ac6:	b480      	push	{r7}
 8107ac8:	b083      	sub	sp, #12
 8107aca:	af00      	add	r7, sp, #0
 8107acc:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8107ace:	bf00      	nop
 8107ad0:	370c      	adds	r7, #12
 8107ad2:	46bd      	mov	sp, r7
 8107ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107ad8:	4770      	bx	lr

08107ada <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8107ada:	b480      	push	{r7}
 8107adc:	b083      	sub	sp, #12
 8107ade:	af00      	add	r7, sp, #0
 8107ae0:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8107ae2:	bf00      	nop
 8107ae4:	370c      	adds	r7, #12
 8107ae6:	46bd      	mov	sp, r7
 8107ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107aec:	4770      	bx	lr

08107aee <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8107aee:	b480      	push	{r7}
 8107af0:	b083      	sub	sp, #12
 8107af2:	af00      	add	r7, sp, #0
 8107af4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8107af6:	bf00      	nop
 8107af8:	370c      	adds	r7, #12
 8107afa:	46bd      	mov	sp, r7
 8107afc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107b00:	4770      	bx	lr

08107b02 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8107b02:	b480      	push	{r7}
 8107b04:	b083      	sub	sp, #12
 8107b06:	af00      	add	r7, sp, #0
 8107b08:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8107b0a:	bf00      	nop
 8107b0c:	370c      	adds	r7, #12
 8107b0e:	46bd      	mov	sp, r7
 8107b10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107b14:	4770      	bx	lr
	...

08107b18 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8107b18:	b480      	push	{r7}
 8107b1a:	b085      	sub	sp, #20
 8107b1c:	af00      	add	r7, sp, #0
 8107b1e:	6078      	str	r0, [r7, #4]
 8107b20:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8107b22:	687b      	ldr	r3, [r7, #4]
 8107b24:	681b      	ldr	r3, [r3, #0]
 8107b26:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8107b28:	687b      	ldr	r3, [r7, #4]
 8107b2a:	4a43      	ldr	r2, [pc, #268]	@ (8107c38 <TIM_Base_SetConfig+0x120>)
 8107b2c:	4293      	cmp	r3, r2
 8107b2e:	d013      	beq.n	8107b58 <TIM_Base_SetConfig+0x40>
 8107b30:	687b      	ldr	r3, [r7, #4]
 8107b32:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8107b36:	d00f      	beq.n	8107b58 <TIM_Base_SetConfig+0x40>
 8107b38:	687b      	ldr	r3, [r7, #4]
 8107b3a:	4a40      	ldr	r2, [pc, #256]	@ (8107c3c <TIM_Base_SetConfig+0x124>)
 8107b3c:	4293      	cmp	r3, r2
 8107b3e:	d00b      	beq.n	8107b58 <TIM_Base_SetConfig+0x40>
 8107b40:	687b      	ldr	r3, [r7, #4]
 8107b42:	4a3f      	ldr	r2, [pc, #252]	@ (8107c40 <TIM_Base_SetConfig+0x128>)
 8107b44:	4293      	cmp	r3, r2
 8107b46:	d007      	beq.n	8107b58 <TIM_Base_SetConfig+0x40>
 8107b48:	687b      	ldr	r3, [r7, #4]
 8107b4a:	4a3e      	ldr	r2, [pc, #248]	@ (8107c44 <TIM_Base_SetConfig+0x12c>)
 8107b4c:	4293      	cmp	r3, r2
 8107b4e:	d003      	beq.n	8107b58 <TIM_Base_SetConfig+0x40>
 8107b50:	687b      	ldr	r3, [r7, #4]
 8107b52:	4a3d      	ldr	r2, [pc, #244]	@ (8107c48 <TIM_Base_SetConfig+0x130>)
 8107b54:	4293      	cmp	r3, r2
 8107b56:	d108      	bne.n	8107b6a <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8107b58:	68fb      	ldr	r3, [r7, #12]
 8107b5a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8107b5e:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8107b60:	683b      	ldr	r3, [r7, #0]
 8107b62:	685b      	ldr	r3, [r3, #4]
 8107b64:	68fa      	ldr	r2, [r7, #12]
 8107b66:	4313      	orrs	r3, r2
 8107b68:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8107b6a:	687b      	ldr	r3, [r7, #4]
 8107b6c:	4a32      	ldr	r2, [pc, #200]	@ (8107c38 <TIM_Base_SetConfig+0x120>)
 8107b6e:	4293      	cmp	r3, r2
 8107b70:	d01f      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b72:	687b      	ldr	r3, [r7, #4]
 8107b74:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8107b78:	d01b      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b7a:	687b      	ldr	r3, [r7, #4]
 8107b7c:	4a2f      	ldr	r2, [pc, #188]	@ (8107c3c <TIM_Base_SetConfig+0x124>)
 8107b7e:	4293      	cmp	r3, r2
 8107b80:	d017      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b82:	687b      	ldr	r3, [r7, #4]
 8107b84:	4a2e      	ldr	r2, [pc, #184]	@ (8107c40 <TIM_Base_SetConfig+0x128>)
 8107b86:	4293      	cmp	r3, r2
 8107b88:	d013      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b8a:	687b      	ldr	r3, [r7, #4]
 8107b8c:	4a2d      	ldr	r2, [pc, #180]	@ (8107c44 <TIM_Base_SetConfig+0x12c>)
 8107b8e:	4293      	cmp	r3, r2
 8107b90:	d00f      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b92:	687b      	ldr	r3, [r7, #4]
 8107b94:	4a2c      	ldr	r2, [pc, #176]	@ (8107c48 <TIM_Base_SetConfig+0x130>)
 8107b96:	4293      	cmp	r3, r2
 8107b98:	d00b      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107b9a:	687b      	ldr	r3, [r7, #4]
 8107b9c:	4a2b      	ldr	r2, [pc, #172]	@ (8107c4c <TIM_Base_SetConfig+0x134>)
 8107b9e:	4293      	cmp	r3, r2
 8107ba0:	d007      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107ba2:	687b      	ldr	r3, [r7, #4]
 8107ba4:	4a2a      	ldr	r2, [pc, #168]	@ (8107c50 <TIM_Base_SetConfig+0x138>)
 8107ba6:	4293      	cmp	r3, r2
 8107ba8:	d003      	beq.n	8107bb2 <TIM_Base_SetConfig+0x9a>
 8107baa:	687b      	ldr	r3, [r7, #4]
 8107bac:	4a29      	ldr	r2, [pc, #164]	@ (8107c54 <TIM_Base_SetConfig+0x13c>)
 8107bae:	4293      	cmp	r3, r2
 8107bb0:	d108      	bne.n	8107bc4 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8107bb2:	68fb      	ldr	r3, [r7, #12]
 8107bb4:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8107bb8:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8107bba:	683b      	ldr	r3, [r7, #0]
 8107bbc:	68db      	ldr	r3, [r3, #12]
 8107bbe:	68fa      	ldr	r2, [r7, #12]
 8107bc0:	4313      	orrs	r3, r2
 8107bc2:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8107bc4:	68fb      	ldr	r3, [r7, #12]
 8107bc6:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8107bca:	683b      	ldr	r3, [r7, #0]
 8107bcc:	695b      	ldr	r3, [r3, #20]
 8107bce:	4313      	orrs	r3, r2
 8107bd0:	60fb      	str	r3, [r7, #12]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8107bd2:	683b      	ldr	r3, [r7, #0]
 8107bd4:	689a      	ldr	r2, [r3, #8]
 8107bd6:	687b      	ldr	r3, [r7, #4]
 8107bd8:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8107bda:	683b      	ldr	r3, [r7, #0]
 8107bdc:	681a      	ldr	r2, [r3, #0]
 8107bde:	687b      	ldr	r3, [r7, #4]
 8107be0:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8107be2:	687b      	ldr	r3, [r7, #4]
 8107be4:	4a14      	ldr	r2, [pc, #80]	@ (8107c38 <TIM_Base_SetConfig+0x120>)
 8107be6:	4293      	cmp	r3, r2
 8107be8:	d00f      	beq.n	8107c0a <TIM_Base_SetConfig+0xf2>
 8107bea:	687b      	ldr	r3, [r7, #4]
 8107bec:	4a16      	ldr	r2, [pc, #88]	@ (8107c48 <TIM_Base_SetConfig+0x130>)
 8107bee:	4293      	cmp	r3, r2
 8107bf0:	d00b      	beq.n	8107c0a <TIM_Base_SetConfig+0xf2>
 8107bf2:	687b      	ldr	r3, [r7, #4]
 8107bf4:	4a15      	ldr	r2, [pc, #84]	@ (8107c4c <TIM_Base_SetConfig+0x134>)
 8107bf6:	4293      	cmp	r3, r2
 8107bf8:	d007      	beq.n	8107c0a <TIM_Base_SetConfig+0xf2>
 8107bfa:	687b      	ldr	r3, [r7, #4]
 8107bfc:	4a14      	ldr	r2, [pc, #80]	@ (8107c50 <TIM_Base_SetConfig+0x138>)
 8107bfe:	4293      	cmp	r3, r2
 8107c00:	d003      	beq.n	8107c0a <TIM_Base_SetConfig+0xf2>
 8107c02:	687b      	ldr	r3, [r7, #4]
 8107c04:	4a13      	ldr	r2, [pc, #76]	@ (8107c54 <TIM_Base_SetConfig+0x13c>)
 8107c06:	4293      	cmp	r3, r2
 8107c08:	d103      	bne.n	8107c12 <TIM_Base_SetConfig+0xfa>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8107c0a:	683b      	ldr	r3, [r7, #0]
 8107c0c:	691a      	ldr	r2, [r3, #16]
 8107c0e:	687b      	ldr	r3, [r7, #4]
 8107c10:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Disable Update Event (UEV) with Update Generation (UG)
     by changing Update Request Source (URS) to avoid Update flag (UIF) */
  SET_BIT(TIMx->CR1, TIM_CR1_URS);
 8107c12:	687b      	ldr	r3, [r7, #4]
 8107c14:	681b      	ldr	r3, [r3, #0]
 8107c16:	f043 0204 	orr.w	r2, r3, #4
 8107c1a:	687b      	ldr	r3, [r7, #4]
 8107c1c:	601a      	str	r2, [r3, #0]

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8107c1e:	687b      	ldr	r3, [r7, #4]
 8107c20:	2201      	movs	r2, #1
 8107c22:	615a      	str	r2, [r3, #20]

  TIMx->CR1 = tmpcr1;
 8107c24:	687b      	ldr	r3, [r7, #4]
 8107c26:	68fa      	ldr	r2, [r7, #12]
 8107c28:	601a      	str	r2, [r3, #0]
}
 8107c2a:	bf00      	nop
 8107c2c:	3714      	adds	r7, #20
 8107c2e:	46bd      	mov	sp, r7
 8107c30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107c34:	4770      	bx	lr
 8107c36:	bf00      	nop
 8107c38:	40010000 	.word	0x40010000
 8107c3c:	40000400 	.word	0x40000400
 8107c40:	40000800 	.word	0x40000800
 8107c44:	40000c00 	.word	0x40000c00
 8107c48:	40010400 	.word	0x40010400
 8107c4c:	40014000 	.word	0x40014000
 8107c50:	40014400 	.word	0x40014400
 8107c54:	40014800 	.word	0x40014800

08107c58 <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8107c58:	b480      	push	{r7}
 8107c5a:	b083      	sub	sp, #12
 8107c5c:	af00      	add	r7, sp, #0
 8107c5e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8107c60:	bf00      	nop
 8107c62:	370c      	adds	r7, #12
 8107c64:	46bd      	mov	sp, r7
 8107c66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107c6a:	4770      	bx	lr

08107c6c <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8107c6c:	b480      	push	{r7}
 8107c6e:	b083      	sub	sp, #12
 8107c70:	af00      	add	r7, sp, #0
 8107c72:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8107c74:	bf00      	nop
 8107c76:	370c      	adds	r7, #12
 8107c78:	46bd      	mov	sp, r7
 8107c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107c7e:	4770      	bx	lr

08107c80 <HAL_TIMEx_Break2Callback>:
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8107c80:	b480      	push	{r7}
 8107c82:	b083      	sub	sp, #12
 8107c84:	af00      	add	r7, sp, #0
 8107c86:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8107c88:	bf00      	nop
 8107c8a:	370c      	adds	r7, #12
 8107c8c:	46bd      	mov	sp, r7
 8107c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107c92:	4770      	bx	lr

08107c94 <LL_GPIO_SetPinMode>:
{
 8107c94:	b480      	push	{r7}
 8107c96:	b085      	sub	sp, #20
 8107c98:	af00      	add	r7, sp, #0
 8107c9a:	60f8      	str	r0, [r7, #12]
 8107c9c:	60b9      	str	r1, [r7, #8]
 8107c9e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODE0), ((Pin * Pin) * Mode));
 8107ca0:	68fb      	ldr	r3, [r7, #12]
 8107ca2:	6819      	ldr	r1, [r3, #0]
 8107ca4:	68bb      	ldr	r3, [r7, #8]
 8107ca6:	fb03 f203 	mul.w	r2, r3, r3
 8107caa:	4613      	mov	r3, r2
 8107cac:	005b      	lsls	r3, r3, #1
 8107cae:	4413      	add	r3, r2
 8107cb0:	43db      	mvns	r3, r3
 8107cb2:	ea01 0203 	and.w	r2, r1, r3
 8107cb6:	68bb      	ldr	r3, [r7, #8]
 8107cb8:	fb03 f303 	mul.w	r3, r3, r3
 8107cbc:	6879      	ldr	r1, [r7, #4]
 8107cbe:	fb01 f303 	mul.w	r3, r1, r3
 8107cc2:	431a      	orrs	r2, r3
 8107cc4:	68fb      	ldr	r3, [r7, #12]
 8107cc6:	601a      	str	r2, [r3, #0]
}
 8107cc8:	bf00      	nop
 8107cca:	3714      	adds	r7, #20
 8107ccc:	46bd      	mov	sp, r7
 8107cce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107cd2:	4770      	bx	lr

08107cd4 <LL_GPIO_SetPinOutputType>:
{
 8107cd4:	b480      	push	{r7}
 8107cd6:	b085      	sub	sp, #20
 8107cd8:	af00      	add	r7, sp, #0
 8107cda:	60f8      	str	r0, [r7, #12]
 8107cdc:	60b9      	str	r1, [r7, #8]
 8107cde:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8107ce0:	68fb      	ldr	r3, [r7, #12]
 8107ce2:	685a      	ldr	r2, [r3, #4]
 8107ce4:	68bb      	ldr	r3, [r7, #8]
 8107ce6:	43db      	mvns	r3, r3
 8107ce8:	401a      	ands	r2, r3
 8107cea:	68bb      	ldr	r3, [r7, #8]
 8107cec:	6879      	ldr	r1, [r7, #4]
 8107cee:	fb01 f303 	mul.w	r3, r1, r3
 8107cf2:	431a      	orrs	r2, r3
 8107cf4:	68fb      	ldr	r3, [r7, #12]
 8107cf6:	605a      	str	r2, [r3, #4]
}
 8107cf8:	bf00      	nop
 8107cfa:	3714      	adds	r7, #20
 8107cfc:	46bd      	mov	sp, r7
 8107cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107d02:	4770      	bx	lr

08107d04 <LL_GPIO_SetPinSpeed>:
{
 8107d04:	b480      	push	{r7}
 8107d06:	b085      	sub	sp, #20
 8107d08:	af00      	add	r7, sp, #0
 8107d0a:	60f8      	str	r0, [r7, #12]
 8107d0c:	60b9      	str	r1, [r7, #8]
 8107d0e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8107d10:	68fb      	ldr	r3, [r7, #12]
 8107d12:	6899      	ldr	r1, [r3, #8]
 8107d14:	68bb      	ldr	r3, [r7, #8]
 8107d16:	fb03 f203 	mul.w	r2, r3, r3
 8107d1a:	4613      	mov	r3, r2
 8107d1c:	005b      	lsls	r3, r3, #1
 8107d1e:	4413      	add	r3, r2
 8107d20:	43db      	mvns	r3, r3
 8107d22:	ea01 0203 	and.w	r2, r1, r3
 8107d26:	68bb      	ldr	r3, [r7, #8]
 8107d28:	fb03 f303 	mul.w	r3, r3, r3
 8107d2c:	6879      	ldr	r1, [r7, #4]
 8107d2e:	fb01 f303 	mul.w	r3, r1, r3
 8107d32:	431a      	orrs	r2, r3
 8107d34:	68fb      	ldr	r3, [r7, #12]
 8107d36:	609a      	str	r2, [r3, #8]
}
 8107d38:	bf00      	nop
 8107d3a:	3714      	adds	r7, #20
 8107d3c:	46bd      	mov	sp, r7
 8107d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107d42:	4770      	bx	lr

08107d44 <LL_GPIO_SetPinPull>:
{
 8107d44:	b480      	push	{r7}
 8107d46:	b085      	sub	sp, #20
 8107d48:	af00      	add	r7, sp, #0
 8107d4a:	60f8      	str	r0, [r7, #12]
 8107d4c:	60b9      	str	r1, [r7, #8]
 8107d4e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8107d50:	68fb      	ldr	r3, [r7, #12]
 8107d52:	68d9      	ldr	r1, [r3, #12]
 8107d54:	68bb      	ldr	r3, [r7, #8]
 8107d56:	fb03 f203 	mul.w	r2, r3, r3
 8107d5a:	4613      	mov	r3, r2
 8107d5c:	005b      	lsls	r3, r3, #1
 8107d5e:	4413      	add	r3, r2
 8107d60:	43db      	mvns	r3, r3
 8107d62:	ea01 0203 	and.w	r2, r1, r3
 8107d66:	68bb      	ldr	r3, [r7, #8]
 8107d68:	fb03 f303 	mul.w	r3, r3, r3
 8107d6c:	6879      	ldr	r1, [r7, #4]
 8107d6e:	fb01 f303 	mul.w	r3, r1, r3
 8107d72:	431a      	orrs	r2, r3
 8107d74:	68fb      	ldr	r3, [r7, #12]
 8107d76:	60da      	str	r2, [r3, #12]
}
 8107d78:	bf00      	nop
 8107d7a:	3714      	adds	r7, #20
 8107d7c:	46bd      	mov	sp, r7
 8107d7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107d82:	4770      	bx	lr

08107d84 <LL_GPIO_SetAFPin_0_7>:
{
 8107d84:	b480      	push	{r7}
 8107d86:	b085      	sub	sp, #20
 8107d88:	af00      	add	r7, sp, #0
 8107d8a:	60f8      	str	r0, [r7, #12]
 8107d8c:	60b9      	str	r1, [r7, #8]
 8107d8e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[0], ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
 8107d90:	68fb      	ldr	r3, [r7, #12]
 8107d92:	6a19      	ldr	r1, [r3, #32]
 8107d94:	68bb      	ldr	r3, [r7, #8]
 8107d96:	fb03 f303 	mul.w	r3, r3, r3
 8107d9a:	68ba      	ldr	r2, [r7, #8]
 8107d9c:	fb02 f303 	mul.w	r3, r2, r3
 8107da0:	68ba      	ldr	r2, [r7, #8]
 8107da2:	fb03 f202 	mul.w	r2, r3, r2
 8107da6:	4613      	mov	r3, r2
 8107da8:	011b      	lsls	r3, r3, #4
 8107daa:	1a9b      	subs	r3, r3, r2
 8107dac:	43db      	mvns	r3, r3
 8107dae:	ea01 0203 	and.w	r2, r1, r3
 8107db2:	68bb      	ldr	r3, [r7, #8]
 8107db4:	fb03 f303 	mul.w	r3, r3, r3
 8107db8:	68b9      	ldr	r1, [r7, #8]
 8107dba:	fb01 f303 	mul.w	r3, r1, r3
 8107dbe:	68b9      	ldr	r1, [r7, #8]
 8107dc0:	fb01 f303 	mul.w	r3, r1, r3
 8107dc4:	6879      	ldr	r1, [r7, #4]
 8107dc6:	fb01 f303 	mul.w	r3, r1, r3
 8107dca:	431a      	orrs	r2, r3
 8107dcc:	68fb      	ldr	r3, [r7, #12]
 8107dce:	621a      	str	r2, [r3, #32]
}
 8107dd0:	bf00      	nop
 8107dd2:	3714      	adds	r7, #20
 8107dd4:	46bd      	mov	sp, r7
 8107dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107dda:	4770      	bx	lr

08107ddc <LL_GPIO_SetAFPin_8_15>:
{
 8107ddc:	b480      	push	{r7}
 8107dde:	b085      	sub	sp, #20
 8107de0:	af00      	add	r7, sp, #0
 8107de2:	60f8      	str	r0, [r7, #12]
 8107de4:	60b9      	str	r1, [r7, #8]
 8107de6:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8107de8:	68fb      	ldr	r3, [r7, #12]
 8107dea:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8107dec:	68bb      	ldr	r3, [r7, #8]
 8107dee:	0a1b      	lsrs	r3, r3, #8
 8107df0:	68ba      	ldr	r2, [r7, #8]
 8107df2:	0a12      	lsrs	r2, r2, #8
 8107df4:	fb02 f303 	mul.w	r3, r2, r3
 8107df8:	68ba      	ldr	r2, [r7, #8]
 8107dfa:	0a12      	lsrs	r2, r2, #8
 8107dfc:	fb02 f303 	mul.w	r3, r2, r3
 8107e00:	68ba      	ldr	r2, [r7, #8]
 8107e02:	0a12      	lsrs	r2, r2, #8
 8107e04:	fb03 f202 	mul.w	r2, r3, r2
 8107e08:	4613      	mov	r3, r2
 8107e0a:	011b      	lsls	r3, r3, #4
 8107e0c:	1a9b      	subs	r3, r3, r2
 8107e0e:	43db      	mvns	r3, r3
 8107e10:	ea01 0203 	and.w	r2, r1, r3
 8107e14:	68bb      	ldr	r3, [r7, #8]
 8107e16:	0a1b      	lsrs	r3, r3, #8
 8107e18:	68b9      	ldr	r1, [r7, #8]
 8107e1a:	0a09      	lsrs	r1, r1, #8
 8107e1c:	fb01 f303 	mul.w	r3, r1, r3
 8107e20:	68b9      	ldr	r1, [r7, #8]
 8107e22:	0a09      	lsrs	r1, r1, #8
 8107e24:	fb01 f303 	mul.w	r3, r1, r3
 8107e28:	68b9      	ldr	r1, [r7, #8]
 8107e2a:	0a09      	lsrs	r1, r1, #8
 8107e2c:	fb01 f303 	mul.w	r3, r1, r3
 8107e30:	6879      	ldr	r1, [r7, #4]
 8107e32:	fb01 f303 	mul.w	r3, r1, r3
 8107e36:	431a      	orrs	r2, r3
 8107e38:	68fb      	ldr	r3, [r7, #12]
 8107e3a:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8107e3c:	bf00      	nop
 8107e3e:	3714      	adds	r7, #20
 8107e40:	46bd      	mov	sp, r7
 8107e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107e46:	4770      	bx	lr

08107e48 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8107e48:	b580      	push	{r7, lr}
 8107e4a:	b088      	sub	sp, #32
 8107e4c:	af00      	add	r7, sp, #0
 8107e4e:	6078      	str	r0, [r7, #4]
 8107e50:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8107e52:	683b      	ldr	r3, [r7, #0]
 8107e54:	681b      	ldr	r3, [r3, #0]
 8107e56:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8107e58:	693b      	ldr	r3, [r7, #16]
 8107e5a:	fa93 f3a3 	rbit	r3, r3
 8107e5e:	60fb      	str	r3, [r7, #12]
  return result;
 8107e60:	68fb      	ldr	r3, [r7, #12]
 8107e62:	617b      	str	r3, [r7, #20]
  if (value == 0U)
 8107e64:	697b      	ldr	r3, [r7, #20]
 8107e66:	2b00      	cmp	r3, #0
 8107e68:	d101      	bne.n	8107e6e <LL_GPIO_Init+0x26>
    return 32U;
 8107e6a:	2320      	movs	r3, #32
 8107e6c:	e003      	b.n	8107e76 <LL_GPIO_Init+0x2e>
  return __builtin_clz(value);
 8107e6e:	697b      	ldr	r3, [r7, #20]
 8107e70:	fab3 f383 	clz	r3, r3
 8107e74:	b2db      	uxtb	r3, r3
 8107e76:	61fb      	str	r3, [r7, #28]

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8107e78:	e048      	b.n	8107f0c <LL_GPIO_Init+0xc4>
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);
 8107e7a:	683b      	ldr	r3, [r7, #0]
 8107e7c:	681a      	ldr	r2, [r3, #0]
 8107e7e:	2101      	movs	r1, #1
 8107e80:	69fb      	ldr	r3, [r7, #28]
 8107e82:	fa01 f303 	lsl.w	r3, r1, r3
 8107e86:	4013      	ands	r3, r2
 8107e88:	61bb      	str	r3, [r7, #24]

    if (currentpin != 0x00000000U)
 8107e8a:	69bb      	ldr	r3, [r7, #24]
 8107e8c:	2b00      	cmp	r3, #0
 8107e8e:	d03a      	beq.n	8107f06 <LL_GPIO_Init+0xbe>
    {

      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8107e90:	683b      	ldr	r3, [r7, #0]
 8107e92:	685b      	ldr	r3, [r3, #4]
 8107e94:	2b01      	cmp	r3, #1
 8107e96:	d003      	beq.n	8107ea0 <LL_GPIO_Init+0x58>
 8107e98:	683b      	ldr	r3, [r7, #0]
 8107e9a:	685b      	ldr	r3, [r3, #4]
 8107e9c:	2b02      	cmp	r3, #2
 8107e9e:	d10e      	bne.n	8107ebe <LL_GPIO_Init+0x76>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));

        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 8107ea0:	683b      	ldr	r3, [r7, #0]
 8107ea2:	689b      	ldr	r3, [r3, #8]
 8107ea4:	461a      	mov	r2, r3
 8107ea6:	69b9      	ldr	r1, [r7, #24]
 8107ea8:	6878      	ldr	r0, [r7, #4]
 8107eaa:	f7ff ff2b 	bl	8107d04 <LL_GPIO_SetPinSpeed>

        /* Check Output mode parameters */
        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));

        /* Output mode configuration*/
        LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);
 8107eae:	683b      	ldr	r3, [r7, #0]
 8107eb0:	6819      	ldr	r1, [r3, #0]
 8107eb2:	683b      	ldr	r3, [r7, #0]
 8107eb4:	68db      	ldr	r3, [r3, #12]
 8107eb6:	461a      	mov	r2, r3
 8107eb8:	6878      	ldr	r0, [r7, #4]
 8107eba:	f7ff ff0b 	bl	8107cd4 <LL_GPIO_SetPinOutputType>

      }

      /* Pull-up Pull down resistor configuration*/
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 8107ebe:	683b      	ldr	r3, [r7, #0]
 8107ec0:	691b      	ldr	r3, [r3, #16]
 8107ec2:	461a      	mov	r2, r3
 8107ec4:	69b9      	ldr	r1, [r7, #24]
 8107ec6:	6878      	ldr	r0, [r7, #4]
 8107ec8:	f7ff ff3c 	bl	8107d44 <LL_GPIO_SetPinPull>

      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8107ecc:	683b      	ldr	r3, [r7, #0]
 8107ece:	685b      	ldr	r3, [r3, #4]
 8107ed0:	2b02      	cmp	r3, #2
 8107ed2:	d111      	bne.n	8107ef8 <LL_GPIO_Init+0xb0>
      {
        /* Check Alternate parameter */
        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));

        /* Alternate function configuration */
        if (currentpin < LL_GPIO_PIN_8)
 8107ed4:	69bb      	ldr	r3, [r7, #24]
 8107ed6:	2bff      	cmp	r3, #255	@ 0xff
 8107ed8:	d807      	bhi.n	8107eea <LL_GPIO_Init+0xa2>
        {
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8107eda:	683b      	ldr	r3, [r7, #0]
 8107edc:	695b      	ldr	r3, [r3, #20]
 8107ede:	461a      	mov	r2, r3
 8107ee0:	69b9      	ldr	r1, [r7, #24]
 8107ee2:	6878      	ldr	r0, [r7, #4]
 8107ee4:	f7ff ff4e 	bl	8107d84 <LL_GPIO_SetAFPin_0_7>
 8107ee8:	e006      	b.n	8107ef8 <LL_GPIO_Init+0xb0>
        }
        else
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8107eea:	683b      	ldr	r3, [r7, #0]
 8107eec:	695b      	ldr	r3, [r3, #20]
 8107eee:	461a      	mov	r2, r3
 8107ef0:	69b9      	ldr	r1, [r7, #24]
 8107ef2:	6878      	ldr	r0, [r7, #4]
 8107ef4:	f7ff ff72 	bl	8107ddc <LL_GPIO_SetAFPin_8_15>
        }
      }

      /* Pin Mode configuration */
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 8107ef8:	683b      	ldr	r3, [r7, #0]
 8107efa:	685b      	ldr	r3, [r3, #4]
 8107efc:	461a      	mov	r2, r3
 8107efe:	69b9      	ldr	r1, [r7, #24]
 8107f00:	6878      	ldr	r0, [r7, #4]
 8107f02:	f7ff fec7 	bl	8107c94 <LL_GPIO_SetPinMode>
    }
    pinpos++;
 8107f06:	69fb      	ldr	r3, [r7, #28]
 8107f08:	3301      	adds	r3, #1
 8107f0a:	61fb      	str	r3, [r7, #28]
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8107f0c:	683b      	ldr	r3, [r7, #0]
 8107f0e:	681a      	ldr	r2, [r3, #0]
 8107f10:	69fb      	ldr	r3, [r7, #28]
 8107f12:	fa22 f303 	lsr.w	r3, r2, r3
 8107f16:	2b00      	cmp	r3, #0
 8107f18:	d1af      	bne.n	8107e7a <LL_GPIO_Init+0x32>
  }

  return (SUCCESS);
 8107f1a:	2300      	movs	r3, #0
}
 8107f1c:	4618      	mov	r0, r3
 8107f1e:	3720      	adds	r7, #32
 8107f20:	46bd      	mov	sp, r7
 8107f22:	bd80      	pop	{r7, pc}

08107f24 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
 8107f24:	b480      	push	{r7}
 8107f26:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8107f28:	4b07      	ldr	r3, [pc, #28]	@ (8107f48 <LL_RCC_HSE_IsReady+0x24>)
 8107f2a:	681b      	ldr	r3, [r3, #0]
 8107f2c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8107f30:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8107f34:	d101      	bne.n	8107f3a <LL_RCC_HSE_IsReady+0x16>
 8107f36:	2301      	movs	r3, #1
 8107f38:	e000      	b.n	8107f3c <LL_RCC_HSE_IsReady+0x18>
 8107f3a:	2300      	movs	r3, #0
}
 8107f3c:	4618      	mov	r0, r3
 8107f3e:	46bd      	mov	sp, r7
 8107f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107f44:	4770      	bx	lr
 8107f46:	bf00      	nop
 8107f48:	58024400 	.word	0x58024400

08107f4c <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
 8107f4c:	b480      	push	{r7}
 8107f4e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8107f50:	4b06      	ldr	r3, [pc, #24]	@ (8107f6c <LL_RCC_HSI_IsReady+0x20>)
 8107f52:	681b      	ldr	r3, [r3, #0]
 8107f54:	f003 0304 	and.w	r3, r3, #4
 8107f58:	2b04      	cmp	r3, #4
 8107f5a:	d101      	bne.n	8107f60 <LL_RCC_HSI_IsReady+0x14>
 8107f5c:	2301      	movs	r3, #1
 8107f5e:	e000      	b.n	8107f62 <LL_RCC_HSI_IsReady+0x16>
 8107f60:	2300      	movs	r3, #0
}
 8107f62:	4618      	mov	r0, r3
 8107f64:	46bd      	mov	sp, r7
 8107f66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107f6a:	4770      	bx	lr
 8107f6c:	58024400 	.word	0x58024400

08107f70 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV2
  *         @arg @ref LL_RCC_HSI_DIV4
  *         @arg @ref LL_RCC_HSI_DIV8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
 8107f70:	b480      	push	{r7}
 8107f72:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8107f74:	4b04      	ldr	r3, [pc, #16]	@ (8107f88 <LL_RCC_HSI_GetDivider+0x18>)
 8107f76:	681b      	ldr	r3, [r3, #0]
 8107f78:	f003 0318 	and.w	r3, r3, #24
}
 8107f7c:	4618      	mov	r0, r3
 8107f7e:	46bd      	mov	sp, r7
 8107f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107f84:	4770      	bx	lr
 8107f86:	bf00      	nop
 8107f88:	58024400 	.word	0x58024400

08107f8c <LL_RCC_CSI_IsReady>:
  * @brief  Check if CSI clock is ready
  * @rmtoll CR           CSIRDY        LL_RCC_CSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CSI_IsReady(void)
{
 8107f8c:	b480      	push	{r7}
 8107f8e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 8107f90:	4b07      	ldr	r3, [pc, #28]	@ (8107fb0 <LL_RCC_CSI_IsReady+0x24>)
 8107f92:	681b      	ldr	r3, [r3, #0]
 8107f94:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8107f98:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8107f9c:	d101      	bne.n	8107fa2 <LL_RCC_CSI_IsReady+0x16>
 8107f9e:	2301      	movs	r3, #1
 8107fa0:	e000      	b.n	8107fa4 <LL_RCC_CSI_IsReady+0x18>
 8107fa2:	2300      	movs	r3, #0
}
 8107fa4:	4618      	mov	r0, r3
 8107fa6:	46bd      	mov	sp, r7
 8107fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107fac:	4770      	bx	lr
 8107fae:	bf00      	nop
 8107fb0:	58024400 	.word	0x58024400

08107fb4 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll BDCR         LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
 8107fb4:	b480      	push	{r7}
 8107fb6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8107fb8:	4b06      	ldr	r3, [pc, #24]	@ (8107fd4 <LL_RCC_LSE_IsReady+0x20>)
 8107fba:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8107fbc:	f003 0302 	and.w	r3, r3, #2
 8107fc0:	2b02      	cmp	r3, #2
 8107fc2:	d101      	bne.n	8107fc8 <LL_RCC_LSE_IsReady+0x14>
 8107fc4:	2301      	movs	r3, #1
 8107fc6:	e000      	b.n	8107fca <LL_RCC_LSE_IsReady+0x16>
 8107fc8:	2300      	movs	r3, #0
}
 8107fca:	4618      	mov	r0, r3
 8107fcc:	46bd      	mov	sp, r7
 8107fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107fd2:	4770      	bx	lr
 8107fd4:	58024400 	.word	0x58024400

08107fd8 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_CSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL1
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
 8107fd8:	b480      	push	{r7}
 8107fda:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8107fdc:	4b04      	ldr	r3, [pc, #16]	@ (8107ff0 <LL_RCC_GetSysClkSource+0x18>)
 8107fde:	691b      	ldr	r3, [r3, #16]
 8107fe0:	f003 0338 	and.w	r3, r3, #56	@ 0x38
}
 8107fe4:	4618      	mov	r0, r3
 8107fe6:	46bd      	mov	sp, r7
 8107fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107fec:	4770      	bx	lr
 8107fee:	bf00      	nop
 8107ff0:	58024400 	.word	0x58024400

08107ff4 <LL_RCC_GetSysPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysPrescaler(void)
{
 8107ff4:	b480      	push	{r7}
 8107ff6:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1CPRE)
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_D1CPRE));
 8107ff8:	4b04      	ldr	r3, [pc, #16]	@ (810800c <LL_RCC_GetSysPrescaler+0x18>)
 8107ffa:	699b      	ldr	r3, [r3, #24]
 8107ffc:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
#else
  return (uint32_t)(READ_BIT(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE));
#endif /* RCC_D1CFGR_D1CPRE */
}
 8108000:	4618      	mov	r0, r3
 8108002:	46bd      	mov	sp, r7
 8108004:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108008:	4770      	bx	lr
 810800a:	bf00      	nop
 810800c:	58024400 	.word	0x58024400

08108010 <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_AHB_DIV_128
  *         @arg @ref LL_RCC_AHB_DIV_256
  *         @arg @ref LL_RCC_AHB_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
 8108010:	b480      	push	{r7}
 8108012:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_HPRE)
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
 8108014:	4b04      	ldr	r3, [pc, #16]	@ (8108028 <LL_RCC_GetAHBPrescaler+0x18>)
 8108016:	699b      	ldr	r3, [r3, #24]
 8108018:	f003 030f 	and.w	r3, r3, #15
#else
  return (uint32_t)(READ_BIT(RCC->CDCFGR1, RCC_CDCFGR1_HPRE));
#endif /* RCC_D1CFGR_HPRE */
}
 810801c:	4618      	mov	r0, r3
 810801e:	46bd      	mov	sp, r7
 8108020:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108024:	4770      	bx	lr
 8108026:	bf00      	nop
 8108028:	58024400 	.word	0x58024400

0810802c <LL_RCC_GetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_4
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
 810802c:	b480      	push	{r7}
 810802e:	af00      	add	r7, sp, #0
#if defined(RCC_D2CFGR_D2PPRE1)
  return (uint32_t)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1));
 8108030:	4b04      	ldr	r3, [pc, #16]	@ (8108044 <LL_RCC_GetAPB1Prescaler+0x18>)
 8108032:	69db      	ldr	r3, [r3, #28]
 8108034:	f003 0370 	and.w	r3, r3, #112	@ 0x70
#else
  return (uint32_t)(READ_BIT(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1));
#endif /* RCC_D2CFGR_D2PPRE1 */
}
 8108038:	4618      	mov	r0, r3
 810803a:	46bd      	mov	sp, r7
 810803c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108040:	4770      	bx	lr
 8108042:	bf00      	nop
 8108044:	58024400 	.word	0x58024400

08108048 <LL_RCC_GetAPB2Prescaler>:
  *         @arg @ref LL_RCC_APB2_DIV_4
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
 8108048:	b480      	push	{r7}
 810804a:	af00      	add	r7, sp, #0
#if defined(RCC_D2CFGR_D2PPRE2)
  return (uint32_t)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2));
 810804c:	4b04      	ldr	r3, [pc, #16]	@ (8108060 <LL_RCC_GetAPB2Prescaler+0x18>)
 810804e:	69db      	ldr	r3, [r3, #28]
 8108050:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
#else
  return (uint32_t)(READ_BIT(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2));
#endif /* RCC_D2CFGR_D2PPRE2 */
}
 8108054:	4618      	mov	r0, r3
 8108056:	46bd      	mov	sp, r7
 8108058:	f85d 7b04 	ldr.w	r7, [sp], #4
 810805c:	4770      	bx	lr
 810805e:	bf00      	nop
 8108060:	58024400 	.word	0x58024400

08108064 <LL_RCC_GetClockSource>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE uint32_t LL_RCC_GetClockSource(uint32_t Periph)
{
 8108064:	b480      	push	{r7}
 8108066:	b085      	sub	sp, #20
 8108068:	af00      	add	r7, sp, #0
 810806a:	6078      	str	r0, [r7, #4]
#if defined(RCC_D1CCIPR_FMCSEL)
  const uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->D1CCIPR) + LL_CLKSOURCE_REG(Periph)));
 810806c:	687b      	ldr	r3, [r7, #4]
 810806e:	b2da      	uxtb	r2, r3
 8108070:	4b0e      	ldr	r3, [pc, #56]	@ (81080ac <LL_RCC_GetClockSource+0x48>)
 8108072:	4413      	add	r3, r2
 8108074:	60fb      	str	r3, [r7, #12]
#else
  const uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CDCCIPR) + LL_CLKSOURCE_REG(Periph)));
#endif /* RCC_D1CCIPR_FMCSEL */
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
 8108076:	68fb      	ldr	r3, [r7, #12]
 8108078:	681a      	ldr	r2, [r3, #0]
 810807a:	687b      	ldr	r3, [r7, #4]
 810807c:	0e19      	lsrs	r1, r3, #24
 810807e:	687b      	ldr	r3, [r7, #4]
 8108080:	0a1b      	lsrs	r3, r3, #8
 8108082:	f003 031f 	and.w	r3, r3, #31
 8108086:	fa01 f303 	lsl.w	r3, r1, r3
 810808a:	401a      	ands	r2, r3
 810808c:	687b      	ldr	r3, [r7, #4]
 810808e:	0a1b      	lsrs	r3, r3, #8
 8108090:	f003 031f 	and.w	r3, r3, #31
 8108094:	fa22 f303 	lsr.w	r3, r2, r3
 8108098:	041a      	lsls	r2, r3, #16
 810809a:	687b      	ldr	r3, [r7, #4]
 810809c:	4313      	orrs	r3, r2
}
 810809e:	4618      	mov	r0, r3
 81080a0:	3714      	adds	r7, #20
 81080a2:	46bd      	mov	sp, r7
 81080a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81080a8:	4770      	bx	lr
 81080aa:	bf00      	nop
 81080ac:	5802444c 	.word	0x5802444c

081080b0 <LL_RCC_GetUSARTClockSource>:
  *         @arg @ref LL_RCC_USART234578_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_USART234578_CLKSOURCE_CSI
  *         @arg @ref LL_RCC_USART234578_CLKSOURCE_LSE
  */
__STATIC_INLINE uint32_t LL_RCC_GetUSARTClockSource(uint32_t Periph)
{
 81080b0:	b580      	push	{r7, lr}
 81080b2:	b082      	sub	sp, #8
 81080b4:	af00      	add	r7, sp, #0
 81080b6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
 81080b8:	6878      	ldr	r0, [r7, #4]
 81080ba:	f7ff ffd3 	bl	8108064 <LL_RCC_GetClockSource>
 81080be:	4603      	mov	r3, r0
}
 81080c0:	4618      	mov	r0, r3
 81080c2:	3708      	adds	r7, #8
 81080c4:	46bd      	mov	sp, r7
 81080c6:	bd80      	pop	{r7, pc}

081080c8 <LL_RCC_PLL_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_CSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_NONE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetSource(void)
{
 81080c8:	b480      	push	{r7}
 81080ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 81080cc:	4b04      	ldr	r3, [pc, #16]	@ (81080e0 <LL_RCC_PLL_GetSource+0x18>)
 81080ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81080d0:	f003 0303 	and.w	r3, r3, #3
}
 81080d4:	4618      	mov	r0, r3
 81080d6:	46bd      	mov	sp, r7
 81080d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81080dc:	4770      	bx	lr
 81080de:	bf00      	nop
 81080e0:	58024400 	.word	0x58024400

081080e4 <LL_RCC_PLL1P_IsEnabled>:
  * @brief  Check if PLL1 P is enabled
  * @rmtoll PLLCFGR           DIVP1EN         LL_RCC_PLL1P_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1P_IsEnabled(void)
{
 81080e4:	b480      	push	{r7}
 81080e6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN) == RCC_PLLCFGR_DIVP1EN) ? 1UL : 0UL);
 81080e8:	4b07      	ldr	r3, [pc, #28]	@ (8108108 <LL_RCC_PLL1P_IsEnabled+0x24>)
 81080ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81080ec:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 81080f0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 81080f4:	d101      	bne.n	81080fa <LL_RCC_PLL1P_IsEnabled+0x16>
 81080f6:	2301      	movs	r3, #1
 81080f8:	e000      	b.n	81080fc <LL_RCC_PLL1P_IsEnabled+0x18>
 81080fa:	2300      	movs	r3, #0
}
 81080fc:	4618      	mov	r0, r3
 81080fe:	46bd      	mov	sp, r7
 8108100:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108104:	4770      	bx	lr
 8108106:	bf00      	nop
 8108108:	58024400 	.word	0x58024400

0810810c <LL_RCC_PLL1Q_IsEnabled>:
  * @brief  Check if PLL1 Q is enabled
  * @rmtoll PLLCFGR           DIVQ1EN         LL_RCC_PLL1Q_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1Q_IsEnabled(void)
{
 810810c:	b480      	push	{r7}
 810810e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN) == RCC_PLLCFGR_DIVQ1EN) ? 1UL : 0UL);
 8108110:	4b07      	ldr	r3, [pc, #28]	@ (8108130 <LL_RCC_PLL1Q_IsEnabled+0x24>)
 8108112:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108114:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8108118:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 810811c:	d101      	bne.n	8108122 <LL_RCC_PLL1Q_IsEnabled+0x16>
 810811e:	2301      	movs	r3, #1
 8108120:	e000      	b.n	8108124 <LL_RCC_PLL1Q_IsEnabled+0x18>
 8108122:	2300      	movs	r3, #0
}
 8108124:	4618      	mov	r0, r3
 8108126:	46bd      	mov	sp, r7
 8108128:	f85d 7b04 	ldr.w	r7, [sp], #4
 810812c:	4770      	bx	lr
 810812e:	bf00      	nop
 8108130:	58024400 	.word	0x58024400

08108134 <LL_RCC_PLL1R_IsEnabled>:
  * @brief  Check if PLL1 R is enabled
  * @rmtoll PLLCFGR           DIVR1EN         LL_RCC_PLL1R_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1R_IsEnabled(void)
{
 8108134:	b480      	push	{r7}
 8108136:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN) == RCC_PLLCFGR_DIVR1EN) ? 1UL : 0UL);
 8108138:	4b07      	ldr	r3, [pc, #28]	@ (8108158 <LL_RCC_PLL1R_IsEnabled+0x24>)
 810813a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810813c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8108140:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8108144:	d101      	bne.n	810814a <LL_RCC_PLL1R_IsEnabled+0x16>
 8108146:	2301      	movs	r3, #1
 8108148:	e000      	b.n	810814c <LL_RCC_PLL1R_IsEnabled+0x18>
 810814a:	2300      	movs	r3, #0
}
 810814c:	4618      	mov	r0, r3
 810814e:	46bd      	mov	sp, r7
 8108150:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108154:	4770      	bx	lr
 8108156:	bf00      	nop
 8108158:	58024400 	.word	0x58024400

0810815c <LL_RCC_PLL1FRACN_IsEnabled>:
  * @brief  Check if PLL1 FRACN is enabled
  * @rmtoll PLLCFGR           PLL1FRACEN         LL_RCC_PLL1FRACN_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1FRACN_IsEnabled(void)
{
 810815c:	b480      	push	{r7}
 810815e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN) == RCC_PLLCFGR_PLL1FRACEN) ? 1UL : 0UL);
 8108160:	4b06      	ldr	r3, [pc, #24]	@ (810817c <LL_RCC_PLL1FRACN_IsEnabled+0x20>)
 8108162:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108164:	f003 0301 	and.w	r3, r3, #1
 8108168:	2b01      	cmp	r3, #1
 810816a:	d101      	bne.n	8108170 <LL_RCC_PLL1FRACN_IsEnabled+0x14>
 810816c:	2301      	movs	r3, #1
 810816e:	e000      	b.n	8108172 <LL_RCC_PLL1FRACN_IsEnabled+0x16>
 8108170:	2300      	movs	r3, #0
}
 8108172:	4618      	mov	r0, r3
 8108174:	46bd      	mov	sp, r7
 8108176:	f85d 7b04 	ldr.w	r7, [sp], #4
 810817a:	4770      	bx	lr
 810817c:	58024400 	.word	0x58024400

08108180 <LL_RCC_PLL1_GetN>:
  * @brief  Get PLL1 N Coefficient
  * @rmtoll PLL1DIVR        N1          LL_RCC_PLL1_GetN
  * @retval A value between 4 and 512
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetN(void)
{
 8108180:	b480      	push	{r7}
 8108182:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_N1) >>  RCC_PLL1DIVR_N1_Pos) + 1UL);
 8108184:	4b04      	ldr	r3, [pc, #16]	@ (8108198 <LL_RCC_PLL1_GetN+0x18>)
 8108186:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8108188:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810818c:	3301      	adds	r3, #1
}
 810818e:	4618      	mov	r0, r3
 8108190:	46bd      	mov	sp, r7
 8108192:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108196:	4770      	bx	lr
 8108198:	58024400 	.word	0x58024400

0810819c <LL_RCC_PLL1_GetM>:
  * @brief  Get PLL1 M Coefficient
  * @rmtoll PLLCKSELR       DIVM1          LL_RCC_PLL1_GetM
  * @retval A value between 0 and 63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetM(void)
{
 810819c:	b480      	push	{r7}
 810819e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1) >>  RCC_PLLCKSELR_DIVM1_Pos);
 81081a0:	4b04      	ldr	r3, [pc, #16]	@ (81081b4 <LL_RCC_PLL1_GetM+0x18>)
 81081a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81081a4:	091b      	lsrs	r3, r3, #4
 81081a6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
 81081aa:	4618      	mov	r0, r3
 81081ac:	46bd      	mov	sp, r7
 81081ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 81081b2:	4770      	bx	lr
 81081b4:	58024400 	.word	0x58024400

081081b8 <LL_RCC_PLL1_GetP>:
  * @brief  Get PLL1 P Coefficient
  * @rmtoll PLL1DIVR        P1          LL_RCC_PLL1_GetP
  * @retval A value between 2 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetP(void)
{
 81081b8:	b480      	push	{r7}
 81081ba:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_P1) >>  RCC_PLL1DIVR_P1_Pos) + 1UL);
 81081bc:	4b05      	ldr	r3, [pc, #20]	@ (81081d4 <LL_RCC_PLL1_GetP+0x1c>)
 81081be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81081c0:	0a5b      	lsrs	r3, r3, #9
 81081c2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81081c6:	3301      	adds	r3, #1
}
 81081c8:	4618      	mov	r0, r3
 81081ca:	46bd      	mov	sp, r7
 81081cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81081d0:	4770      	bx	lr
 81081d2:	bf00      	nop
 81081d4:	58024400 	.word	0x58024400

081081d8 <LL_RCC_PLL1_GetQ>:
  * @brief  Get PLL1 Q Coefficient
  * @rmtoll PLL1DIVR        Q1          LL_RCC_PLL1_GetQ
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetQ(void)
{
 81081d8:	b480      	push	{r7}
 81081da:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1) >>  RCC_PLL1DIVR_Q1_Pos) + 1UL);
 81081dc:	4b05      	ldr	r3, [pc, #20]	@ (81081f4 <LL_RCC_PLL1_GetQ+0x1c>)
 81081de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81081e0:	0c1b      	lsrs	r3, r3, #16
 81081e2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81081e6:	3301      	adds	r3, #1
}
 81081e8:	4618      	mov	r0, r3
 81081ea:	46bd      	mov	sp, r7
 81081ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 81081f0:	4770      	bx	lr
 81081f2:	bf00      	nop
 81081f4:	58024400 	.word	0x58024400

081081f8 <LL_RCC_PLL1_GetR>:
  * @brief  Get PLL1 R Coefficient
  * @rmtoll PLL1DIVR        R1          LL_RCC_PLL1_GetR
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetR(void)
{
 81081f8:	b480      	push	{r7}
 81081fa:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_R1) >>  RCC_PLL1DIVR_R1_Pos) + 1UL);
 81081fc:	4b05      	ldr	r3, [pc, #20]	@ (8108214 <LL_RCC_PLL1_GetR+0x1c>)
 81081fe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8108200:	0e1b      	lsrs	r3, r3, #24
 8108202:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8108206:	3301      	adds	r3, #1
}
 8108208:	4618      	mov	r0, r3
 810820a:	46bd      	mov	sp, r7
 810820c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108210:	4770      	bx	lr
 8108212:	bf00      	nop
 8108214:	58024400 	.word	0x58024400

08108218 <LL_RCC_PLL1_GetFRACN>:
  * @brief  Get PLL1 FRACN Coefficient
  * @rmtoll PLL1FRACR      FRACN1          LL_RCC_PLL1_GetFRACN
  * @retval A value between 0 and 8191 (0x1FFF)
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetFRACN(void)
{
 8108218:	b480      	push	{r7}
 810821a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1) >>  RCC_PLL1FRACR_FRACN1_Pos);
 810821c:	4b04      	ldr	r3, [pc, #16]	@ (8108230 <LL_RCC_PLL1_GetFRACN+0x18>)
 810821e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8108220:	08db      	lsrs	r3, r3, #3
 8108222:	f3c3 030c 	ubfx	r3, r3, #0, #13
}
 8108226:	4618      	mov	r0, r3
 8108228:	46bd      	mov	sp, r7
 810822a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810822e:	4770      	bx	lr
 8108230:	58024400 	.word	0x58024400

08108234 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll CR           PLL2RDY        LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
 8108234:	b480      	push	{r7}
 8108236:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == (RCC_CR_PLL2RDY)) ? 1UL : 0UL);
 8108238:	4b07      	ldr	r3, [pc, #28]	@ (8108258 <LL_RCC_PLL2_IsReady+0x24>)
 810823a:	681b      	ldr	r3, [r3, #0]
 810823c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8108240:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8108244:	d101      	bne.n	810824a <LL_RCC_PLL2_IsReady+0x16>
 8108246:	2301      	movs	r3, #1
 8108248:	e000      	b.n	810824c <LL_RCC_PLL2_IsReady+0x18>
 810824a:	2300      	movs	r3, #0
}
 810824c:	4618      	mov	r0, r3
 810824e:	46bd      	mov	sp, r7
 8108250:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108254:	4770      	bx	lr
 8108256:	bf00      	nop
 8108258:	58024400 	.word	0x58024400

0810825c <LL_RCC_PLL2P_IsEnabled>:
  * @brief  Check if PLL2 P is enabled
  * @rmtoll PLLCFGR           DIVP2EN         LL_RCC_PLL2P_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2P_IsEnabled(void)
{
 810825c:	b480      	push	{r7}
 810825e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN) == RCC_PLLCFGR_DIVP2EN) ? 1UL : 0UL);
 8108260:	4b07      	ldr	r3, [pc, #28]	@ (8108280 <LL_RCC_PLL2P_IsEnabled+0x24>)
 8108262:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108264:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8108268:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 810826c:	d101      	bne.n	8108272 <LL_RCC_PLL2P_IsEnabled+0x16>
 810826e:	2301      	movs	r3, #1
 8108270:	e000      	b.n	8108274 <LL_RCC_PLL2P_IsEnabled+0x18>
 8108272:	2300      	movs	r3, #0
}
 8108274:	4618      	mov	r0, r3
 8108276:	46bd      	mov	sp, r7
 8108278:	f85d 7b04 	ldr.w	r7, [sp], #4
 810827c:	4770      	bx	lr
 810827e:	bf00      	nop
 8108280:	58024400 	.word	0x58024400

08108284 <LL_RCC_PLL2Q_IsEnabled>:
  * @brief  Check if PLL2 Q is enabled
  * @rmtoll PLLCFGR           DIVQ2EN         LL_RCC_PLL2Q_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2Q_IsEnabled(void)
{
 8108284:	b480      	push	{r7}
 8108286:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN) == RCC_PLLCFGR_DIVQ2EN) ? 1UL : 0UL);
 8108288:	4b07      	ldr	r3, [pc, #28]	@ (81082a8 <LL_RCC_PLL2Q_IsEnabled+0x24>)
 810828a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810828c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8108290:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8108294:	d101      	bne.n	810829a <LL_RCC_PLL2Q_IsEnabled+0x16>
 8108296:	2301      	movs	r3, #1
 8108298:	e000      	b.n	810829c <LL_RCC_PLL2Q_IsEnabled+0x18>
 810829a:	2300      	movs	r3, #0
}
 810829c:	4618      	mov	r0, r3
 810829e:	46bd      	mov	sp, r7
 81082a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81082a4:	4770      	bx	lr
 81082a6:	bf00      	nop
 81082a8:	58024400 	.word	0x58024400

081082ac <LL_RCC_PLL2R_IsEnabled>:
  * @brief  Check if PLL2 R is enabled
  * @rmtoll PLLCFGR           DIVR2EN         LL_RCC_PLL2R_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2R_IsEnabled(void)
{
 81082ac:	b480      	push	{r7}
 81082ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN) == RCC_PLLCFGR_DIVR2EN) ? 1UL : 0UL);
 81082b0:	4b07      	ldr	r3, [pc, #28]	@ (81082d0 <LL_RCC_PLL2R_IsEnabled+0x24>)
 81082b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81082b4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 81082b8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 81082bc:	d101      	bne.n	81082c2 <LL_RCC_PLL2R_IsEnabled+0x16>
 81082be:	2301      	movs	r3, #1
 81082c0:	e000      	b.n	81082c4 <LL_RCC_PLL2R_IsEnabled+0x18>
 81082c2:	2300      	movs	r3, #0
}
 81082c4:	4618      	mov	r0, r3
 81082c6:	46bd      	mov	sp, r7
 81082c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81082cc:	4770      	bx	lr
 81082ce:	bf00      	nop
 81082d0:	58024400 	.word	0x58024400

081082d4 <LL_RCC_PLL2FRACN_IsEnabled>:
  * @brief  Check if PLL2 FRACN is enabled
  * @rmtoll PLLCFGR           PLL2FRACEN         LL_RCC_PLL2FRACN_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2FRACN_IsEnabled(void)
{
 81082d4:	b480      	push	{r7}
 81082d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN) == RCC_PLLCFGR_PLL2FRACEN) ? 1UL : 0UL);
 81082d8:	4b06      	ldr	r3, [pc, #24]	@ (81082f4 <LL_RCC_PLL2FRACN_IsEnabled+0x20>)
 81082da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81082dc:	f003 0310 	and.w	r3, r3, #16
 81082e0:	2b10      	cmp	r3, #16
 81082e2:	d101      	bne.n	81082e8 <LL_RCC_PLL2FRACN_IsEnabled+0x14>
 81082e4:	2301      	movs	r3, #1
 81082e6:	e000      	b.n	81082ea <LL_RCC_PLL2FRACN_IsEnabled+0x16>
 81082e8:	2300      	movs	r3, #0
}
 81082ea:	4618      	mov	r0, r3
 81082ec:	46bd      	mov	sp, r7
 81082ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 81082f2:	4770      	bx	lr
 81082f4:	58024400 	.word	0x58024400

081082f8 <LL_RCC_PLL2_GetN>:
  * @brief  Get PLL2 N Coefficient
  * @rmtoll PLL2DIVR        N2          LL_RCC_PLL2_GetN
  * @retval A value between 4 and 512
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetN(void)
{
 81082f8:	b480      	push	{r7}
 81082fa:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_N2) >>  RCC_PLL2DIVR_N2_Pos) + 1UL);
 81082fc:	4b04      	ldr	r3, [pc, #16]	@ (8108310 <LL_RCC_PLL2_GetN+0x18>)
 81082fe:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8108300:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8108304:	3301      	adds	r3, #1
}
 8108306:	4618      	mov	r0, r3
 8108308:	46bd      	mov	sp, r7
 810830a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810830e:	4770      	bx	lr
 8108310:	58024400 	.word	0x58024400

08108314 <LL_RCC_PLL2_GetM>:
  * @brief  Get PLL2 M Coefficient
  * @rmtoll PLLCKSELR       DIVM2          LL_RCC_PLL2_GetM
  * @retval A value between 0 and 63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetM(void)
{
 8108314:	b480      	push	{r7}
 8108316:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2) >>  RCC_PLLCKSELR_DIVM2_Pos);
 8108318:	4b04      	ldr	r3, [pc, #16]	@ (810832c <LL_RCC_PLL2_GetM+0x18>)
 810831a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810831c:	0b1b      	lsrs	r3, r3, #12
 810831e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
 8108322:	4618      	mov	r0, r3
 8108324:	46bd      	mov	sp, r7
 8108326:	f85d 7b04 	ldr.w	r7, [sp], #4
 810832a:	4770      	bx	lr
 810832c:	58024400 	.word	0x58024400

08108330 <LL_RCC_PLL2_GetP>:
  * @brief  Get PLL2 P Coefficient
  * @rmtoll PLL2DIVR        P2          LL_RCC_PLL2_GetP
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetP(void)
{
 8108330:	b480      	push	{r7}
 8108332:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_P2) >>  RCC_PLL2DIVR_P2_Pos) + 1UL);
 8108334:	4b05      	ldr	r3, [pc, #20]	@ (810834c <LL_RCC_PLL2_GetP+0x1c>)
 8108336:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8108338:	0a5b      	lsrs	r3, r3, #9
 810833a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810833e:	3301      	adds	r3, #1
}
 8108340:	4618      	mov	r0, r3
 8108342:	46bd      	mov	sp, r7
 8108344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108348:	4770      	bx	lr
 810834a:	bf00      	nop
 810834c:	58024400 	.word	0x58024400

08108350 <LL_RCC_PLL2_GetQ>:
  * @brief  Get PLL2 Q Coefficient
  * @rmtoll PLL2DIVR        Q2          LL_RCC_PLL2_GetQ
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetQ(void)
{
 8108350:	b480      	push	{r7}
 8108352:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2) >>  RCC_PLL2DIVR_Q2_Pos) + 1UL);
 8108354:	4b05      	ldr	r3, [pc, #20]	@ (810836c <LL_RCC_PLL2_GetQ+0x1c>)
 8108356:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8108358:	0c1b      	lsrs	r3, r3, #16
 810835a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810835e:	3301      	adds	r3, #1
}
 8108360:	4618      	mov	r0, r3
 8108362:	46bd      	mov	sp, r7
 8108364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108368:	4770      	bx	lr
 810836a:	bf00      	nop
 810836c:	58024400 	.word	0x58024400

08108370 <LL_RCC_PLL2_GetR>:
  * @brief  Get PLL2 R Coefficient
  * @rmtoll PLL2DIVR        R2          LL_RCC_PLL2_GetR
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetR(void)
{
 8108370:	b480      	push	{r7}
 8108372:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_R2) >>  RCC_PLL2DIVR_R2_Pos) + 1UL);
 8108374:	4b05      	ldr	r3, [pc, #20]	@ (810838c <LL_RCC_PLL2_GetR+0x1c>)
 8108376:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8108378:	0e1b      	lsrs	r3, r3, #24
 810837a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810837e:	3301      	adds	r3, #1
}
 8108380:	4618      	mov	r0, r3
 8108382:	46bd      	mov	sp, r7
 8108384:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108388:	4770      	bx	lr
 810838a:	bf00      	nop
 810838c:	58024400 	.word	0x58024400

08108390 <LL_RCC_PLL2_GetFRACN>:
  * @brief  Get PLL2 FRACN Coefficient
  * @rmtoll PLL2FRACR      FRACN2          LL_RCC_PLL2_GetFRACN
  * @retval A value between 0 and 8191 (0x1FFF)
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetFRACN(void)
{
 8108390:	b480      	push	{r7}
 8108392:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2) >>  RCC_PLL2FRACR_FRACN2_Pos);
 8108394:	4b04      	ldr	r3, [pc, #16]	@ (81083a8 <LL_RCC_PLL2_GetFRACN+0x18>)
 8108396:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8108398:	08db      	lsrs	r3, r3, #3
 810839a:	f3c3 030c 	ubfx	r3, r3, #0, #13
}
 810839e:	4618      	mov	r0, r3
 81083a0:	46bd      	mov	sp, r7
 81083a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81083a6:	4770      	bx	lr
 81083a8:	58024400 	.word	0x58024400

081083ac <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll CR           PLL3RDY        LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
 81083ac:	b480      	push	{r7}
 81083ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLL3RDY) == (RCC_CR_PLL3RDY)) ? 1UL : 0UL);
 81083b0:	4b07      	ldr	r3, [pc, #28]	@ (81083d0 <LL_RCC_PLL3_IsReady+0x24>)
 81083b2:	681b      	ldr	r3, [r3, #0]
 81083b4:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 81083b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81083bc:	d101      	bne.n	81083c2 <LL_RCC_PLL3_IsReady+0x16>
 81083be:	2301      	movs	r3, #1
 81083c0:	e000      	b.n	81083c4 <LL_RCC_PLL3_IsReady+0x18>
 81083c2:	2300      	movs	r3, #0
}
 81083c4:	4618      	mov	r0, r3
 81083c6:	46bd      	mov	sp, r7
 81083c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81083cc:	4770      	bx	lr
 81083ce:	bf00      	nop
 81083d0:	58024400 	.word	0x58024400

081083d4 <LL_RCC_PLL3P_IsEnabled>:
  * @brief  Check if PLL3 P is enabled
  * @rmtoll PLLCFGR           DIVP3EN         LL_RCC_PLL3P_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3P_IsEnabled(void)
{
 81083d4:	b480      	push	{r7}
 81083d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN) == RCC_PLLCFGR_DIVP3EN) ? 1UL : 0UL);
 81083d8:	4b07      	ldr	r3, [pc, #28]	@ (81083f8 <LL_RCC_PLL3P_IsEnabled+0x24>)
 81083da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81083dc:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 81083e0:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 81083e4:	d101      	bne.n	81083ea <LL_RCC_PLL3P_IsEnabled+0x16>
 81083e6:	2301      	movs	r3, #1
 81083e8:	e000      	b.n	81083ec <LL_RCC_PLL3P_IsEnabled+0x18>
 81083ea:	2300      	movs	r3, #0
}
 81083ec:	4618      	mov	r0, r3
 81083ee:	46bd      	mov	sp, r7
 81083f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81083f4:	4770      	bx	lr
 81083f6:	bf00      	nop
 81083f8:	58024400 	.word	0x58024400

081083fc <LL_RCC_PLL3Q_IsEnabled>:
  * @brief  Check if PLL3 Q is enabled
  * @rmtoll PLLCFGR           DIVQ3EN         LL_RCC_PLL3Q_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3Q_IsEnabled(void)
{
 81083fc:	b480      	push	{r7}
 81083fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN) == RCC_PLLCFGR_DIVQ3EN) ? 1UL : 0UL);
 8108400:	4b07      	ldr	r3, [pc, #28]	@ (8108420 <LL_RCC_PLL3Q_IsEnabled+0x24>)
 8108402:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108404:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8108408:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 810840c:	d101      	bne.n	8108412 <LL_RCC_PLL3Q_IsEnabled+0x16>
 810840e:	2301      	movs	r3, #1
 8108410:	e000      	b.n	8108414 <LL_RCC_PLL3Q_IsEnabled+0x18>
 8108412:	2300      	movs	r3, #0
}
 8108414:	4618      	mov	r0, r3
 8108416:	46bd      	mov	sp, r7
 8108418:	f85d 7b04 	ldr.w	r7, [sp], #4
 810841c:	4770      	bx	lr
 810841e:	bf00      	nop
 8108420:	58024400 	.word	0x58024400

08108424 <LL_RCC_PLL3R_IsEnabled>:
  * @brief  Check if PLL3 R is enabled
  * @rmtoll PLLCFGR           DIVR3EN         LL_RCC_PLL3R_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3R_IsEnabled(void)
{
 8108424:	b480      	push	{r7}
 8108426:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN) == RCC_PLLCFGR_DIVR3EN) ? 1UL : 0UL);
 8108428:	4b07      	ldr	r3, [pc, #28]	@ (8108448 <LL_RCC_PLL3R_IsEnabled+0x24>)
 810842a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810842c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8108430:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8108434:	d101      	bne.n	810843a <LL_RCC_PLL3R_IsEnabled+0x16>
 8108436:	2301      	movs	r3, #1
 8108438:	e000      	b.n	810843c <LL_RCC_PLL3R_IsEnabled+0x18>
 810843a:	2300      	movs	r3, #0
}
 810843c:	4618      	mov	r0, r3
 810843e:	46bd      	mov	sp, r7
 8108440:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108444:	4770      	bx	lr
 8108446:	bf00      	nop
 8108448:	58024400 	.word	0x58024400

0810844c <LL_RCC_PLL3FRACN_IsEnabled>:
  * @brief  Check if PLL3 FRACN is enabled
  * @rmtoll PLLCFGR           PLL3FRACEN         LL_RCC_PLL3FRACN_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3FRACN_IsEnabled(void)
{
 810844c:	b480      	push	{r7}
 810844e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN) == RCC_PLLCFGR_PLL3FRACEN) ? 1UL : 0UL);
 8108450:	4b07      	ldr	r3, [pc, #28]	@ (8108470 <LL_RCC_PLL3FRACN_IsEnabled+0x24>)
 8108452:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108454:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8108458:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 810845c:	d101      	bne.n	8108462 <LL_RCC_PLL3FRACN_IsEnabled+0x16>
 810845e:	2301      	movs	r3, #1
 8108460:	e000      	b.n	8108464 <LL_RCC_PLL3FRACN_IsEnabled+0x18>
 8108462:	2300      	movs	r3, #0
}
 8108464:	4618      	mov	r0, r3
 8108466:	46bd      	mov	sp, r7
 8108468:	f85d 7b04 	ldr.w	r7, [sp], #4
 810846c:	4770      	bx	lr
 810846e:	bf00      	nop
 8108470:	58024400 	.word	0x58024400

08108474 <LL_RCC_PLL3_GetN>:
  * @brief  Get PLL3 N Coefficient
  * @rmtoll PLL3DIVR        N3          LL_RCC_PLL3_GetN
  * @retval A value between 4 and 512
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetN(void)
{
 8108474:	b480      	push	{r7}
 8108476:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 8108478:	4b04      	ldr	r3, [pc, #16]	@ (810848c <LL_RCC_PLL3_GetN+0x18>)
 810847a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810847c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8108480:	3301      	adds	r3, #1
}
 8108482:	4618      	mov	r0, r3
 8108484:	46bd      	mov	sp, r7
 8108486:	f85d 7b04 	ldr.w	r7, [sp], #4
 810848a:	4770      	bx	lr
 810848c:	58024400 	.word	0x58024400

08108490 <LL_RCC_PLL3_GetM>:
  * @brief  Get PLL3 M Coefficient
  * @rmtoll PLLCKSELR       DIVM3          LL_RCC_PLL3_GetM
  * @retval A value between 0 and 63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetM(void)
{
 8108490:	b480      	push	{r7}
 8108492:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3) >>  RCC_PLLCKSELR_DIVM3_Pos);
 8108494:	4b04      	ldr	r3, [pc, #16]	@ (81084a8 <LL_RCC_PLL3_GetM+0x18>)
 8108496:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8108498:	0d1b      	lsrs	r3, r3, #20
 810849a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
 810849e:	4618      	mov	r0, r3
 81084a0:	46bd      	mov	sp, r7
 81084a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81084a6:	4770      	bx	lr
 81084a8:	58024400 	.word	0x58024400

081084ac <LL_RCC_PLL3_GetP>:
  * @brief  Get PLL3 P Coefficient
  * @rmtoll PLL3DIVR        P3          LL_RCC_PLL3_GetP
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetP(void)
{
 81084ac:	b480      	push	{r7}
 81084ae:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_P3) >>  RCC_PLL3DIVR_P3_Pos) + 1UL);
 81084b0:	4b05      	ldr	r3, [pc, #20]	@ (81084c8 <LL_RCC_PLL3_GetP+0x1c>)
 81084b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 81084b4:	0a5b      	lsrs	r3, r3, #9
 81084b6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81084ba:	3301      	adds	r3, #1
}
 81084bc:	4618      	mov	r0, r3
 81084be:	46bd      	mov	sp, r7
 81084c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81084c4:	4770      	bx	lr
 81084c6:	bf00      	nop
 81084c8:	58024400 	.word	0x58024400

081084cc <LL_RCC_PLL3_GetQ>:
  * @brief  Get PLL3 Q Coefficient
  * @rmtoll PLL3DIVR        Q3          LL_RCC_PLL3_GetQ
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetQ(void)
{
 81084cc:	b480      	push	{r7}
 81084ce:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_Q3) >>  RCC_PLL3DIVR_Q3_Pos) + 1UL);
 81084d0:	4b05      	ldr	r3, [pc, #20]	@ (81084e8 <LL_RCC_PLL3_GetQ+0x1c>)
 81084d2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 81084d4:	0c1b      	lsrs	r3, r3, #16
 81084d6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81084da:	3301      	adds	r3, #1
}
 81084dc:	4618      	mov	r0, r3
 81084de:	46bd      	mov	sp, r7
 81084e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81084e4:	4770      	bx	lr
 81084e6:	bf00      	nop
 81084e8:	58024400 	.word	0x58024400

081084ec <LL_RCC_PLL3_GetR>:
  * @brief  Get PLL3 R Coefficient
  * @rmtoll PLL3DIVR        R3          LL_RCC_PLL3_GetR
  * @retval A value between 1 and 128
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetR(void)
{
 81084ec:	b480      	push	{r7}
 81084ee:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_R3) >>  RCC_PLL3DIVR_R3_Pos) + 1UL);
 81084f0:	4b05      	ldr	r3, [pc, #20]	@ (8108508 <LL_RCC_PLL3_GetR+0x1c>)
 81084f2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 81084f4:	0e1b      	lsrs	r3, r3, #24
 81084f6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 81084fa:	3301      	adds	r3, #1
}
 81084fc:	4618      	mov	r0, r3
 81084fe:	46bd      	mov	sp, r7
 8108500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108504:	4770      	bx	lr
 8108506:	bf00      	nop
 8108508:	58024400 	.word	0x58024400

0810850c <LL_RCC_PLL3_GetFRACN>:
  * @brief  Get PLL3 FRACN Coefficient
  * @rmtoll PLL3FRACR      FRACN3          LL_RCC_PLL3_GetFRACN
  * @retval A value between 0 and 8191 (0x1FFF)
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetFRACN(void)
{
 810850c:	b480      	push	{r7}
 810850e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3) >>  RCC_PLL3FRACR_FRACN3_Pos);
 8108510:	4b04      	ldr	r3, [pc, #16]	@ (8108524 <LL_RCC_PLL3_GetFRACN+0x18>)
 8108512:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8108514:	08db      	lsrs	r3, r3, #3
 8108516:	f3c3 030c 	ubfx	r3, r3, #0, #13
}
 810851a:	4618      	mov	r0, r3
 810851c:	46bd      	mov	sp, r7
 810851e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108522:	4770      	bx	lr
 8108524:	58024400 	.word	0x58024400

08108528 <LL_RCC_GetPLL1ClockFreq>:
  * @brief  Return PLL1 clocks frequencies
  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval None
  */
void LL_RCC_GetPLL1ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)
{
 8108528:	b580      	push	{r7, lr}
 810852a:	b08a      	sub	sp, #40	@ 0x28
 810852c:	af02      	add	r7, sp, #8
 810852e:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8108530:	2300      	movs	r3, #0
 8108532:	61fb      	str	r3, [r7, #28]
  uint32_t m, n, fracn = 0U;
 8108534:	2300      	movs	r3, #0
 8108536:	61bb      	str	r3, [r7, #24]

  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP
  */
  pllsource = LL_RCC_PLL_GetSource();
 8108538:	f7ff fdc6 	bl	81080c8 <LL_RCC_PLL_GetSource>
 810853c:	6178      	str	r0, [r7, #20]

  switch (pllsource)
 810853e:	697b      	ldr	r3, [r7, #20]
 8108540:	2b02      	cmp	r3, #2
 8108542:	d01f      	beq.n	8108584 <LL_RCC_GetPLL1ClockFreq+0x5c>
 8108544:	697b      	ldr	r3, [r7, #20]
 8108546:	2b02      	cmp	r3, #2
 8108548:	d824      	bhi.n	8108594 <LL_RCC_GetPLL1ClockFreq+0x6c>
 810854a:	697b      	ldr	r3, [r7, #20]
 810854c:	2b00      	cmp	r3, #0
 810854e:	d003      	beq.n	8108558 <LL_RCC_GetPLL1ClockFreq+0x30>
 8108550:	697b      	ldr	r3, [r7, #20]
 8108552:	2b01      	cmp	r3, #1
 8108554:	d00e      	beq.n	8108574 <LL_RCC_GetPLL1ClockFreq+0x4c>
      break;

    case LL_RCC_PLLSOURCE_NONE:
    default:
      /* PLL clock disabled */
      break;
 8108556:	e01d      	b.n	8108594 <LL_RCC_GetPLL1ClockFreq+0x6c>
      if (LL_RCC_HSI_IsReady() != 0U)
 8108558:	f7ff fcf8 	bl	8107f4c <LL_RCC_HSI_IsReady>
 810855c:	4603      	mov	r3, r0
 810855e:	2b00      	cmp	r3, #0
 8108560:	d01a      	beq.n	8108598 <LL_RCC_GetPLL1ClockFreq+0x70>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8108562:	f7ff fd05 	bl	8107f70 <LL_RCC_HSI_GetDivider>
 8108566:	4603      	mov	r3, r0
 8108568:	08db      	lsrs	r3, r3, #3
 810856a:	4a38      	ldr	r2, [pc, #224]	@ (810864c <LL_RCC_GetPLL1ClockFreq+0x124>)
 810856c:	fa22 f303 	lsr.w	r3, r2, r3
 8108570:	61fb      	str	r3, [r7, #28]
      break;
 8108572:	e011      	b.n	8108598 <LL_RCC_GetPLL1ClockFreq+0x70>
      if (LL_RCC_CSI_IsReady() != 0U)
 8108574:	f7ff fd0a 	bl	8107f8c <LL_RCC_CSI_IsReady>
 8108578:	4603      	mov	r3, r0
 810857a:	2b00      	cmp	r3, #0
 810857c:	d00e      	beq.n	810859c <LL_RCC_GetPLL1ClockFreq+0x74>
        pllinputfreq = CSI_VALUE;
 810857e:	4b34      	ldr	r3, [pc, #208]	@ (8108650 <LL_RCC_GetPLL1ClockFreq+0x128>)
 8108580:	61fb      	str	r3, [r7, #28]
      break;
 8108582:	e00b      	b.n	810859c <LL_RCC_GetPLL1ClockFreq+0x74>
      if (LL_RCC_HSE_IsReady() != 0U)
 8108584:	f7ff fcce 	bl	8107f24 <LL_RCC_HSE_IsReady>
 8108588:	4603      	mov	r3, r0
 810858a:	2b00      	cmp	r3, #0
 810858c:	d008      	beq.n	81085a0 <LL_RCC_GetPLL1ClockFreq+0x78>
        pllinputfreq = HSE_VALUE;
 810858e:	4b31      	ldr	r3, [pc, #196]	@ (8108654 <LL_RCC_GetPLL1ClockFreq+0x12c>)
 8108590:	61fb      	str	r3, [r7, #28]
      break;
 8108592:	e005      	b.n	81085a0 <LL_RCC_GetPLL1ClockFreq+0x78>
      break;
 8108594:	bf00      	nop
 8108596:	e004      	b.n	81085a2 <LL_RCC_GetPLL1ClockFreq+0x7a>
      break;
 8108598:	bf00      	nop
 810859a:	e002      	b.n	81085a2 <LL_RCC_GetPLL1ClockFreq+0x7a>
      break;
 810859c:	bf00      	nop
 810859e:	e000      	b.n	81085a2 <LL_RCC_GetPLL1ClockFreq+0x7a>
      break;
 81085a0:	bf00      	nop
  }

  PLL_Clocks->PLL_P_Frequency = 0U;
 81085a2:	687b      	ldr	r3, [r7, #4]
 81085a4:	2200      	movs	r2, #0
 81085a6:	601a      	str	r2, [r3, #0]
  PLL_Clocks->PLL_Q_Frequency = 0U;
 81085a8:	687b      	ldr	r3, [r7, #4]
 81085aa:	2200      	movs	r2, #0
 81085ac:	605a      	str	r2, [r3, #4]
  PLL_Clocks->PLL_R_Frequency = 0U;
 81085ae:	687b      	ldr	r3, [r7, #4]
 81085b0:	2200      	movs	r2, #0
 81085b2:	609a      	str	r2, [r3, #8]

  m = LL_RCC_PLL1_GetM();
 81085b4:	f7ff fdf2 	bl	810819c <LL_RCC_PLL1_GetM>
 81085b8:	6138      	str	r0, [r7, #16]
  n = LL_RCC_PLL1_GetN();
 81085ba:	f7ff fde1 	bl	8108180 <LL_RCC_PLL1_GetN>
 81085be:	60f8      	str	r0, [r7, #12]
  if (LL_RCC_PLL1FRACN_IsEnabled() != 0U)
 81085c0:	f7ff fdcc 	bl	810815c <LL_RCC_PLL1FRACN_IsEnabled>
 81085c4:	4603      	mov	r3, r0
 81085c6:	2b00      	cmp	r3, #0
 81085c8:	d002      	beq.n	81085d0 <LL_RCC_GetPLL1ClockFreq+0xa8>
  {
    fracn = LL_RCC_PLL1_GetFRACN();
 81085ca:	f7ff fe25 	bl	8108218 <LL_RCC_PLL1_GetFRACN>
 81085ce:	61b8      	str	r0, [r7, #24]
  }

  if (m != 0U)
 81085d0:	693b      	ldr	r3, [r7, #16]
 81085d2:	2b00      	cmp	r3, #0
 81085d4:	d035      	beq.n	8108642 <LL_RCC_GetPLL1ClockFreq+0x11a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
 81085d6:	f7ff fd85 	bl	81080e4 <LL_RCC_PLL1P_IsEnabled>
 81085da:	4603      	mov	r3, r0
 81085dc:	2b00      	cmp	r3, #0
 81085de:	d00c      	beq.n	81085fa <LL_RCC_GetPLL1ClockFreq+0xd2>
    {
      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetP());
 81085e0:	f7ff fdea 	bl	81081b8 <LL_RCC_PLL1_GetP>
 81085e4:	4603      	mov	r3, r0
 81085e6:	9300      	str	r3, [sp, #0]
 81085e8:	69bb      	ldr	r3, [r7, #24]
 81085ea:	68fa      	ldr	r2, [r7, #12]
 81085ec:	6939      	ldr	r1, [r7, #16]
 81085ee:	69f8      	ldr	r0, [r7, #28]
 81085f0:	f000 f964 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 81085f4:	4602      	mov	r2, r0
 81085f6:	687b      	ldr	r3, [r7, #4]
 81085f8:	601a      	str	r2, [r3, #0]
    }

    if (LL_RCC_PLL1Q_IsEnabled() != 0U)
 81085fa:	f7ff fd87 	bl	810810c <LL_RCC_PLL1Q_IsEnabled>
 81085fe:	4603      	mov	r3, r0
 8108600:	2b00      	cmp	r3, #0
 8108602:	d00c      	beq.n	810861e <LL_RCC_GetPLL1ClockFreq+0xf6>
    {
      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetQ());
 8108604:	f7ff fde8 	bl	81081d8 <LL_RCC_PLL1_GetQ>
 8108608:	4603      	mov	r3, r0
 810860a:	9300      	str	r3, [sp, #0]
 810860c:	69bb      	ldr	r3, [r7, #24]
 810860e:	68fa      	ldr	r2, [r7, #12]
 8108610:	6939      	ldr	r1, [r7, #16]
 8108612:	69f8      	ldr	r0, [r7, #28]
 8108614:	f000 f952 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 8108618:	4602      	mov	r2, r0
 810861a:	687b      	ldr	r3, [r7, #4]
 810861c:	605a      	str	r2, [r3, #4]
    }

    if (LL_RCC_PLL1R_IsEnabled() != 0U)
 810861e:	f7ff fd89 	bl	8108134 <LL_RCC_PLL1R_IsEnabled>
 8108622:	4603      	mov	r3, r0
 8108624:	2b00      	cmp	r3, #0
 8108626:	d00c      	beq.n	8108642 <LL_RCC_GetPLL1ClockFreq+0x11a>
    {
      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetR());
 8108628:	f7ff fde6 	bl	81081f8 <LL_RCC_PLL1_GetR>
 810862c:	4603      	mov	r3, r0
 810862e:	9300      	str	r3, [sp, #0]
 8108630:	69bb      	ldr	r3, [r7, #24]
 8108632:	68fa      	ldr	r2, [r7, #12]
 8108634:	6939      	ldr	r1, [r7, #16]
 8108636:	69f8      	ldr	r0, [r7, #28]
 8108638:	f000 f940 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 810863c:	4602      	mov	r2, r0
 810863e:	687b      	ldr	r3, [r7, #4]
 8108640:	609a      	str	r2, [r3, #8]
    }
  }
}
 8108642:	bf00      	nop
 8108644:	3720      	adds	r7, #32
 8108646:	46bd      	mov	sp, r7
 8108648:	bd80      	pop	{r7, pc}
 810864a:	bf00      	nop
 810864c:	03d09000 	.word	0x03d09000
 8108650:	003d0900 	.word	0x003d0900
 8108654:	017d7840 	.word	0x017d7840

08108658 <LL_RCC_GetPLL2ClockFreq>:
  * @brief  Return PLL2 clocks frequencies
  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval None
  */
void LL_RCC_GetPLL2ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)
{
 8108658:	b580      	push	{r7, lr}
 810865a:	b08a      	sub	sp, #40	@ 0x28
 810865c:	af02      	add	r7, sp, #8
 810865e:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8108660:	2300      	movs	r3, #0
 8108662:	61fb      	str	r3, [r7, #28]
  uint32_t m, n, fracn = 0U;
 8108664:	2300      	movs	r3, #0
 8108666:	61bb      	str	r3, [r7, #24]

  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP
  */
  pllsource = LL_RCC_PLL_GetSource();
 8108668:	f7ff fd2e 	bl	81080c8 <LL_RCC_PLL_GetSource>
 810866c:	6178      	str	r0, [r7, #20]

  switch (pllsource)
 810866e:	697b      	ldr	r3, [r7, #20]
 8108670:	2b02      	cmp	r3, #2
 8108672:	d01f      	beq.n	81086b4 <LL_RCC_GetPLL2ClockFreq+0x5c>
 8108674:	697b      	ldr	r3, [r7, #20]
 8108676:	2b02      	cmp	r3, #2
 8108678:	d824      	bhi.n	81086c4 <LL_RCC_GetPLL2ClockFreq+0x6c>
 810867a:	697b      	ldr	r3, [r7, #20]
 810867c:	2b00      	cmp	r3, #0
 810867e:	d003      	beq.n	8108688 <LL_RCC_GetPLL2ClockFreq+0x30>
 8108680:	697b      	ldr	r3, [r7, #20]
 8108682:	2b01      	cmp	r3, #1
 8108684:	d00e      	beq.n	81086a4 <LL_RCC_GetPLL2ClockFreq+0x4c>
      break;

    case LL_RCC_PLLSOURCE_NONE:
    default:
      /* PLL clock disabled */
      break;
 8108686:	e01d      	b.n	81086c4 <LL_RCC_GetPLL2ClockFreq+0x6c>
      if (LL_RCC_HSI_IsReady() != 0U)
 8108688:	f7ff fc60 	bl	8107f4c <LL_RCC_HSI_IsReady>
 810868c:	4603      	mov	r3, r0
 810868e:	2b00      	cmp	r3, #0
 8108690:	d01a      	beq.n	81086c8 <LL_RCC_GetPLL2ClockFreq+0x70>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8108692:	f7ff fc6d 	bl	8107f70 <LL_RCC_HSI_GetDivider>
 8108696:	4603      	mov	r3, r0
 8108698:	08db      	lsrs	r3, r3, #3
 810869a:	4a38      	ldr	r2, [pc, #224]	@ (810877c <LL_RCC_GetPLL2ClockFreq+0x124>)
 810869c:	fa22 f303 	lsr.w	r3, r2, r3
 81086a0:	61fb      	str	r3, [r7, #28]
      break;
 81086a2:	e011      	b.n	81086c8 <LL_RCC_GetPLL2ClockFreq+0x70>
      if (LL_RCC_CSI_IsReady() != 0U)
 81086a4:	f7ff fc72 	bl	8107f8c <LL_RCC_CSI_IsReady>
 81086a8:	4603      	mov	r3, r0
 81086aa:	2b00      	cmp	r3, #0
 81086ac:	d00e      	beq.n	81086cc <LL_RCC_GetPLL2ClockFreq+0x74>
        pllinputfreq = CSI_VALUE;
 81086ae:	4b34      	ldr	r3, [pc, #208]	@ (8108780 <LL_RCC_GetPLL2ClockFreq+0x128>)
 81086b0:	61fb      	str	r3, [r7, #28]
      break;
 81086b2:	e00b      	b.n	81086cc <LL_RCC_GetPLL2ClockFreq+0x74>
      if (LL_RCC_HSE_IsReady() != 0U)
 81086b4:	f7ff fc36 	bl	8107f24 <LL_RCC_HSE_IsReady>
 81086b8:	4603      	mov	r3, r0
 81086ba:	2b00      	cmp	r3, #0
 81086bc:	d008      	beq.n	81086d0 <LL_RCC_GetPLL2ClockFreq+0x78>
        pllinputfreq = HSE_VALUE;
 81086be:	4b31      	ldr	r3, [pc, #196]	@ (8108784 <LL_RCC_GetPLL2ClockFreq+0x12c>)
 81086c0:	61fb      	str	r3, [r7, #28]
      break;
 81086c2:	e005      	b.n	81086d0 <LL_RCC_GetPLL2ClockFreq+0x78>
      break;
 81086c4:	bf00      	nop
 81086c6:	e004      	b.n	81086d2 <LL_RCC_GetPLL2ClockFreq+0x7a>
      break;
 81086c8:	bf00      	nop
 81086ca:	e002      	b.n	81086d2 <LL_RCC_GetPLL2ClockFreq+0x7a>
      break;
 81086cc:	bf00      	nop
 81086ce:	e000      	b.n	81086d2 <LL_RCC_GetPLL2ClockFreq+0x7a>
      break;
 81086d0:	bf00      	nop
  }

  PLL_Clocks->PLL_P_Frequency = 0U;
 81086d2:	687b      	ldr	r3, [r7, #4]
 81086d4:	2200      	movs	r2, #0
 81086d6:	601a      	str	r2, [r3, #0]
  PLL_Clocks->PLL_Q_Frequency = 0U;
 81086d8:	687b      	ldr	r3, [r7, #4]
 81086da:	2200      	movs	r2, #0
 81086dc:	605a      	str	r2, [r3, #4]
  PLL_Clocks->PLL_R_Frequency = 0U;
 81086de:	687b      	ldr	r3, [r7, #4]
 81086e0:	2200      	movs	r2, #0
 81086e2:	609a      	str	r2, [r3, #8]

  m = LL_RCC_PLL2_GetM();
 81086e4:	f7ff fe16 	bl	8108314 <LL_RCC_PLL2_GetM>
 81086e8:	6138      	str	r0, [r7, #16]
  n = LL_RCC_PLL2_GetN();
 81086ea:	f7ff fe05 	bl	81082f8 <LL_RCC_PLL2_GetN>
 81086ee:	60f8      	str	r0, [r7, #12]
  if (LL_RCC_PLL2FRACN_IsEnabled() != 0U)
 81086f0:	f7ff fdf0 	bl	81082d4 <LL_RCC_PLL2FRACN_IsEnabled>
 81086f4:	4603      	mov	r3, r0
 81086f6:	2b00      	cmp	r3, #0
 81086f8:	d002      	beq.n	8108700 <LL_RCC_GetPLL2ClockFreq+0xa8>
  {
    fracn = LL_RCC_PLL2_GetFRACN();
 81086fa:	f7ff fe49 	bl	8108390 <LL_RCC_PLL2_GetFRACN>
 81086fe:	61b8      	str	r0, [r7, #24]
  }

  if (m != 0U)
 8108700:	693b      	ldr	r3, [r7, #16]
 8108702:	2b00      	cmp	r3, #0
 8108704:	d035      	beq.n	8108772 <LL_RCC_GetPLL2ClockFreq+0x11a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
 8108706:	f7ff fda9 	bl	810825c <LL_RCC_PLL2P_IsEnabled>
 810870a:	4603      	mov	r3, r0
 810870c:	2b00      	cmp	r3, #0
 810870e:	d00c      	beq.n	810872a <LL_RCC_GetPLL2ClockFreq+0xd2>
    {
      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetP());
 8108710:	f7ff fe0e 	bl	8108330 <LL_RCC_PLL2_GetP>
 8108714:	4603      	mov	r3, r0
 8108716:	9300      	str	r3, [sp, #0]
 8108718:	69bb      	ldr	r3, [r7, #24]
 810871a:	68fa      	ldr	r2, [r7, #12]
 810871c:	6939      	ldr	r1, [r7, #16]
 810871e:	69f8      	ldr	r0, [r7, #28]
 8108720:	f000 f8cc 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 8108724:	4602      	mov	r2, r0
 8108726:	687b      	ldr	r3, [r7, #4]
 8108728:	601a      	str	r2, [r3, #0]
    }

    if (LL_RCC_PLL2Q_IsEnabled() != 0U)
 810872a:	f7ff fdab 	bl	8108284 <LL_RCC_PLL2Q_IsEnabled>
 810872e:	4603      	mov	r3, r0
 8108730:	2b00      	cmp	r3, #0
 8108732:	d00c      	beq.n	810874e <LL_RCC_GetPLL2ClockFreq+0xf6>
    {
      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetQ());
 8108734:	f7ff fe0c 	bl	8108350 <LL_RCC_PLL2_GetQ>
 8108738:	4603      	mov	r3, r0
 810873a:	9300      	str	r3, [sp, #0]
 810873c:	69bb      	ldr	r3, [r7, #24]
 810873e:	68fa      	ldr	r2, [r7, #12]
 8108740:	6939      	ldr	r1, [r7, #16]
 8108742:	69f8      	ldr	r0, [r7, #28]
 8108744:	f000 f8ba 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 8108748:	4602      	mov	r2, r0
 810874a:	687b      	ldr	r3, [r7, #4]
 810874c:	605a      	str	r2, [r3, #4]
    }

    if (LL_RCC_PLL2R_IsEnabled() != 0U)
 810874e:	f7ff fdad 	bl	81082ac <LL_RCC_PLL2R_IsEnabled>
 8108752:	4603      	mov	r3, r0
 8108754:	2b00      	cmp	r3, #0
 8108756:	d00c      	beq.n	8108772 <LL_RCC_GetPLL2ClockFreq+0x11a>
    {
      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetR());
 8108758:	f7ff fe0a 	bl	8108370 <LL_RCC_PLL2_GetR>
 810875c:	4603      	mov	r3, r0
 810875e:	9300      	str	r3, [sp, #0]
 8108760:	69bb      	ldr	r3, [r7, #24]
 8108762:	68fa      	ldr	r2, [r7, #12]
 8108764:	6939      	ldr	r1, [r7, #16]
 8108766:	69f8      	ldr	r0, [r7, #28]
 8108768:	f000 f8a8 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 810876c:	4602      	mov	r2, r0
 810876e:	687b      	ldr	r3, [r7, #4]
 8108770:	609a      	str	r2, [r3, #8]
    }
  }
}
 8108772:	bf00      	nop
 8108774:	3720      	adds	r7, #32
 8108776:	46bd      	mov	sp, r7
 8108778:	bd80      	pop	{r7, pc}
 810877a:	bf00      	nop
 810877c:	03d09000 	.word	0x03d09000
 8108780:	003d0900 	.word	0x003d0900
 8108784:	017d7840 	.word	0x017d7840

08108788 <LL_RCC_GetPLL3ClockFreq>:
  * @brief  Return PLL3 clocks frequencies
  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval None
  */
void LL_RCC_GetPLL3ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)
{
 8108788:	b580      	push	{r7, lr}
 810878a:	b08a      	sub	sp, #40	@ 0x28
 810878c:	af02      	add	r7, sp, #8
 810878e:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8108790:	2300      	movs	r3, #0
 8108792:	61fb      	str	r3, [r7, #28]
  uint32_t m, n, fracn = 0U;
 8108794:	2300      	movs	r3, #0
 8108796:	61bb      	str	r3, [r7, #24]

  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP
  */
  pllsource = LL_RCC_PLL_GetSource();
 8108798:	f7ff fc96 	bl	81080c8 <LL_RCC_PLL_GetSource>
 810879c:	6178      	str	r0, [r7, #20]

  switch (pllsource)
 810879e:	697b      	ldr	r3, [r7, #20]
 81087a0:	2b02      	cmp	r3, #2
 81087a2:	d01f      	beq.n	81087e4 <LL_RCC_GetPLL3ClockFreq+0x5c>
 81087a4:	697b      	ldr	r3, [r7, #20]
 81087a6:	2b02      	cmp	r3, #2
 81087a8:	d824      	bhi.n	81087f4 <LL_RCC_GetPLL3ClockFreq+0x6c>
 81087aa:	697b      	ldr	r3, [r7, #20]
 81087ac:	2b00      	cmp	r3, #0
 81087ae:	d003      	beq.n	81087b8 <LL_RCC_GetPLL3ClockFreq+0x30>
 81087b0:	697b      	ldr	r3, [r7, #20]
 81087b2:	2b01      	cmp	r3, #1
 81087b4:	d00e      	beq.n	81087d4 <LL_RCC_GetPLL3ClockFreq+0x4c>
      break;

    case LL_RCC_PLLSOURCE_NONE:
    default:
      /* PLL clock disabled */
      break;
 81087b6:	e01d      	b.n	81087f4 <LL_RCC_GetPLL3ClockFreq+0x6c>
      if (LL_RCC_HSI_IsReady() != 0U)
 81087b8:	f7ff fbc8 	bl	8107f4c <LL_RCC_HSI_IsReady>
 81087bc:	4603      	mov	r3, r0
 81087be:	2b00      	cmp	r3, #0
 81087c0:	d01a      	beq.n	81087f8 <LL_RCC_GetPLL3ClockFreq+0x70>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 81087c2:	f7ff fbd5 	bl	8107f70 <LL_RCC_HSI_GetDivider>
 81087c6:	4603      	mov	r3, r0
 81087c8:	08db      	lsrs	r3, r3, #3
 81087ca:	4a39      	ldr	r2, [pc, #228]	@ (81088b0 <LL_RCC_GetPLL3ClockFreq+0x128>)
 81087cc:	fa22 f303 	lsr.w	r3, r2, r3
 81087d0:	61fb      	str	r3, [r7, #28]
      break;
 81087d2:	e011      	b.n	81087f8 <LL_RCC_GetPLL3ClockFreq+0x70>
      if (LL_RCC_CSI_IsReady() != 0U)
 81087d4:	f7ff fbda 	bl	8107f8c <LL_RCC_CSI_IsReady>
 81087d8:	4603      	mov	r3, r0
 81087da:	2b00      	cmp	r3, #0
 81087dc:	d00e      	beq.n	81087fc <LL_RCC_GetPLL3ClockFreq+0x74>
        pllinputfreq = CSI_VALUE;
 81087de:	4b35      	ldr	r3, [pc, #212]	@ (81088b4 <LL_RCC_GetPLL3ClockFreq+0x12c>)
 81087e0:	61fb      	str	r3, [r7, #28]
      break;
 81087e2:	e00b      	b.n	81087fc <LL_RCC_GetPLL3ClockFreq+0x74>
      if (LL_RCC_HSE_IsReady() != 0U)
 81087e4:	f7ff fb9e 	bl	8107f24 <LL_RCC_HSE_IsReady>
 81087e8:	4603      	mov	r3, r0
 81087ea:	2b00      	cmp	r3, #0
 81087ec:	d008      	beq.n	8108800 <LL_RCC_GetPLL3ClockFreq+0x78>
        pllinputfreq = HSE_VALUE;
 81087ee:	4b32      	ldr	r3, [pc, #200]	@ (81088b8 <LL_RCC_GetPLL3ClockFreq+0x130>)
 81087f0:	61fb      	str	r3, [r7, #28]
      break;
 81087f2:	e005      	b.n	8108800 <LL_RCC_GetPLL3ClockFreq+0x78>
      break;
 81087f4:	bf00      	nop
 81087f6:	e004      	b.n	8108802 <LL_RCC_GetPLL3ClockFreq+0x7a>
      break;
 81087f8:	bf00      	nop
 81087fa:	e002      	b.n	8108802 <LL_RCC_GetPLL3ClockFreq+0x7a>
      break;
 81087fc:	bf00      	nop
 81087fe:	e000      	b.n	8108802 <LL_RCC_GetPLL3ClockFreq+0x7a>
      break;
 8108800:	bf00      	nop
  }

  PLL_Clocks->PLL_P_Frequency = 0U;
 8108802:	687b      	ldr	r3, [r7, #4]
 8108804:	2200      	movs	r2, #0
 8108806:	601a      	str	r2, [r3, #0]
  PLL_Clocks->PLL_Q_Frequency = 0U;
 8108808:	687b      	ldr	r3, [r7, #4]
 810880a:	2200      	movs	r2, #0
 810880c:	605a      	str	r2, [r3, #4]
  PLL_Clocks->PLL_R_Frequency = 0U;
 810880e:	687b      	ldr	r3, [r7, #4]
 8108810:	2200      	movs	r2, #0
 8108812:	609a      	str	r2, [r3, #8]

  m = LL_RCC_PLL3_GetM();
 8108814:	f7ff fe3c 	bl	8108490 <LL_RCC_PLL3_GetM>
 8108818:	6138      	str	r0, [r7, #16]
  n = LL_RCC_PLL3_GetN();
 810881a:	f7ff fe2b 	bl	8108474 <LL_RCC_PLL3_GetN>
 810881e:	60f8      	str	r0, [r7, #12]
  if (LL_RCC_PLL3FRACN_IsEnabled() != 0U)
 8108820:	f7ff fe14 	bl	810844c <LL_RCC_PLL3FRACN_IsEnabled>
 8108824:	4603      	mov	r3, r0
 8108826:	2b00      	cmp	r3, #0
 8108828:	d002      	beq.n	8108830 <LL_RCC_GetPLL3ClockFreq+0xa8>
  {
    fracn = LL_RCC_PLL3_GetFRACN();
 810882a:	f7ff fe6f 	bl	810850c <LL_RCC_PLL3_GetFRACN>
 810882e:	61b8      	str	r0, [r7, #24]
  }

  if ((m != 0U) && (pllinputfreq != 0U))
 8108830:	693b      	ldr	r3, [r7, #16]
 8108832:	2b00      	cmp	r3, #0
 8108834:	d038      	beq.n	81088a8 <LL_RCC_GetPLL3ClockFreq+0x120>
 8108836:	69fb      	ldr	r3, [r7, #28]
 8108838:	2b00      	cmp	r3, #0
 810883a:	d035      	beq.n	81088a8 <LL_RCC_GetPLL3ClockFreq+0x120>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
 810883c:	f7ff fdca 	bl	81083d4 <LL_RCC_PLL3P_IsEnabled>
 8108840:	4603      	mov	r3, r0
 8108842:	2b00      	cmp	r3, #0
 8108844:	d00c      	beq.n	8108860 <LL_RCC_GetPLL3ClockFreq+0xd8>
    {
      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetP());
 8108846:	f7ff fe31 	bl	81084ac <LL_RCC_PLL3_GetP>
 810884a:	4603      	mov	r3, r0
 810884c:	9300      	str	r3, [sp, #0]
 810884e:	69bb      	ldr	r3, [r7, #24]
 8108850:	68fa      	ldr	r2, [r7, #12]
 8108852:	6939      	ldr	r1, [r7, #16]
 8108854:	69f8      	ldr	r0, [r7, #28]
 8108856:	f000 f831 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 810885a:	4602      	mov	r2, r0
 810885c:	687b      	ldr	r3, [r7, #4]
 810885e:	601a      	str	r2, [r3, #0]
    }

    if (LL_RCC_PLL3Q_IsEnabled() != 0U)
 8108860:	f7ff fdcc 	bl	81083fc <LL_RCC_PLL3Q_IsEnabled>
 8108864:	4603      	mov	r3, r0
 8108866:	2b00      	cmp	r3, #0
 8108868:	d00c      	beq.n	8108884 <LL_RCC_GetPLL3ClockFreq+0xfc>
    {
      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetQ());
 810886a:	f7ff fe2f 	bl	81084cc <LL_RCC_PLL3_GetQ>
 810886e:	4603      	mov	r3, r0
 8108870:	9300      	str	r3, [sp, #0]
 8108872:	69bb      	ldr	r3, [r7, #24]
 8108874:	68fa      	ldr	r2, [r7, #12]
 8108876:	6939      	ldr	r1, [r7, #16]
 8108878:	69f8      	ldr	r0, [r7, #28]
 810887a:	f000 f81f 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 810887e:	4602      	mov	r2, r0
 8108880:	687b      	ldr	r3, [r7, #4]
 8108882:	605a      	str	r2, [r3, #4]
    }

    if (LL_RCC_PLL3R_IsEnabled() != 0U)
 8108884:	f7ff fdce 	bl	8108424 <LL_RCC_PLL3R_IsEnabled>
 8108888:	4603      	mov	r3, r0
 810888a:	2b00      	cmp	r3, #0
 810888c:	d00c      	beq.n	81088a8 <LL_RCC_GetPLL3ClockFreq+0x120>
    {
      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetR());
 810888e:	f7ff fe2d 	bl	81084ec <LL_RCC_PLL3_GetR>
 8108892:	4603      	mov	r3, r0
 8108894:	9300      	str	r3, [sp, #0]
 8108896:	69bb      	ldr	r3, [r7, #24]
 8108898:	68fa      	ldr	r2, [r7, #12]
 810889a:	6939      	ldr	r1, [r7, #16]
 810889c:	69f8      	ldr	r0, [r7, #28]
 810889e:	f000 f80d 	bl	81088bc <LL_RCC_CalcPLLClockFreq>
 81088a2:	4602      	mov	r2, r0
 81088a4:	687b      	ldr	r3, [r7, #4]
 81088a6:	609a      	str	r2, [r3, #8]
    }
  }
}
 81088a8:	bf00      	nop
 81088aa:	3720      	adds	r7, #32
 81088ac:	46bd      	mov	sp, r7
 81088ae:	bd80      	pop	{r7, pc}
 81088b0:	03d09000 	.word	0x03d09000
 81088b4:	003d0900 	.word	0x003d0900
 81088b8:	017d7840 	.word	0x017d7840

081088bc <LL_RCC_CalcPLLClockFreq>:
  * @param  PQR    VCO output divider (P, Q or R)
  *                Between 1 and 128, except for PLL1P Odd value not allowed
  * @retval PLL1 clock frequency (in Hz)
  */
uint32_t LL_RCC_CalcPLLClockFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t PQR)
{
 81088bc:	b480      	push	{r7}
 81088be:	b087      	sub	sp, #28
 81088c0:	af00      	add	r7, sp, #0
 81088c2:	60f8      	str	r0, [r7, #12]
 81088c4:	60b9      	str	r1, [r7, #8]
 81088c6:	607a      	str	r2, [r7, #4]
 81088c8:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 81088ca:	68fb      	ldr	r3, [r7, #12]
 81088cc:	ee07 3a90 	vmov	s15, r3
 81088d0:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81088d4:	68bb      	ldr	r3, [r7, #8]
 81088d6:	ee07 3a90 	vmov	s15, r3
 81088da:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81088de:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81088e2:	687b      	ldr	r3, [r7, #4]
 81088e4:	ee07 3a90 	vmov	s15, r3
 81088e8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81088ec:	683b      	ldr	r3, [r7, #0]
 81088ee:	ee07 3a90 	vmov	s15, r3
 81088f2:	eeb8 6a67 	vcvt.f32.u32	s12, s15
 81088f6:	eddf 5a10 	vldr	s11, [pc, #64]	@ 8108938 <LL_RCC_CalcPLLClockFreq+0x7c>
 81088fa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81088fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8108902:	ee67 7a27 	vmul.f32	s15, s14, s15
 8108906:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)PQR;
 810890a:	6a3b      	ldr	r3, [r7, #32]
 810890c:	ee07 3a90 	vmov	s15, r3
 8108910:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8108914:	edd7 6a05 	vldr	s13, [r7, #20]
 8108918:	eec6 7a87 	vdiv.f32	s15, s13, s14
 810891c:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
 8108920:	edd7 7a05 	vldr	s15, [r7, #20]
 8108924:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8108928:	ee17 3a90 	vmov	r3, s15
}
 810892c:	4618      	mov	r0, r3
 810892e:	371c      	adds	r7, #28
 8108930:	46bd      	mov	sp, r7
 8108932:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108936:	4770      	bx	lr
 8108938:	46000000 	.word	0x46000000

0810893c <LL_RCC_GetUSARTClockFreq>:
  *         @arg @ref LL_RCC_USART234578_CLKSOURCE
  * @retval USART clock frequency (in Hz)
  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
uint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)
{
 810893c:	b590      	push	{r4, r7, lr}
 810893e:	b087      	sub	sp, #28
 8108940:	af00      	add	r7, sp, #0
 8108942:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 8108944:	2300      	movs	r3, #0
 8108946:	617b      	str	r3, [r7, #20]
  LL_PLL_ClocksTypeDef PLL_Clocks;

  /* Check parameter */
  assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8108948:	6878      	ldr	r0, [r7, #4]
 810894a:	f7ff fbb1 	bl	81080b0 <LL_RCC_GetUSARTClockSource>
 810894e:	4603      	mov	r3, r0
 8108950:	4a62      	ldr	r2, [pc, #392]	@ (8108adc <LL_RCC_GetUSARTClockFreq+0x1a0>)
 8108952:	4293      	cmp	r3, r2
 8108954:	f000 80a9 	beq.w	8108aaa <LL_RCC_GetUSARTClockFreq+0x16e>
 8108958:	4a60      	ldr	r2, [pc, #384]	@ (8108adc <LL_RCC_GetUSARTClockFreq+0x1a0>)
 810895a:	4293      	cmp	r3, r2
 810895c:	f200 80ae 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 8108960:	4a5f      	ldr	r2, [pc, #380]	@ (8108ae0 <LL_RCC_GetUSARTClockFreq+0x1a4>)
 8108962:	4293      	cmp	r3, r2
 8108964:	f000 80a1 	beq.w	8108aaa <LL_RCC_GetUSARTClockFreq+0x16e>
 8108968:	4a5d      	ldr	r2, [pc, #372]	@ (8108ae0 <LL_RCC_GetUSARTClockFreq+0x1a4>)
 810896a:	4293      	cmp	r3, r2
 810896c:	f200 80a6 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 8108970:	4a5c      	ldr	r2, [pc, #368]	@ (8108ae4 <LL_RCC_GetUSARTClockFreq+0x1a8>)
 8108972:	4293      	cmp	r3, r2
 8108974:	f000 8091 	beq.w	8108a9a <LL_RCC_GetUSARTClockFreq+0x15e>
 8108978:	4a5a      	ldr	r2, [pc, #360]	@ (8108ae4 <LL_RCC_GetUSARTClockFreq+0x1a8>)
 810897a:	4293      	cmp	r3, r2
 810897c:	f200 809e 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 8108980:	4a59      	ldr	r2, [pc, #356]	@ (8108ae8 <LL_RCC_GetUSARTClockFreq+0x1ac>)
 8108982:	4293      	cmp	r3, r2
 8108984:	f000 8089 	beq.w	8108a9a <LL_RCC_GetUSARTClockFreq+0x15e>
 8108988:	4a57      	ldr	r2, [pc, #348]	@ (8108ae8 <LL_RCC_GetUSARTClockFreq+0x1ac>)
 810898a:	4293      	cmp	r3, r2
 810898c:	f200 8096 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 8108990:	4a56      	ldr	r2, [pc, #344]	@ (8108aec <LL_RCC_GetUSARTClockFreq+0x1b0>)
 8108992:	4293      	cmp	r3, r2
 8108994:	d073      	beq.n	8108a7e <LL_RCC_GetUSARTClockFreq+0x142>
 8108996:	4a55      	ldr	r2, [pc, #340]	@ (8108aec <LL_RCC_GetUSARTClockFreq+0x1b0>)
 8108998:	4293      	cmp	r3, r2
 810899a:	f200 808f 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 810899e:	4a54      	ldr	r2, [pc, #336]	@ (8108af0 <LL_RCC_GetUSARTClockFreq+0x1b4>)
 81089a0:	4293      	cmp	r3, r2
 81089a2:	d06c      	beq.n	8108a7e <LL_RCC_GetUSARTClockFreq+0x142>
 81089a4:	4a52      	ldr	r2, [pc, #328]	@ (8108af0 <LL_RCC_GetUSARTClockFreq+0x1b4>)
 81089a6:	4293      	cmp	r3, r2
 81089a8:	f200 8088 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 81089ac:	4a51      	ldr	r2, [pc, #324]	@ (8108af4 <LL_RCC_GetUSARTClockFreq+0x1b8>)
 81089ae:	4293      	cmp	r3, r2
 81089b0:	d058      	beq.n	8108a64 <LL_RCC_GetUSARTClockFreq+0x128>
 81089b2:	4a50      	ldr	r2, [pc, #320]	@ (8108af4 <LL_RCC_GetUSARTClockFreq+0x1b8>)
 81089b4:	4293      	cmp	r3, r2
 81089b6:	f200 8081 	bhi.w	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 81089ba:	4a4f      	ldr	r2, [pc, #316]	@ (8108af8 <LL_RCC_GetUSARTClockFreq+0x1bc>)
 81089bc:	4293      	cmp	r3, r2
 81089be:	d051      	beq.n	8108a64 <LL_RCC_GetUSARTClockFreq+0x128>
 81089c0:	4a4d      	ldr	r2, [pc, #308]	@ (8108af8 <LL_RCC_GetUSARTClockFreq+0x1bc>)
 81089c2:	4293      	cmp	r3, r2
 81089c4:	d87a      	bhi.n	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 81089c6:	4a4d      	ldr	r2, [pc, #308]	@ (8108afc <LL_RCC_GetUSARTClockFreq+0x1c0>)
 81089c8:	4293      	cmp	r3, r2
 81089ca:	d03e      	beq.n	8108a4a <LL_RCC_GetUSARTClockFreq+0x10e>
 81089cc:	4a4b      	ldr	r2, [pc, #300]	@ (8108afc <LL_RCC_GetUSARTClockFreq+0x1c0>)
 81089ce:	4293      	cmp	r3, r2
 81089d0:	d874      	bhi.n	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 81089d2:	4a4b      	ldr	r2, [pc, #300]	@ (8108b00 <LL_RCC_GetUSARTClockFreq+0x1c4>)
 81089d4:	4293      	cmp	r3, r2
 81089d6:	d038      	beq.n	8108a4a <LL_RCC_GetUSARTClockFreq+0x10e>
 81089d8:	4a49      	ldr	r2, [pc, #292]	@ (8108b00 <LL_RCC_GetUSARTClockFreq+0x1c4>)
 81089da:	4293      	cmp	r3, r2
 81089dc:	d86e      	bhi.n	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
 81089de:	4a49      	ldr	r2, [pc, #292]	@ (8108b04 <LL_RCC_GetUSARTClockFreq+0x1c8>)
 81089e0:	4293      	cmp	r3, r2
 81089e2:	d01a      	beq.n	8108a1a <LL_RCC_GetUSARTClockFreq+0xde>
 81089e4:	4a48      	ldr	r2, [pc, #288]	@ (8108b08 <LL_RCC_GetUSARTClockFreq+0x1cc>)
 81089e6:	4293      	cmp	r3, r2
 81089e8:	d168      	bne.n	8108abc <LL_RCC_GetUSARTClockFreq+0x180>
  {
    case LL_RCC_USART16_CLKSOURCE_PCLK2:
      usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 81089ea:	f000 f895 	bl	8108b18 <RCC_GetSystemClockFreq>
 81089ee:	4604      	mov	r4, r0
 81089f0:	f7ff fb00 	bl	8107ff4 <LL_RCC_GetSysPrescaler>
 81089f4:	4603      	mov	r3, r0
 81089f6:	0a1b      	lsrs	r3, r3, #8
 81089f8:	f003 030f 	and.w	r3, r3, #15
 81089fc:	4a43      	ldr	r2, [pc, #268]	@ (8108b0c <LL_RCC_GetUSARTClockFreq+0x1d0>)
 81089fe:	5cd3      	ldrb	r3, [r2, r3]
 8108a00:	f003 031f 	and.w	r3, r3, #31
 8108a04:	fa24 f303 	lsr.w	r3, r4, r3
 8108a08:	4618      	mov	r0, r3
 8108a0a:	f000 f8e7 	bl	8108bdc <RCC_GetHCLKClockFreq>
 8108a0e:	4603      	mov	r3, r0
 8108a10:	4618      	mov	r0, r3
 8108a12:	f000 f911 	bl	8108c38 <RCC_GetPCLK2ClockFreq>
 8108a16:	6178      	str	r0, [r7, #20]
      break;
 8108a18:	e05b      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>

    case LL_RCC_USART234578_CLKSOURCE_PCLK1:
      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 8108a1a:	f000 f87d 	bl	8108b18 <RCC_GetSystemClockFreq>
 8108a1e:	4604      	mov	r4, r0
 8108a20:	f7ff fae8 	bl	8107ff4 <LL_RCC_GetSysPrescaler>
 8108a24:	4603      	mov	r3, r0
 8108a26:	0a1b      	lsrs	r3, r3, #8
 8108a28:	f003 030f 	and.w	r3, r3, #15
 8108a2c:	4a37      	ldr	r2, [pc, #220]	@ (8108b0c <LL_RCC_GetUSARTClockFreq+0x1d0>)
 8108a2e:	5cd3      	ldrb	r3, [r2, r3]
 8108a30:	f003 031f 	and.w	r3, r3, #31
 8108a34:	fa24 f303 	lsr.w	r3, r4, r3
 8108a38:	4618      	mov	r0, r3
 8108a3a:	f000 f8cf 	bl	8108bdc <RCC_GetHCLKClockFreq>
 8108a3e:	4603      	mov	r3, r0
 8108a40:	4618      	mov	r0, r3
 8108a42:	f000 f8e1 	bl	8108c08 <RCC_GetPCLK1ClockFreq>
 8108a46:	6178      	str	r0, [r7, #20]
      break;
 8108a48:	e043      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>

    case LL_RCC_USART16_CLKSOURCE_PLL2Q:
    case LL_RCC_USART234578_CLKSOURCE_PLL2Q:
      if (LL_RCC_PLL2_IsReady() != 0U)
 8108a4a:	f7ff fbf3 	bl	8108234 <LL_RCC_PLL2_IsReady>
 8108a4e:	4603      	mov	r3, r0
 8108a50:	2b00      	cmp	r3, #0
 8108a52:	d035      	beq.n	8108ac0 <LL_RCC_GetUSARTClockFreq+0x184>
      {
        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);
 8108a54:	f107 0308 	add.w	r3, r7, #8
 8108a58:	4618      	mov	r0, r3
 8108a5a:	f7ff fdfd 	bl	8108658 <LL_RCC_GetPLL2ClockFreq>
        usart_frequency = PLL_Clocks.PLL_Q_Frequency;
 8108a5e:	68fb      	ldr	r3, [r7, #12]
 8108a60:	617b      	str	r3, [r7, #20]
      }
      break;
 8108a62:	e02d      	b.n	8108ac0 <LL_RCC_GetUSARTClockFreq+0x184>

    case LL_RCC_USART16_CLKSOURCE_PLL3Q:
    case LL_RCC_USART234578_CLKSOURCE_PLL3Q:
      if (LL_RCC_PLL3_IsReady() != 0U)
 8108a64:	f7ff fca2 	bl	81083ac <LL_RCC_PLL3_IsReady>
 8108a68:	4603      	mov	r3, r0
 8108a6a:	2b00      	cmp	r3, #0
 8108a6c:	d02a      	beq.n	8108ac4 <LL_RCC_GetUSARTClockFreq+0x188>
      {
        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);
 8108a6e:	f107 0308 	add.w	r3, r7, #8
 8108a72:	4618      	mov	r0, r3
 8108a74:	f7ff fe88 	bl	8108788 <LL_RCC_GetPLL3ClockFreq>
        usart_frequency = PLL_Clocks.PLL_Q_Frequency;
 8108a78:	68fb      	ldr	r3, [r7, #12]
 8108a7a:	617b      	str	r3, [r7, #20]
      }
      break;
 8108a7c:	e022      	b.n	8108ac4 <LL_RCC_GetUSARTClockFreq+0x188>

    case LL_RCC_USART16_CLKSOURCE_HSI:
    case LL_RCC_USART234578_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
 8108a7e:	f7ff fa65 	bl	8107f4c <LL_RCC_HSI_IsReady>
 8108a82:	4603      	mov	r3, r0
 8108a84:	2b00      	cmp	r3, #0
 8108a86:	d01f      	beq.n	8108ac8 <LL_RCC_GetUSARTClockFreq+0x18c>
      {
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8108a88:	f7ff fa72 	bl	8107f70 <LL_RCC_HSI_GetDivider>
 8108a8c:	4603      	mov	r3, r0
 8108a8e:	08db      	lsrs	r3, r3, #3
 8108a90:	4a1f      	ldr	r2, [pc, #124]	@ (8108b10 <LL_RCC_GetUSARTClockFreq+0x1d4>)
 8108a92:	fa22 f303 	lsr.w	r3, r2, r3
 8108a96:	617b      	str	r3, [r7, #20]
      }
      break;
 8108a98:	e016      	b.n	8108ac8 <LL_RCC_GetUSARTClockFreq+0x18c>

    case LL_RCC_USART16_CLKSOURCE_CSI:
    case LL_RCC_USART234578_CLKSOURCE_CSI:
      if (LL_RCC_CSI_IsReady() != 0U)
 8108a9a:	f7ff fa77 	bl	8107f8c <LL_RCC_CSI_IsReady>
 8108a9e:	4603      	mov	r3, r0
 8108aa0:	2b00      	cmp	r3, #0
 8108aa2:	d013      	beq.n	8108acc <LL_RCC_GetUSARTClockFreq+0x190>
      {
        usart_frequency = CSI_VALUE;
 8108aa4:	4b1b      	ldr	r3, [pc, #108]	@ (8108b14 <LL_RCC_GetUSARTClockFreq+0x1d8>)
 8108aa6:	617b      	str	r3, [r7, #20]
      }
      break;
 8108aa8:	e010      	b.n	8108acc <LL_RCC_GetUSARTClockFreq+0x190>

    case LL_RCC_USART16_CLKSOURCE_LSE:
    case LL_RCC_USART234578_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
 8108aaa:	f7ff fa83 	bl	8107fb4 <LL_RCC_LSE_IsReady>
 8108aae:	4603      	mov	r3, r0
 8108ab0:	2b00      	cmp	r3, #0
 8108ab2:	d00d      	beq.n	8108ad0 <LL_RCC_GetUSARTClockFreq+0x194>
      {
        usart_frequency = LSE_VALUE;
 8108ab4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8108ab8:	617b      	str	r3, [r7, #20]
      }
      break;
 8108aba:	e009      	b.n	8108ad0 <LL_RCC_GetUSARTClockFreq+0x194>

    default:
      /* Kernel clock disabled */
      break;
 8108abc:	bf00      	nop
 8108abe:	e008      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>
      break;
 8108ac0:	bf00      	nop
 8108ac2:	e006      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>
      break;
 8108ac4:	bf00      	nop
 8108ac6:	e004      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>
      break;
 8108ac8:	bf00      	nop
 8108aca:	e002      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>
      break;
 8108acc:	bf00      	nop
 8108ace:	e000      	b.n	8108ad2 <LL_RCC_GetUSARTClockFreq+0x196>
      break;
 8108ad0:	bf00      	nop
  }

  return usart_frequency;
 8108ad2:	697b      	ldr	r3, [r7, #20]
}
 8108ad4:	4618      	mov	r0, r3
 8108ad6:	371c      	adds	r7, #28
 8108ad8:	46bd      	mov	sp, r7
 8108ada:	bd90      	pop	{r4, r7, pc}
 8108adc:	07050308 	.word	0x07050308
 8108ae0:	07050008 	.word	0x07050008
 8108ae4:	07040308 	.word	0x07040308
 8108ae8:	07040008 	.word	0x07040008
 8108aec:	07030308 	.word	0x07030308
 8108af0:	07030008 	.word	0x07030008
 8108af4:	07020308 	.word	0x07020308
 8108af8:	07020008 	.word	0x07020008
 8108afc:	07010308 	.word	0x07010308
 8108b00:	07010008 	.word	0x07010008
 8108b04:	07000008 	.word	0x07000008
 8108b08:	07000308 	.word	0x07000308
 8108b0c:	0810da14 	.word	0x0810da14
 8108b10:	03d09000 	.word	0x03d09000
 8108b14:	003d0900 	.word	0x003d0900

08108b18 <RCC_GetSystemClockFreq>:
/**
  * @brief  Return SYSTEM clock frequency
  * @retval SYSTEM clock frequency (in Hz)
  */
static uint32_t RCC_GetSystemClockFreq(void)
{
 8108b18:	b580      	push	{r7, lr}
 8108b1a:	b084      	sub	sp, #16
 8108b1c:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
 8108b1e:	2300      	movs	r3, #0
 8108b20:	60fb      	str	r3, [r7, #12]
  LL_PLL_ClocksTypeDef PLL_Clocks;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
 8108b22:	f7ff fa59 	bl	8107fd8 <LL_RCC_GetSysClkSource>
 8108b26:	4603      	mov	r3, r0
 8108b28:	2b18      	cmp	r3, #24
 8108b2a:	d84b      	bhi.n	8108bc4 <RCC_GetSystemClockFreq+0xac>
 8108b2c:	a201      	add	r2, pc, #4	@ (adr r2, 8108b34 <RCC_GetSystemClockFreq+0x1c>)
 8108b2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8108b32:	bf00      	nop
 8108b34:	08108b99 	.word	0x08108b99
 8108b38:	08108bc5 	.word	0x08108bc5
 8108b3c:	08108bc5 	.word	0x08108bc5
 8108b40:	08108bc5 	.word	0x08108bc5
 8108b44:	08108bc5 	.word	0x08108bc5
 8108b48:	08108bc5 	.word	0x08108bc5
 8108b4c:	08108bc5 	.word	0x08108bc5
 8108b50:	08108bc5 	.word	0x08108bc5
 8108b54:	08108bab 	.word	0x08108bab
 8108b58:	08108bc5 	.word	0x08108bc5
 8108b5c:	08108bc5 	.word	0x08108bc5
 8108b60:	08108bc5 	.word	0x08108bc5
 8108b64:	08108bc5 	.word	0x08108bc5
 8108b68:	08108bc5 	.word	0x08108bc5
 8108b6c:	08108bc5 	.word	0x08108bc5
 8108b70:	08108bc5 	.word	0x08108bc5
 8108b74:	08108bb1 	.word	0x08108bb1
 8108b78:	08108bc5 	.word	0x08108bc5
 8108b7c:	08108bc5 	.word	0x08108bc5
 8108b80:	08108bc5 	.word	0x08108bc5
 8108b84:	08108bc5 	.word	0x08108bc5
 8108b88:	08108bc5 	.word	0x08108bc5
 8108b8c:	08108bc5 	.word	0x08108bc5
 8108b90:	08108bc5 	.word	0x08108bc5
 8108b94:	08108bb7 	.word	0x08108bb7
  {
    /* No check on Ready: Won't be selected by hardware if not */
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8108b98:	f7ff f9ea 	bl	8107f70 <LL_RCC_HSI_GetDivider>
 8108b9c:	4603      	mov	r3, r0
 8108b9e:	08db      	lsrs	r3, r3, #3
 8108ba0:	4a0b      	ldr	r2, [pc, #44]	@ (8108bd0 <RCC_GetSystemClockFreq+0xb8>)
 8108ba2:	fa22 f303 	lsr.w	r3, r2, r3
 8108ba6:	60fb      	str	r3, [r7, #12]
      break;
 8108ba8:	e00d      	b.n	8108bc6 <RCC_GetSystemClockFreq+0xae>

    case LL_RCC_SYS_CLKSOURCE_STATUS_CSI:
      frequency = CSI_VALUE;
 8108baa:	4b0a      	ldr	r3, [pc, #40]	@ (8108bd4 <RCC_GetSystemClockFreq+0xbc>)
 8108bac:	60fb      	str	r3, [r7, #12]
      break;
 8108bae:	e00a      	b.n	8108bc6 <RCC_GetSystemClockFreq+0xae>

    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:
      frequency = HSE_VALUE;
 8108bb0:	4b09      	ldr	r3, [pc, #36]	@ (8108bd8 <RCC_GetSystemClockFreq+0xc0>)
 8108bb2:	60fb      	str	r3, [r7, #12]
      break;
 8108bb4:	e007      	b.n	8108bc6 <RCC_GetSystemClockFreq+0xae>

    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL1:
      LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);
 8108bb6:	463b      	mov	r3, r7
 8108bb8:	4618      	mov	r0, r3
 8108bba:	f7ff fcb5 	bl	8108528 <LL_RCC_GetPLL1ClockFreq>
      frequency = PLL_Clocks.PLL_P_Frequency;
 8108bbe:	683b      	ldr	r3, [r7, #0]
 8108bc0:	60fb      	str	r3, [r7, #12]
      break;
 8108bc2:	e000      	b.n	8108bc6 <RCC_GetSystemClockFreq+0xae>

    default:
      /* Nothing to do */
      break;
 8108bc4:	bf00      	nop
  }

  return frequency;
 8108bc6:	68fb      	ldr	r3, [r7, #12]
}
 8108bc8:	4618      	mov	r0, r3
 8108bca:	3710      	adds	r7, #16
 8108bcc:	46bd      	mov	sp, r7
 8108bce:	bd80      	pop	{r7, pc}
 8108bd0:	03d09000 	.word	0x03d09000
 8108bd4:	003d0900 	.word	0x003d0900
 8108bd8:	017d7840 	.word	0x017d7840

08108bdc <RCC_GetHCLKClockFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
 8108bdc:	b580      	push	{r7, lr}
 8108bde:	b082      	sub	sp, #8
 8108be0:	af00      	add	r7, sp, #0
 8108be2:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 8108be4:	f7ff fa14 	bl	8108010 <LL_RCC_GetAHBPrescaler>
 8108be8:	4603      	mov	r3, r0
 8108bea:	f003 030f 	and.w	r3, r3, #15
 8108bee:	4a05      	ldr	r2, [pc, #20]	@ (8108c04 <RCC_GetHCLKClockFreq+0x28>)
 8108bf0:	5cd3      	ldrb	r3, [r2, r3]
 8108bf2:	f003 031f 	and.w	r3, r3, #31
 8108bf6:	687a      	ldr	r2, [r7, #4]
 8108bf8:	fa22 f303 	lsr.w	r3, r2, r3
}
 8108bfc:	4618      	mov	r0, r3
 8108bfe:	3708      	adds	r7, #8
 8108c00:	46bd      	mov	sp, r7
 8108c02:	bd80      	pop	{r7, pc}
 8108c04:	0810da14 	.word	0x0810da14

08108c08 <RCC_GetPCLK1ClockFreq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
 8108c08:	b580      	push	{r7, lr}
 8108c0a:	b082      	sub	sp, #8
 8108c0c:	af00      	add	r7, sp, #0
 8108c0e:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8108c10:	f7ff fa0c 	bl	810802c <LL_RCC_GetAPB1Prescaler>
 8108c14:	4603      	mov	r3, r0
 8108c16:	091b      	lsrs	r3, r3, #4
 8108c18:	f003 0307 	and.w	r3, r3, #7
 8108c1c:	4a05      	ldr	r2, [pc, #20]	@ (8108c34 <RCC_GetPCLK1ClockFreq+0x2c>)
 8108c1e:	5cd3      	ldrb	r3, [r2, r3]
 8108c20:	f003 031f 	and.w	r3, r3, #31
 8108c24:	687a      	ldr	r2, [r7, #4]
 8108c26:	fa22 f303 	lsr.w	r3, r2, r3
}
 8108c2a:	4618      	mov	r0, r3
 8108c2c:	3708      	adds	r7, #8
 8108c2e:	46bd      	mov	sp, r7
 8108c30:	bd80      	pop	{r7, pc}
 8108c32:	bf00      	nop
 8108c34:	0810da14 	.word	0x0810da14

08108c38 <RCC_GetPCLK2ClockFreq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
 8108c38:	b580      	push	{r7, lr}
 8108c3a:	b082      	sub	sp, #8
 8108c3c:	af00      	add	r7, sp, #0
 8108c3e:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 8108c40:	f7ff fa02 	bl	8108048 <LL_RCC_GetAPB2Prescaler>
 8108c44:	4603      	mov	r3, r0
 8108c46:	0a1b      	lsrs	r3, r3, #8
 8108c48:	f003 0307 	and.w	r3, r3, #7
 8108c4c:	4a05      	ldr	r2, [pc, #20]	@ (8108c64 <RCC_GetPCLK2ClockFreq+0x2c>)
 8108c4e:	5cd3      	ldrb	r3, [r2, r3]
 8108c50:	f003 031f 	and.w	r3, r3, #31
 8108c54:	687a      	ldr	r2, [r7, #4]
 8108c56:	fa22 f303 	lsr.w	r3, r2, r3
}
 8108c5a:	4618      	mov	r0, r3
 8108c5c:	3708      	adds	r7, #8
 8108c5e:	46bd      	mov	sp, r7
 8108c60:	bd80      	pop	{r7, pc}
 8108c62:	bf00      	nop
 8108c64:	0810da14 	.word	0x0810da14

08108c68 <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 8108c68:	b084      	sub	sp, #16
 8108c6a:	b480      	push	{r7}
 8108c6c:	b085      	sub	sp, #20
 8108c6e:	af00      	add	r7, sp, #0
 8108c70:	6078      	str	r0, [r7, #4]
 8108c72:	f107 001c 	add.w	r0, r7, #28
 8108c76:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
 8108c7a:	2300      	movs	r3, #0
 8108c7c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
 8108c7e:	69fa      	ldr	r2, [r7, #28]
             Init.ClockPowerSave      | \
 8108c80:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           | \
 8108c82:	431a      	orrs	r2, r3
             Init.BusWide             | \
 8108c84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
             Init.ClockPowerSave      | \
 8108c86:	431a      	orrs	r2, r3
             Init.HardwareFlowControl | \
 8108c88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
             Init.BusWide             | \
 8108c8a:	431a      	orrs	r2, r3
             Init.ClockDiv
 8108c8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
             Init.HardwareFlowControl | \
 8108c8e:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           | \
 8108c90:	68fa      	ldr	r2, [r7, #12]
 8108c92:	4313      	orrs	r3, r2
 8108c94:	60fb      	str	r3, [r7, #12]
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 8108c96:	687b      	ldr	r3, [r7, #4]
 8108c98:	685a      	ldr	r2, [r3, #4]
 8108c9a:	4b07      	ldr	r3, [pc, #28]	@ (8108cb8 <SDMMC_Init+0x50>)
 8108c9c:	4013      	ands	r3, r2
 8108c9e:	68fa      	ldr	r2, [r7, #12]
 8108ca0:	431a      	orrs	r2, r3
 8108ca2:	687b      	ldr	r3, [r7, #4]
 8108ca4:	605a      	str	r2, [r3, #4]

  return HAL_OK;
 8108ca6:	2300      	movs	r3, #0
}
 8108ca8:	4618      	mov	r0, r3
 8108caa:	3714      	adds	r7, #20
 8108cac:	46bd      	mov	sp, r7
 8108cae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108cb2:	b004      	add	sp, #16
 8108cb4:	4770      	bx	lr
 8108cb6:	bf00      	nop
 8108cb8:	ffc02c00 	.word	0xffc02c00

08108cbc <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling)
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(const SDMMC_TypeDef *SDMMCx)
{
 8108cbc:	b480      	push	{r7}
 8108cbe:	b083      	sub	sp, #12
 8108cc0:	af00      	add	r7, sp, #0
 8108cc2:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
 8108cc4:	687b      	ldr	r3, [r7, #4]
 8108cc6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
 8108cca:	4618      	mov	r0, r3
 8108ccc:	370c      	adds	r7, #12
 8108cce:	46bd      	mov	sp, r7
 8108cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108cd4:	4770      	bx	lr

08108cd6 <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
 8108cd6:	b480      	push	{r7}
 8108cd8:	b083      	sub	sp, #12
 8108cda:	af00      	add	r7, sp, #0
 8108cdc:	6078      	str	r0, [r7, #4]
 8108cde:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
 8108ce0:	683b      	ldr	r3, [r7, #0]
 8108ce2:	681a      	ldr	r2, [r3, #0]
 8108ce4:	687b      	ldr	r3, [r7, #4]
 8108ce6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return HAL_OK;
 8108cea:	2300      	movs	r3, #0
}
 8108cec:	4618      	mov	r0, r3
 8108cee:	370c      	adds	r7, #12
 8108cf0:	46bd      	mov	sp, r7
 8108cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108cf6:	4770      	bx	lr

08108cf8 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
 8108cf8:	b480      	push	{r7}
 8108cfa:	b083      	sub	sp, #12
 8108cfc:	af00      	add	r7, sp, #0
 8108cfe:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 8108d00:	687b      	ldr	r3, [r7, #4]
 8108d02:	681b      	ldr	r3, [r3, #0]
 8108d04:	f043 0203 	orr.w	r2, r3, #3
 8108d08:	687b      	ldr	r3, [r7, #4]
 8108d0a:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8108d0c:	2300      	movs	r3, #0
}
 8108d0e:	4618      	mov	r0, r3
 8108d10:	370c      	adds	r7, #12
 8108d12:	46bd      	mov	sp, r7
 8108d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108d18:	4770      	bx	lr

08108d1a <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(const SDMMC_TypeDef *SDMMCx)
{
 8108d1a:	b480      	push	{r7}
 8108d1c:	b083      	sub	sp, #12
 8108d1e:	af00      	add	r7, sp, #0
 8108d20:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 8108d22:	687b      	ldr	r3, [r7, #4]
 8108d24:	681b      	ldr	r3, [r3, #0]
 8108d26:	f003 0303 	and.w	r3, r3, #3
}
 8108d2a:	4618      	mov	r0, r3
 8108d2c:	370c      	adds	r7, #12
 8108d2e:	46bd      	mov	sp, r7
 8108d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108d34:	4770      	bx	lr
	...

08108d38 <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, const SDMMC_CmdInitTypeDef *Command)
{
 8108d38:	b480      	push	{r7}
 8108d3a:	b085      	sub	sp, #20
 8108d3c:	af00      	add	r7, sp, #0
 8108d3e:	6078      	str	r0, [r7, #4]
 8108d40:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8108d42:	2300      	movs	r3, #0
 8108d44:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 8108d46:	683b      	ldr	r3, [r7, #0]
 8108d48:	681a      	ldr	r2, [r3, #0]
 8108d4a:	687b      	ldr	r3, [r7, #4]
 8108d4c:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 8108d4e:	683b      	ldr	r3, [r7, #0]
 8108d50:	685a      	ldr	r2, [r3, #4]
                       Command->Response         | \
 8108d52:	683b      	ldr	r3, [r7, #0]
 8108d54:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 8108d56:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt | \
 8108d58:	683b      	ldr	r3, [r7, #0]
 8108d5a:	68db      	ldr	r3, [r3, #12]
                       Command->Response         | \
 8108d5c:	431a      	orrs	r2, r3
                       Command->CPSM);
 8108d5e:	683b      	ldr	r3, [r7, #0]
 8108d60:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt | \
 8108d62:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 8108d64:	68fa      	ldr	r2, [r7, #12]
 8108d66:	4313      	orrs	r3, r2
 8108d68:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8108d6a:	687b      	ldr	r3, [r7, #4]
 8108d6c:	68da      	ldr	r2, [r3, #12]
 8108d6e:	4b06      	ldr	r3, [pc, #24]	@ (8108d88 <SDMMC_SendCommand+0x50>)
 8108d70:	4013      	ands	r3, r2
 8108d72:	68fa      	ldr	r2, [r7, #12]
 8108d74:	431a      	orrs	r2, r3
 8108d76:	687b      	ldr	r3, [r7, #4]
 8108d78:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 8108d7a:	2300      	movs	r3, #0
}
 8108d7c:	4618      	mov	r0, r3
 8108d7e:	3714      	adds	r7, #20
 8108d80:	46bd      	mov	sp, r7
 8108d82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108d86:	4770      	bx	lr
 8108d88:	fffee0c0 	.word	0xfffee0c0

08108d8c <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(const SDMMC_TypeDef *SDMMCx)
{
 8108d8c:	b480      	push	{r7}
 8108d8e:	b083      	sub	sp, #12
 8108d90:	af00      	add	r7, sp, #0
 8108d92:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
 8108d94:	687b      	ldr	r3, [r7, #4]
 8108d96:	691b      	ldr	r3, [r3, #16]
 8108d98:	b2db      	uxtb	r3, r3
}
 8108d9a:	4618      	mov	r0, r3
 8108d9c:	370c      	adds	r7, #12
 8108d9e:	46bd      	mov	sp, r7
 8108da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108da4:	4770      	bx	lr

08108da6 <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(const SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
 8108da6:	b480      	push	{r7}
 8108da8:	b085      	sub	sp, #20
 8108daa:	af00      	add	r7, sp, #0
 8108dac:	6078      	str	r0, [r7, #4]
 8108dae:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 8108db0:	687b      	ldr	r3, [r7, #4]
 8108db2:	3314      	adds	r3, #20
 8108db4:	461a      	mov	r2, r3
 8108db6:	683b      	ldr	r3, [r7, #0]
 8108db8:	4413      	add	r3, r2
 8108dba:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint32_t *) tmp);
 8108dbc:	68fb      	ldr	r3, [r7, #12]
 8108dbe:	681b      	ldr	r3, [r3, #0]
}
 8108dc0:	4618      	mov	r0, r3
 8108dc2:	3714      	adds	r7, #20
 8108dc4:	46bd      	mov	sp, r7
 8108dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108dca:	4770      	bx	lr

08108dcc <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, const SDMMC_DataInitTypeDef *Data)
{
 8108dcc:	b480      	push	{r7}
 8108dce:	b085      	sub	sp, #20
 8108dd0:	af00      	add	r7, sp, #0
 8108dd2:	6078      	str	r0, [r7, #4]
 8108dd4:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8108dd6:	2300      	movs	r3, #0
 8108dd8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
 8108dda:	683b      	ldr	r3, [r7, #0]
 8108ddc:	681a      	ldr	r2, [r3, #0]
 8108dde:	687b      	ldr	r3, [r7, #4]
 8108de0:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 8108de2:	683b      	ldr	r3, [r7, #0]
 8108de4:	685a      	ldr	r2, [r3, #4]
 8108de6:	687b      	ldr	r3, [r7, #4]
 8108de8:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 8108dea:	683b      	ldr	r3, [r7, #0]
 8108dec:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   | \
 8108dee:	683b      	ldr	r3, [r7, #0]
 8108df0:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 8108df2:	431a      	orrs	r2, r3
                       Data->TransferMode  | \
 8108df4:	683b      	ldr	r3, [r7, #0]
 8108df6:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   | \
 8108df8:	431a      	orrs	r2, r3
                       Data->DPSM);
 8108dfa:	683b      	ldr	r3, [r7, #0]
 8108dfc:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  | \
 8108dfe:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 8108e00:	68fa      	ldr	r2, [r7, #12]
 8108e02:	4313      	orrs	r3, r2
 8108e04:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8108e06:	687b      	ldr	r3, [r7, #4]
 8108e08:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8108e0a:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 8108e0e:	68fb      	ldr	r3, [r7, #12]
 8108e10:	431a      	orrs	r2, r3
 8108e12:	687b      	ldr	r3, [r7, #4]
 8108e14:	62da      	str	r2, [r3, #44]	@ 0x2c

  return HAL_OK;
 8108e16:	2300      	movs	r3, #0

}
 8108e18:	4618      	mov	r0, r3
 8108e1a:	3714      	adds	r7, #20
 8108e1c:	46bd      	mov	sp, r7
 8108e1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108e22:	4770      	bx	lr

08108e24 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 8108e24:	b580      	push	{r7, lr}
 8108e26:	b088      	sub	sp, #32
 8108e28:	af00      	add	r7, sp, #0
 8108e2a:	6078      	str	r0, [r7, #4]
 8108e2c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 8108e2e:	683b      	ldr	r3, [r7, #0]
 8108e30:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 8108e32:	2310      	movs	r3, #16
 8108e34:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8108e36:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8108e3a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108e3c:	2300      	movs	r3, #0
 8108e3e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108e40:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108e44:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108e46:	f107 0308 	add.w	r3, r7, #8
 8108e4a:	4619      	mov	r1, r3
 8108e4c:	6878      	ldr	r0, [r7, #4]
 8108e4e:	f7ff ff73 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 8108e52:	f241 3288 	movw	r2, #5000	@ 0x1388
 8108e56:	2110      	movs	r1, #16
 8108e58:	6878      	ldr	r0, [r7, #4]
 8108e5a:	f000 f971 	bl	8109140 <SDMMC_GetCmdResp1>
 8108e5e:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8108e60:	69fb      	ldr	r3, [r7, #28]
}
 8108e62:	4618      	mov	r0, r3
 8108e64:	3720      	adds	r7, #32
 8108e66:	46bd      	mov	sp, r7
 8108e68:	bd80      	pop	{r7, pc}
	...

08108e6c <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 8108e6c:	b580      	push	{r7, lr}
 8108e6e:	b088      	sub	sp, #32
 8108e70:	af00      	add	r7, sp, #0
 8108e72:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
 8108e74:	2300      	movs	r3, #0
 8108e76:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8108e78:	230c      	movs	r3, #12
 8108e7a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8108e7c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8108e80:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108e82:	2300      	movs	r3, #0
 8108e84:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108e86:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108e8a:	61bb      	str	r3, [r7, #24]

  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 8108e8c:	687b      	ldr	r3, [r7, #4]
 8108e8e:	68db      	ldr	r3, [r3, #12]
 8108e90:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8108e94:	687b      	ldr	r3, [r7, #4]
 8108e96:	60da      	str	r2, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 8108e98:	687b      	ldr	r3, [r7, #4]
 8108e9a:	68db      	ldr	r3, [r3, #12]
 8108e9c:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
 8108ea0:	687b      	ldr	r3, [r7, #4]
 8108ea2:	60da      	str	r2, [r3, #12]

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108ea4:	f107 0308 	add.w	r3, r7, #8
 8108ea8:	4619      	mov	r1, r3
 8108eaa:	6878      	ldr	r0, [r7, #4]
 8108eac:	f7ff ff44 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
 8108eb0:	4a0b      	ldr	r2, [pc, #44]	@ (8108ee0 <SDMMC_CmdStopTransfer+0x74>)
 8108eb2:	210c      	movs	r1, #12
 8108eb4:	6878      	ldr	r0, [r7, #4]
 8108eb6:	f000 f943 	bl	8109140 <SDMMC_GetCmdResp1>
 8108eba:	61f8      	str	r0, [r7, #28]

  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 8108ebc:	687b      	ldr	r3, [r7, #4]
 8108ebe:	68db      	ldr	r3, [r3, #12]
 8108ec0:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8108ec4:	687b      	ldr	r3, [r7, #4]
 8108ec6:	60da      	str	r2, [r3, #12]

  /* Ignore Address Out Of Range Error, Not relevant at end of memory */
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
 8108ec8:	69fb      	ldr	r3, [r7, #28]
 8108eca:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8108ece:	d101      	bne.n	8108ed4 <SDMMC_CmdStopTransfer+0x68>
  {
    errorstate = SDMMC_ERROR_NONE;
 8108ed0:	2300      	movs	r3, #0
 8108ed2:	61fb      	str	r3, [r7, #28]
  }

  return errorstate;
 8108ed4:	69fb      	ldr	r3, [r7, #28]
}
 8108ed6:	4618      	mov	r0, r3
 8108ed8:	3720      	adds	r7, #32
 8108eda:	46bd      	mov	sp, r7
 8108edc:	bd80      	pop	{r7, pc}
 8108ede:	bf00      	nop
 8108ee0:	05f5e100 	.word	0x05f5e100

08108ee4 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  addr: Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint32_t Addr)
{
 8108ee4:	b580      	push	{r7, lr}
 8108ee6:	b088      	sub	sp, #32
 8108ee8:	af00      	add	r7, sp, #0
 8108eea:	6078      	str	r0, [r7, #4]
 8108eec:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 8108eee:	683b      	ldr	r3, [r7, #0]
 8108ef0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 8108ef2:	2307      	movs	r3, #7
 8108ef4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8108ef6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8108efa:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108efc:	2300      	movs	r3, #0
 8108efe:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108f00:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108f04:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108f06:	f107 0308 	add.w	r3, r7, #8
 8108f0a:	4619      	mov	r1, r3
 8108f0c:	6878      	ldr	r0, [r7, #4]
 8108f0e:	f7ff ff13 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 8108f12:	f241 3288 	movw	r2, #5000	@ 0x1388
 8108f16:	2107      	movs	r1, #7
 8108f18:	6878      	ldr	r0, [r7, #4]
 8108f1a:	f000 f911 	bl	8109140 <SDMMC_GetCmdResp1>
 8108f1e:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8108f20:	69fb      	ldr	r3, [r7, #28]
}
 8108f22:	4618      	mov	r0, r3
 8108f24:	3720      	adds	r7, #32
 8108f26:	46bd      	mov	sp, r7
 8108f28:	bd80      	pop	{r7, pc}

08108f2a <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 8108f2a:	b580      	push	{r7, lr}
 8108f2c:	b088      	sub	sp, #32
 8108f2e:	af00      	add	r7, sp, #0
 8108f30:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 8108f32:	2300      	movs	r3, #0
 8108f34:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 8108f36:	2300      	movs	r3, #0
 8108f38:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
 8108f3a:	2300      	movs	r3, #0
 8108f3c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108f3e:	2300      	movs	r3, #0
 8108f40:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108f42:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108f46:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108f48:	f107 0308 	add.w	r3, r7, #8
 8108f4c:	4619      	mov	r1, r3
 8108f4e:	6878      	ldr	r0, [r7, #4]
 8108f50:	f7ff fef2 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
 8108f54:	6878      	ldr	r0, [r7, #4]
 8108f56:	f000 fa6f 	bl	8109438 <SDMMC_GetCmdError>
 8108f5a:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8108f5c:	69fb      	ldr	r3, [r7, #28]
}
 8108f5e:	4618      	mov	r0, r3
 8108f60:	3720      	adds	r7, #32
 8108f62:	46bd      	mov	sp, r7
 8108f64:	bd80      	pop	{r7, pc}

08108f66 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 8108f66:	b580      	push	{r7, lr}
 8108f68:	b088      	sub	sp, #32
 8108f6a:	af00      	add	r7, sp, #0
 8108f6c:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 8108f6e:	2300      	movs	r3, #0
 8108f70:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 8108f72:	2302      	movs	r3, #2
 8108f74:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 8108f76:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8108f7a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108f7c:	2300      	movs	r3, #0
 8108f7e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108f80:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108f84:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108f86:	f107 0308 	add.w	r3, r7, #8
 8108f8a:	4619      	mov	r1, r3
 8108f8c:	6878      	ldr	r0, [r7, #4]
 8108f8e:	f7ff fed3 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 8108f92:	6878      	ldr	r0, [r7, #4]
 8108f94:	f000 f9c6 	bl	8109324 <SDMMC_GetCmdResp2>
 8108f98:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8108f9a:	69fb      	ldr	r3, [r7, #28]
}
 8108f9c:	4618      	mov	r0, r3
 8108f9e:	3720      	adds	r7, #32
 8108fa0:	46bd      	mov	sp, r7
 8108fa2:	bd80      	pop	{r7, pc}

08108fa4 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8108fa4:	b580      	push	{r7, lr}
 8108fa6:	b088      	sub	sp, #32
 8108fa8:	af00      	add	r7, sp, #0
 8108faa:	6078      	str	r0, [r7, #4]
 8108fac:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 8108fae:	683b      	ldr	r3, [r7, #0]
 8108fb0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 8108fb2:	2309      	movs	r3, #9
 8108fb4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 8108fb6:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8108fba:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8108fbc:	2300      	movs	r3, #0
 8108fbe:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8108fc0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8108fc4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8108fc6:	f107 0308 	add.w	r3, r7, #8
 8108fca:	4619      	mov	r1, r3
 8108fcc:	6878      	ldr	r0, [r7, #4]
 8108fce:	f7ff feb3 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 8108fd2:	6878      	ldr	r0, [r7, #4]
 8108fd4:	f000 f9a6 	bl	8109324 <SDMMC_GetCmdResp2>
 8108fd8:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8108fda:	69fb      	ldr	r3, [r7, #28]
}
 8108fdc:	4618      	mov	r0, r3
 8108fde:	3720      	adds	r7, #32
 8108fe0:	46bd      	mov	sp, r7
 8108fe2:	bd80      	pop	{r7, pc}

08108fe4 <SDMMC_CmdSetRelAddMmc>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
 8108fe4:	b580      	push	{r7, lr}
 8108fe6:	b088      	sub	sp, #32
 8108fe8:	af00      	add	r7, sp, #0
 8108fea:	6078      	str	r0, [r7, #4]
 8108fec:	460b      	mov	r3, r1
 8108fee:	807b      	strh	r3, [r7, #2]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
 8108ff0:	887b      	ldrh	r3, [r7, #2]
 8108ff2:	041b      	lsls	r3, r3, #16
 8108ff4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 8108ff6:	2303      	movs	r3, #3
 8108ff8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8108ffa:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8108ffe:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8109000:	2300      	movs	r3, #0
 8109002:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8109004:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8109008:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 810900a:	f107 0308 	add.w	r3, r7, #8
 810900e:	4619      	mov	r1, r3
 8109010:	6878      	ldr	r0, [r7, #4]
 8109012:	f7ff fe91 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_REL_ADDR, SDMMC_CMDTIMEOUT);
 8109016:	f241 3288 	movw	r2, #5000	@ 0x1388
 810901a:	2103      	movs	r1, #3
 810901c:	6878      	ldr	r0, [r7, #4]
 810901e:	f000 f88f 	bl	8109140 <SDMMC_GetCmdResp1>
 8109022:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8109024:	69fb      	ldr	r3, [r7, #28]
}
 8109026:	4618      	mov	r0, r3
 8109028:	3720      	adds	r7, #32
 810902a:	46bd      	mov	sp, r7
 810902c:	bd80      	pop	{r7, pc}

0810902e <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 810902e:	b580      	push	{r7, lr}
 8109030:	b088      	sub	sp, #32
 8109032:	af00      	add	r7, sp, #0
 8109034:	6078      	str	r0, [r7, #4]
 8109036:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 8109038:	683b      	ldr	r3, [r7, #0]
 810903a:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 810903c:	230d      	movs	r3, #13
 810903e:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8109040:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8109044:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8109046:	2300      	movs	r3, #0
 8109048:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 810904a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 810904e:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8109050:	f107 0308 	add.w	r3, r7, #8
 8109054:	4619      	mov	r1, r3
 8109056:	6878      	ldr	r0, [r7, #4]
 8109058:	f7ff fe6e 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
 810905c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8109060:	210d      	movs	r1, #13
 8109062:	6878      	ldr	r0, [r7, #4]
 8109064:	f000 f86c 	bl	8109140 <SDMMC_GetCmdResp1>
 8109068:	61f8      	str	r0, [r7, #28]

  return errorstate;
 810906a:	69fb      	ldr	r3, [r7, #28]
}
 810906c:	4618      	mov	r0, r3
 810906e:	3720      	adds	r7, #32
 8109070:	46bd      	mov	sp, r7
 8109072:	bd80      	pop	{r7, pc}

08109074 <SDMMC_CmdOpCondition>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8109074:	b580      	push	{r7, lr}
 8109076:	b088      	sub	sp, #32
 8109078:	af00      	add	r7, sp, #0
 810907a:	6078      	str	r0, [r7, #4]
 810907c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 810907e:	683b      	ldr	r3, [r7, #0]
 8109080:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
 8109082:	2301      	movs	r3, #1
 8109084:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8109086:	f44f 7380 	mov.w	r3, #256	@ 0x100
 810908a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 810908c:	2300      	movs	r3, #0
 810908e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8109090:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8109094:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8109096:	f107 0308 	add.w	r3, r7, #8
 810909a:	4619      	mov	r1, r3
 810909c:	6878      	ldr	r0, [r7, #4]
 810909e:	f7ff fe4b 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 81090a2:	6878      	ldr	r0, [r7, #4]
 81090a4:	f000 f988 	bl	81093b8 <SDMMC_GetCmdResp3>
 81090a8:	61f8      	str	r0, [r7, #28]

  return errorstate;
 81090aa:	69fb      	ldr	r3, [r7, #28]
}
 81090ac:	4618      	mov	r0, r3
 81090ae:	3720      	adds	r7, #32
 81090b0:	46bd      	mov	sp, r7
 81090b2:	bd80      	pop	{r7, pc}

081090b4 <SDMMC_CmdSwitch>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 81090b4:	b580      	push	{r7, lr}
 81090b6:	b088      	sub	sp, #32
 81090b8:	af00      	add	r7, sp, #0
 81090ba:	6078      	str	r0, [r7, #4]
 81090bc:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN*/
 81090be:	683b      	ldr	r3, [r7, #0]
 81090c0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 81090c2:	2306      	movs	r3, #6
 81090c4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 81090c6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 81090ca:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 81090cc:	2300      	movs	r3, #0
 81090ce:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 81090d0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 81090d4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 81090d6:	f107 0308 	add.w	r3, r7, #8
 81090da:	4619      	mov	r1, r3
 81090dc:	6878      	ldr	r0, [r7, #4]
 81090de:	f7ff fe2b 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SWITCH, SDMMC_CMDTIMEOUT);
 81090e2:	f241 3288 	movw	r2, #5000	@ 0x1388
 81090e6:	2106      	movs	r1, #6
 81090e8:	6878      	ldr	r0, [r7, #4]
 81090ea:	f000 f829 	bl	8109140 <SDMMC_GetCmdResp1>
 81090ee:	61f8      	str	r0, [r7, #28]

  return errorstate;
 81090f0:	69fb      	ldr	r3, [r7, #28]
}
 81090f2:	4618      	mov	r0, r3
 81090f4:	3720      	adds	r7, #32
 81090f6:	46bd      	mov	sp, r7
 81090f8:	bd80      	pop	{r7, pc}

081090fa <SDMMC_CmdSendEXTCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 81090fa:	b580      	push	{r7, lr}
 81090fc:	b088      	sub	sp, #32
 81090fe:	af00      	add	r7, sp, #0
 8109100:	6078      	str	r0, [r7, #4]
 8109102:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 8109104:	683b      	ldr	r3, [r7, #0]
 8109106:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 8109108:	2308      	movs	r3, #8
 810910a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 810910c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8109110:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8109112:	2300      	movs	r3, #0
 8109114:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8109116:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 810911a:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 810911c:	f107 0308 	add.w	r3, r7, #8
 8109120:	4619      	mov	r1, r3
 8109122:	6878      	ldr	r0, [r7, #4]
 8109124:	f7ff fe08 	bl	8108d38 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SEND_EXT_CSD, SDMMC_CMDTIMEOUT);
 8109128:	f241 3288 	movw	r2, #5000	@ 0x1388
 810912c:	2108      	movs	r1, #8
 810912e:	6878      	ldr	r0, [r7, #4]
 8109130:	f000 f806 	bl	8109140 <SDMMC_GetCmdResp1>
 8109134:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8109136:	69fb      	ldr	r3, [r7, #28]
}
 8109138:	4618      	mov	r0, r3
 810913a:	3720      	adds	r7, #32
 810913c:	46bd      	mov	sp, r7
 810913e:	bd80      	pop	{r7, pc}

08109140 <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
 8109140:	b580      	push	{r7, lr}
 8109142:	b088      	sub	sp, #32
 8109144:	af00      	add	r7, sp, #0
 8109146:	60f8      	str	r0, [r7, #12]
 8109148:	460b      	mov	r3, r1
 810914a:	607a      	str	r2, [r7, #4]
 810914c:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
 810914e:	4b70      	ldr	r3, [pc, #448]	@ (8109310 <SDMMC_GetCmdResp1+0x1d0>)
 8109150:	681b      	ldr	r3, [r3, #0]
 8109152:	4a70      	ldr	r2, [pc, #448]	@ (8109314 <SDMMC_GetCmdResp1+0x1d4>)
 8109154:	fba2 2303 	umull	r2, r3, r2, r3
 8109158:	0a5a      	lsrs	r2, r3, #9
 810915a:	687b      	ldr	r3, [r7, #4]
 810915c:	fb02 f303 	mul.w	r3, r2, r3
 8109160:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
 8109162:	69fb      	ldr	r3, [r7, #28]
 8109164:	1e5a      	subs	r2, r3, #1
 8109166:	61fa      	str	r2, [r7, #28]
 8109168:	2b00      	cmp	r3, #0
 810916a:	d102      	bne.n	8109172 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
 810916c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8109170:	e0c9      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
 8109172:	68fb      	ldr	r3, [r7, #12]
 8109174:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109176:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
 8109178:	69ba      	ldr	r2, [r7, #24]
 810917a:	4b67      	ldr	r3, [pc, #412]	@ (8109318 <SDMMC_GetCmdResp1+0x1d8>)
 810917c:	4013      	ands	r3, r2
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 810917e:	2b00      	cmp	r3, #0
 8109180:	d0ef      	beq.n	8109162 <SDMMC_GetCmdResp1+0x22>
 8109182:	69bb      	ldr	r3, [r7, #24]
 8109184:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8109188:	2b00      	cmp	r3, #0
 810918a:	d1ea      	bne.n	8109162 <SDMMC_GetCmdResp1+0x22>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 810918c:	68fb      	ldr	r3, [r7, #12]
 810918e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109190:	f003 0304 	and.w	r3, r3, #4
 8109194:	2b00      	cmp	r3, #0
 8109196:	d004      	beq.n	81091a2 <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8109198:	68fb      	ldr	r3, [r7, #12]
 810919a:	2204      	movs	r2, #4
 810919c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 810919e:	2304      	movs	r3, #4
 81091a0:	e0b1      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 81091a2:	68fb      	ldr	r3, [r7, #12]
 81091a4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81091a6:	f003 0301 	and.w	r3, r3, #1
 81091aa:	2b00      	cmp	r3, #0
 81091ac:	d004      	beq.n	81091b8 <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 81091ae:	68fb      	ldr	r3, [r7, #12]
 81091b0:	2201      	movs	r2, #1
 81091b2:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 81091b4:	2301      	movs	r3, #1
 81091b6:	e0a6      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 81091b8:	68fb      	ldr	r3, [r7, #12]
 81091ba:	4a58      	ldr	r2, [pc, #352]	@ (810931c <SDMMC_GetCmdResp1+0x1dc>)
 81091bc:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 81091be:	68f8      	ldr	r0, [r7, #12]
 81091c0:	f7ff fde4 	bl	8108d8c <SDMMC_GetCommandResponse>
 81091c4:	4603      	mov	r3, r0
 81091c6:	461a      	mov	r2, r3
 81091c8:	7afb      	ldrb	r3, [r7, #11]
 81091ca:	4293      	cmp	r3, r2
 81091cc:	d001      	beq.n	81091d2 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 81091ce:	2301      	movs	r3, #1
 81091d0:	e099      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
 81091d2:	2100      	movs	r1, #0
 81091d4:	68f8      	ldr	r0, [r7, #12]
 81091d6:	f7ff fde6 	bl	8108da6 <SDMMC_GetResponse>
 81091da:	6178      	str	r0, [r7, #20]

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 81091dc:	697a      	ldr	r2, [r7, #20]
 81091de:	4b50      	ldr	r3, [pc, #320]	@ (8109320 <SDMMC_GetCmdResp1+0x1e0>)
 81091e0:	4013      	ands	r3, r2
 81091e2:	2b00      	cmp	r3, #0
 81091e4:	d101      	bne.n	81091ea <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
 81091e6:	2300      	movs	r3, #0
 81091e8:	e08d      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 81091ea:	697b      	ldr	r3, [r7, #20]
 81091ec:	2b00      	cmp	r3, #0
 81091ee:	da02      	bge.n	81091f6 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 81091f0:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 81091f4:	e087      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 81091f6:	697b      	ldr	r3, [r7, #20]
 81091f8:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 81091fc:	2b00      	cmp	r3, #0
 81091fe:	d001      	beq.n	8109204 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8109200:	2340      	movs	r3, #64	@ 0x40
 8109202:	e080      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8109204:	697b      	ldr	r3, [r7, #20]
 8109206:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 810920a:	2b00      	cmp	r3, #0
 810920c:	d001      	beq.n	8109212 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 810920e:	2380      	movs	r3, #128	@ 0x80
 8109210:	e079      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8109212:	697b      	ldr	r3, [r7, #20]
 8109214:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8109218:	2b00      	cmp	r3, #0
 810921a:	d002      	beq.n	8109222 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 810921c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8109220:	e071      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8109222:	697b      	ldr	r3, [r7, #20]
 8109224:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8109228:	2b00      	cmp	r3, #0
 810922a:	d002      	beq.n	8109232 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 810922c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8109230:	e069      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8109232:	697b      	ldr	r3, [r7, #20]
 8109234:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8109238:	2b00      	cmp	r3, #0
 810923a:	d002      	beq.n	8109242 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 810923c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8109240:	e061      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8109242:	697b      	ldr	r3, [r7, #20]
 8109244:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8109248:	2b00      	cmp	r3, #0
 810924a:	d002      	beq.n	8109252 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 810924c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8109250:	e059      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8109252:	697b      	ldr	r3, [r7, #20]
 8109254:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8109258:	2b00      	cmp	r3, #0
 810925a:	d002      	beq.n	8109262 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 810925c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8109260:	e051      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8109262:	697b      	ldr	r3, [r7, #20]
 8109264:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8109268:	2b00      	cmp	r3, #0
 810926a:	d002      	beq.n	8109272 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 810926c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8109270:	e049      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8109272:	697b      	ldr	r3, [r7, #20]
 8109274:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8109278:	2b00      	cmp	r3, #0
 810927a:	d002      	beq.n	8109282 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
 810927c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8109280:	e041      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8109282:	697b      	ldr	r3, [r7, #20]
 8109284:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8109288:	2b00      	cmp	r3, #0
 810928a:	d002      	beq.n	8109292 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
 810928c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8109290:	e039      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8109292:	697b      	ldr	r3, [r7, #20]
 8109294:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8109298:	2b00      	cmp	r3, #0
 810929a:	d002      	beq.n	81092a2 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 810929c:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 81092a0:	e031      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 81092a2:	697b      	ldr	r3, [r7, #20]
 81092a4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 81092a8:	2b00      	cmp	r3, #0
 81092aa:	d002      	beq.n	81092b2 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 81092ac:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 81092b0:	e029      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 81092b2:	697b      	ldr	r3, [r7, #20]
 81092b4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 81092b8:	2b00      	cmp	r3, #0
 81092ba:	d002      	beq.n	81092c2 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 81092bc:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 81092c0:	e021      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 81092c2:	697b      	ldr	r3, [r7, #20]
 81092c4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 81092c8:	2b00      	cmp	r3, #0
 81092ca:	d002      	beq.n	81092d2 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
 81092cc:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 81092d0:	e019      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 81092d2:	697b      	ldr	r3, [r7, #20]
 81092d4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 81092d8:	2b00      	cmp	r3, #0
 81092da:	d002      	beq.n	81092e2 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 81092dc:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 81092e0:	e011      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 81092e2:	697b      	ldr	r3, [r7, #20]
 81092e4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 81092e8:	2b00      	cmp	r3, #0
 81092ea:	d002      	beq.n	81092f2 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
 81092ec:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 81092f0:	e009      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 81092f2:	697b      	ldr	r3, [r7, #20]
 81092f4:	f003 0308 	and.w	r3, r3, #8
 81092f8:	2b00      	cmp	r3, #0
 81092fa:	d002      	beq.n	8109302 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 81092fc:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 8109300:	e001      	b.n	8109306 <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8109302:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
 8109306:	4618      	mov	r0, r3
 8109308:	3720      	adds	r7, #32
 810930a:	46bd      	mov	sp, r7
 810930c:	bd80      	pop	{r7, pc}
 810930e:	bf00      	nop
 8109310:	10032028 	.word	0x10032028
 8109314:	10624dd3 	.word	0x10624dd3
 8109318:	00200045 	.word	0x00200045
 810931c:	002000c5 	.word	0x002000c5
 8109320:	fdffe008 	.word	0xfdffe008

08109324 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
 8109324:	b480      	push	{r7}
 8109326:	b085      	sub	sp, #20
 8109328:	af00      	add	r7, sp, #0
 810932a:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 810932c:	4b1f      	ldr	r3, [pc, #124]	@ (81093ac <SDMMC_GetCmdResp2+0x88>)
 810932e:	681b      	ldr	r3, [r3, #0]
 8109330:	4a1f      	ldr	r2, [pc, #124]	@ (81093b0 <SDMMC_GetCmdResp2+0x8c>)
 8109332:	fba2 2303 	umull	r2, r3, r2, r3
 8109336:	0a5b      	lsrs	r3, r3, #9
 8109338:	f241 3288 	movw	r2, #5000	@ 0x1388
 810933c:	fb02 f303 	mul.w	r3, r2, r3
 8109340:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 8109342:	68fb      	ldr	r3, [r7, #12]
 8109344:	1e5a      	subs	r2, r3, #1
 8109346:	60fa      	str	r2, [r7, #12]
 8109348:	2b00      	cmp	r3, #0
 810934a:	d102      	bne.n	8109352 <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 810934c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8109350:	e026      	b.n	81093a0 <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
 8109352:	687b      	ldr	r3, [r7, #4]
 8109354:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109356:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8109358:	68bb      	ldr	r3, [r7, #8]
 810935a:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 810935e:	2b00      	cmp	r3, #0
 8109360:	d0ef      	beq.n	8109342 <SDMMC_GetCmdResp2+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 8109362:	68bb      	ldr	r3, [r7, #8]
 8109364:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8109368:	2b00      	cmp	r3, #0
 810936a:	d1ea      	bne.n	8109342 <SDMMC_GetCmdResp2+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 810936c:	687b      	ldr	r3, [r7, #4]
 810936e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109370:	f003 0304 	and.w	r3, r3, #4
 8109374:	2b00      	cmp	r3, #0
 8109376:	d004      	beq.n	8109382 <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8109378:	687b      	ldr	r3, [r7, #4]
 810937a:	2204      	movs	r2, #4
 810937c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 810937e:	2304      	movs	r3, #4
 8109380:	e00e      	b.n	81093a0 <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8109382:	687b      	ldr	r3, [r7, #4]
 8109384:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109386:	f003 0301 	and.w	r3, r3, #1
 810938a:	2b00      	cmp	r3, #0
 810938c:	d004      	beq.n	8109398 <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 810938e:	687b      	ldr	r3, [r7, #4]
 8109390:	2201      	movs	r2, #1
 8109392:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 8109394:	2301      	movs	r3, #1
 8109396:	e003      	b.n	81093a0 <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8109398:	687b      	ldr	r3, [r7, #4]
 810939a:	4a06      	ldr	r2, [pc, #24]	@ (81093b4 <SDMMC_GetCmdResp2+0x90>)
 810939c:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 810939e:	2300      	movs	r3, #0
}
 81093a0:	4618      	mov	r0, r3
 81093a2:	3714      	adds	r7, #20
 81093a4:	46bd      	mov	sp, r7
 81093a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81093aa:	4770      	bx	lr
 81093ac:	10032028 	.word	0x10032028
 81093b0:	10624dd3 	.word	0x10624dd3
 81093b4:	002000c5 	.word	0x002000c5

081093b8 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
 81093b8:	b480      	push	{r7}
 81093ba:	b085      	sub	sp, #20
 81093bc:	af00      	add	r7, sp, #0
 81093be:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 81093c0:	4b1a      	ldr	r3, [pc, #104]	@ (810942c <SDMMC_GetCmdResp3+0x74>)
 81093c2:	681b      	ldr	r3, [r3, #0]
 81093c4:	4a1a      	ldr	r2, [pc, #104]	@ (8109430 <SDMMC_GetCmdResp3+0x78>)
 81093c6:	fba2 2303 	umull	r2, r3, r2, r3
 81093ca:	0a5b      	lsrs	r3, r3, #9
 81093cc:	f241 3288 	movw	r2, #5000	@ 0x1388
 81093d0:	fb02 f303 	mul.w	r3, r2, r3
 81093d4:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 81093d6:	68fb      	ldr	r3, [r7, #12]
 81093d8:	1e5a      	subs	r2, r3, #1
 81093da:	60fa      	str	r2, [r7, #12]
 81093dc:	2b00      	cmp	r3, #0
 81093de:	d102      	bne.n	81093e6 <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 81093e0:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 81093e4:	e01b      	b.n	810941e <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
 81093e6:	687b      	ldr	r3, [r7, #4]
 81093e8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81093ea:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 81093ec:	68bb      	ldr	r3, [r7, #8]
 81093ee:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 81093f2:	2b00      	cmp	r3, #0
 81093f4:	d0ef      	beq.n	81093d6 <SDMMC_GetCmdResp3+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 81093f6:	68bb      	ldr	r3, [r7, #8]
 81093f8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 81093fc:	2b00      	cmp	r3, #0
 81093fe:	d1ea      	bne.n	81093d6 <SDMMC_GetCmdResp3+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8109400:	687b      	ldr	r3, [r7, #4]
 8109402:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8109404:	f003 0304 	and.w	r3, r3, #4
 8109408:	2b00      	cmp	r3, #0
 810940a:	d004      	beq.n	8109416 <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 810940c:	687b      	ldr	r3, [r7, #4]
 810940e:	2204      	movs	r2, #4
 8109410:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8109412:	2304      	movs	r3, #4
 8109414:	e003      	b.n	810941e <SDMMC_GetCmdResp3+0x66>
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8109416:	687b      	ldr	r3, [r7, #4]
 8109418:	4a06      	ldr	r2, [pc, #24]	@ (8109434 <SDMMC_GetCmdResp3+0x7c>)
 810941a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 810941c:	2300      	movs	r3, #0
}
 810941e:	4618      	mov	r0, r3
 8109420:	3714      	adds	r7, #20
 8109422:	46bd      	mov	sp, r7
 8109424:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109428:	4770      	bx	lr
 810942a:	bf00      	nop
 810942c:	10032028 	.word	0x10032028
 8109430:	10624dd3 	.word	0x10624dd3
 8109434:	002000c5 	.word	0x002000c5

08109438 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
 8109438:	b480      	push	{r7}
 810943a:	b085      	sub	sp, #20
 810943c:	af00      	add	r7, sp, #0
 810943e:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 8109440:	4b11      	ldr	r3, [pc, #68]	@ (8109488 <SDMMC_GetCmdError+0x50>)
 8109442:	681b      	ldr	r3, [r3, #0]
 8109444:	4a11      	ldr	r2, [pc, #68]	@ (810948c <SDMMC_GetCmdError+0x54>)
 8109446:	fba2 2303 	umull	r2, r3, r2, r3
 810944a:	0a5b      	lsrs	r3, r3, #9
 810944c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8109450:	fb02 f303 	mul.w	r3, r2, r3
 8109454:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 8109456:	68fb      	ldr	r3, [r7, #12]
 8109458:	1e5a      	subs	r2, r3, #1
 810945a:	60fa      	str	r2, [r7, #12]
 810945c:	2b00      	cmp	r3, #0
 810945e:	d102      	bne.n	8109466 <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 8109460:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8109464:	e009      	b.n	810947a <SDMMC_GetCmdError+0x42>
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 8109466:	687b      	ldr	r3, [r7, #4]
 8109468:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810946a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810946e:	2b00      	cmp	r3, #0
 8109470:	d0f1      	beq.n	8109456 <SDMMC_GetCmdError+0x1e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8109472:	687b      	ldr	r3, [r7, #4]
 8109474:	4a06      	ldr	r2, [pc, #24]	@ (8109490 <SDMMC_GetCmdError+0x58>)
 8109476:	639a      	str	r2, [r3, #56]	@ 0x38

  return SDMMC_ERROR_NONE;
 8109478:	2300      	movs	r3, #0
}
 810947a:	4618      	mov	r0, r3
 810947c:	3714      	adds	r7, #20
 810947e:	46bd      	mov	sp, r7
 8109480:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109484:	4770      	bx	lr
 8109486:	bf00      	nop
 8109488:	10032028 	.word	0x10032028
 810948c:	10624dd3 	.word	0x10624dd3
 8109490:	002000c5 	.word	0x002000c5

08109494 <LL_TIM_SetPrescaler>:
{
 8109494:	b480      	push	{r7}
 8109496:	b083      	sub	sp, #12
 8109498:	af00      	add	r7, sp, #0
 810949a:	6078      	str	r0, [r7, #4]
 810949c:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->PSC, Prescaler);
 810949e:	687b      	ldr	r3, [r7, #4]
 81094a0:	683a      	ldr	r2, [r7, #0]
 81094a2:	629a      	str	r2, [r3, #40]	@ 0x28
}
 81094a4:	bf00      	nop
 81094a6:	370c      	adds	r7, #12
 81094a8:	46bd      	mov	sp, r7
 81094aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 81094ae:	4770      	bx	lr

081094b0 <LL_TIM_SetAutoReload>:
{
 81094b0:	b480      	push	{r7}
 81094b2:	b083      	sub	sp, #12
 81094b4:	af00      	add	r7, sp, #0
 81094b6:	6078      	str	r0, [r7, #4]
 81094b8:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 81094ba:	687b      	ldr	r3, [r7, #4]
 81094bc:	683a      	ldr	r2, [r7, #0]
 81094be:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 81094c0:	bf00      	nop
 81094c2:	370c      	adds	r7, #12
 81094c4:	46bd      	mov	sp, r7
 81094c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81094ca:	4770      	bx	lr

081094cc <LL_TIM_SetRepetitionCounter>:
{
 81094cc:	b480      	push	{r7}
 81094ce:	b083      	sub	sp, #12
 81094d0:	af00      	add	r7, sp, #0
 81094d2:	6078      	str	r0, [r7, #4]
 81094d4:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 81094d6:	687b      	ldr	r3, [r7, #4]
 81094d8:	683a      	ldr	r2, [r7, #0]
 81094da:	631a      	str	r2, [r3, #48]	@ 0x30
}
 81094dc:	bf00      	nop
 81094de:	370c      	adds	r7, #12
 81094e0:	46bd      	mov	sp, r7
 81094e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81094e6:	4770      	bx	lr

081094e8 <LL_TIM_GenerateEvent_UPDATE>:
  * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
 81094e8:	b480      	push	{r7}
 81094ea:	b083      	sub	sp, #12
 81094ec:	af00      	add	r7, sp, #0
 81094ee:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 81094f0:	687b      	ldr	r3, [r7, #4]
 81094f2:	695b      	ldr	r3, [r3, #20]
 81094f4:	f043 0201 	orr.w	r2, r3, #1
 81094f8:	687b      	ldr	r3, [r7, #4]
 81094fa:	615a      	str	r2, [r3, #20]
}
 81094fc:	bf00      	nop
 81094fe:	370c      	adds	r7, #12
 8109500:	46bd      	mov	sp, r7
 8109502:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109506:	4770      	bx	lr

08109508 <LL_TIM_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, const LL_TIM_InitTypeDef *TIM_InitStruct)
{
 8109508:	b580      	push	{r7, lr}
 810950a:	b084      	sub	sp, #16
 810950c:	af00      	add	r7, sp, #0
 810950e:	6078      	str	r0, [r7, #4]
 8109510:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(TIMx));
  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));

  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 8109512:	687b      	ldr	r3, [r7, #4]
 8109514:	681b      	ldr	r3, [r3, #0]
 8109516:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8109518:	687b      	ldr	r3, [r7, #4]
 810951a:	4a3d      	ldr	r2, [pc, #244]	@ (8109610 <LL_TIM_Init+0x108>)
 810951c:	4293      	cmp	r3, r2
 810951e:	d013      	beq.n	8109548 <LL_TIM_Init+0x40>
 8109520:	687b      	ldr	r3, [r7, #4]
 8109522:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8109526:	d00f      	beq.n	8109548 <LL_TIM_Init+0x40>
 8109528:	687b      	ldr	r3, [r7, #4]
 810952a:	4a3a      	ldr	r2, [pc, #232]	@ (8109614 <LL_TIM_Init+0x10c>)
 810952c:	4293      	cmp	r3, r2
 810952e:	d00b      	beq.n	8109548 <LL_TIM_Init+0x40>
 8109530:	687b      	ldr	r3, [r7, #4]
 8109532:	4a39      	ldr	r2, [pc, #228]	@ (8109618 <LL_TIM_Init+0x110>)
 8109534:	4293      	cmp	r3, r2
 8109536:	d007      	beq.n	8109548 <LL_TIM_Init+0x40>
 8109538:	687b      	ldr	r3, [r7, #4]
 810953a:	4a38      	ldr	r2, [pc, #224]	@ (810961c <LL_TIM_Init+0x114>)
 810953c:	4293      	cmp	r3, r2
 810953e:	d003      	beq.n	8109548 <LL_TIM_Init+0x40>
 8109540:	687b      	ldr	r3, [r7, #4]
 8109542:	4a37      	ldr	r2, [pc, #220]	@ (8109620 <LL_TIM_Init+0x118>)
 8109544:	4293      	cmp	r3, r2
 8109546:	d106      	bne.n	8109556 <LL_TIM_Init+0x4e>
  {
    /* Select the Counter Mode */
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 8109548:	68fb      	ldr	r3, [r7, #12]
 810954a:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 810954e:	683b      	ldr	r3, [r7, #0]
 8109550:	685b      	ldr	r3, [r3, #4]
 8109552:	4313      	orrs	r3, r2
 8109554:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8109556:	687b      	ldr	r3, [r7, #4]
 8109558:	4a2d      	ldr	r2, [pc, #180]	@ (8109610 <LL_TIM_Init+0x108>)
 810955a:	4293      	cmp	r3, r2
 810955c:	d01f      	beq.n	810959e <LL_TIM_Init+0x96>
 810955e:	687b      	ldr	r3, [r7, #4]
 8109560:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8109564:	d01b      	beq.n	810959e <LL_TIM_Init+0x96>
 8109566:	687b      	ldr	r3, [r7, #4]
 8109568:	4a2a      	ldr	r2, [pc, #168]	@ (8109614 <LL_TIM_Init+0x10c>)
 810956a:	4293      	cmp	r3, r2
 810956c:	d017      	beq.n	810959e <LL_TIM_Init+0x96>
 810956e:	687b      	ldr	r3, [r7, #4]
 8109570:	4a29      	ldr	r2, [pc, #164]	@ (8109618 <LL_TIM_Init+0x110>)
 8109572:	4293      	cmp	r3, r2
 8109574:	d013      	beq.n	810959e <LL_TIM_Init+0x96>
 8109576:	687b      	ldr	r3, [r7, #4]
 8109578:	4a28      	ldr	r2, [pc, #160]	@ (810961c <LL_TIM_Init+0x114>)
 810957a:	4293      	cmp	r3, r2
 810957c:	d00f      	beq.n	810959e <LL_TIM_Init+0x96>
 810957e:	687b      	ldr	r3, [r7, #4]
 8109580:	4a27      	ldr	r2, [pc, #156]	@ (8109620 <LL_TIM_Init+0x118>)
 8109582:	4293      	cmp	r3, r2
 8109584:	d00b      	beq.n	810959e <LL_TIM_Init+0x96>
 8109586:	687b      	ldr	r3, [r7, #4]
 8109588:	4a26      	ldr	r2, [pc, #152]	@ (8109624 <LL_TIM_Init+0x11c>)
 810958a:	4293      	cmp	r3, r2
 810958c:	d007      	beq.n	810959e <LL_TIM_Init+0x96>
 810958e:	687b      	ldr	r3, [r7, #4]
 8109590:	4a25      	ldr	r2, [pc, #148]	@ (8109628 <LL_TIM_Init+0x120>)
 8109592:	4293      	cmp	r3, r2
 8109594:	d003      	beq.n	810959e <LL_TIM_Init+0x96>
 8109596:	687b      	ldr	r3, [r7, #4]
 8109598:	4a24      	ldr	r2, [pc, #144]	@ (810962c <LL_TIM_Init+0x124>)
 810959a:	4293      	cmp	r3, r2
 810959c:	d106      	bne.n	81095ac <LL_TIM_Init+0xa4>
  {
    /* Set the clock division */
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 810959e:	68fb      	ldr	r3, [r7, #12]
 81095a0:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 81095a4:	683b      	ldr	r3, [r7, #0]
 81095a6:	68db      	ldr	r3, [r3, #12]
 81095a8:	4313      	orrs	r3, r2
 81095aa:	60fb      	str	r3, [r7, #12]
  }

  /* Write to TIMx CR1 */
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 81095ac:	687b      	ldr	r3, [r7, #4]
 81095ae:	68fa      	ldr	r2, [r7, #12]
 81095b0:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 81095b2:	683b      	ldr	r3, [r7, #0]
 81095b4:	689b      	ldr	r3, [r3, #8]
 81095b6:	4619      	mov	r1, r3
 81095b8:	6878      	ldr	r0, [r7, #4]
 81095ba:	f7ff ff79 	bl	81094b0 <LL_TIM_SetAutoReload>

  /* Set the Prescaler value */
  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 81095be:	683b      	ldr	r3, [r7, #0]
 81095c0:	881b      	ldrh	r3, [r3, #0]
 81095c2:	4619      	mov	r1, r3
 81095c4:	6878      	ldr	r0, [r7, #4]
 81095c6:	f7ff ff65 	bl	8109494 <LL_TIM_SetPrescaler>

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 81095ca:	687b      	ldr	r3, [r7, #4]
 81095cc:	4a10      	ldr	r2, [pc, #64]	@ (8109610 <LL_TIM_Init+0x108>)
 81095ce:	4293      	cmp	r3, r2
 81095d0:	d00f      	beq.n	81095f2 <LL_TIM_Init+0xea>
 81095d2:	687b      	ldr	r3, [r7, #4]
 81095d4:	4a12      	ldr	r2, [pc, #72]	@ (8109620 <LL_TIM_Init+0x118>)
 81095d6:	4293      	cmp	r3, r2
 81095d8:	d00b      	beq.n	81095f2 <LL_TIM_Init+0xea>
 81095da:	687b      	ldr	r3, [r7, #4]
 81095dc:	4a11      	ldr	r2, [pc, #68]	@ (8109624 <LL_TIM_Init+0x11c>)
 81095de:	4293      	cmp	r3, r2
 81095e0:	d007      	beq.n	81095f2 <LL_TIM_Init+0xea>
 81095e2:	687b      	ldr	r3, [r7, #4]
 81095e4:	4a10      	ldr	r2, [pc, #64]	@ (8109628 <LL_TIM_Init+0x120>)
 81095e6:	4293      	cmp	r3, r2
 81095e8:	d003      	beq.n	81095f2 <LL_TIM_Init+0xea>
 81095ea:	687b      	ldr	r3, [r7, #4]
 81095ec:	4a0f      	ldr	r2, [pc, #60]	@ (810962c <LL_TIM_Init+0x124>)
 81095ee:	4293      	cmp	r3, r2
 81095f0:	d105      	bne.n	81095fe <LL_TIM_Init+0xf6>
  {
    /* Set the Repetition Counter value */
    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 81095f2:	683b      	ldr	r3, [r7, #0]
 81095f4:	691b      	ldr	r3, [r3, #16]
 81095f6:	4619      	mov	r1, r3
 81095f8:	6878      	ldr	r0, [r7, #4]
 81095fa:	f7ff ff67 	bl	81094cc <LL_TIM_SetRepetitionCounter>
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter value (if applicable) immediately */
  LL_TIM_GenerateEvent_UPDATE(TIMx);
 81095fe:	6878      	ldr	r0, [r7, #4]
 8109600:	f7ff ff72 	bl	81094e8 <LL_TIM_GenerateEvent_UPDATE>

  return SUCCESS;
 8109604:	2300      	movs	r3, #0
}
 8109606:	4618      	mov	r0, r3
 8109608:	3710      	adds	r7, #16
 810960a:	46bd      	mov	sp, r7
 810960c:	bd80      	pop	{r7, pc}
 810960e:	bf00      	nop
 8109610:	40010000 	.word	0x40010000
 8109614:	40000400 	.word	0x40000400
 8109618:	40000800 	.word	0x40000800
 810961c:	40000c00 	.word	0x40000c00
 8109620:	40010400 	.word	0x40010400
 8109624:	40014000 	.word	0x40014000
 8109628:	40014400 	.word	0x40014400
 810962c:	40014800 	.word	0x40014800

08109630 <LL_USART_IsEnabled>:
{
 8109630:	b480      	push	{r7}
 8109632:	b083      	sub	sp, #12
 8109634:	af00      	add	r7, sp, #0
 8109636:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE)) ? 1UL : 0UL);
 8109638:	687b      	ldr	r3, [r7, #4]
 810963a:	681b      	ldr	r3, [r3, #0]
 810963c:	f003 0301 	and.w	r3, r3, #1
 8109640:	2b01      	cmp	r3, #1
 8109642:	d101      	bne.n	8109648 <LL_USART_IsEnabled+0x18>
 8109644:	2301      	movs	r3, #1
 8109646:	e000      	b.n	810964a <LL_USART_IsEnabled+0x1a>
 8109648:	2300      	movs	r3, #0
}
 810964a:	4618      	mov	r0, r3
 810964c:	370c      	adds	r7, #12
 810964e:	46bd      	mov	sp, r7
 8109650:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109654:	4770      	bx	lr

08109656 <LL_USART_SetPrescaler>:
{
 8109656:	b480      	push	{r7}
 8109658:	b083      	sub	sp, #12
 810965a:	af00      	add	r7, sp, #0
 810965c:	6078      	str	r0, [r7, #4]
 810965e:	6039      	str	r1, [r7, #0]
  MODIFY_REG(USARTx->PRESC, USART_PRESC_PRESCALER, (uint16_t)PrescalerValue);
 8109660:	687b      	ldr	r3, [r7, #4]
 8109662:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8109664:	f023 030f 	bic.w	r3, r3, #15
 8109668:	683a      	ldr	r2, [r7, #0]
 810966a:	b292      	uxth	r2, r2
 810966c:	431a      	orrs	r2, r3
 810966e:	687b      	ldr	r3, [r7, #4]
 8109670:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 8109672:	bf00      	nop
 8109674:	370c      	adds	r7, #12
 8109676:	46bd      	mov	sp, r7
 8109678:	f85d 7b04 	ldr.w	r7, [sp], #4
 810967c:	4770      	bx	lr

0810967e <LL_USART_SetStopBitsLength>:
{
 810967e:	b480      	push	{r7}
 8109680:	b083      	sub	sp, #12
 8109682:	af00      	add	r7, sp, #0
 8109684:	6078      	str	r0, [r7, #4]
 8109686:	6039      	str	r1, [r7, #0]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8109688:	687b      	ldr	r3, [r7, #4]
 810968a:	685b      	ldr	r3, [r3, #4]
 810968c:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
 8109690:	683b      	ldr	r3, [r7, #0]
 8109692:	431a      	orrs	r2, r3
 8109694:	687b      	ldr	r3, [r7, #4]
 8109696:	605a      	str	r2, [r3, #4]
}
 8109698:	bf00      	nop
 810969a:	370c      	adds	r7, #12
 810969c:	46bd      	mov	sp, r7
 810969e:	f85d 7b04 	ldr.w	r7, [sp], #4
 81096a2:	4770      	bx	lr

081096a4 <LL_USART_SetHWFlowCtrl>:
{
 81096a4:	b480      	push	{r7}
 81096a6:	b083      	sub	sp, #12
 81096a8:	af00      	add	r7, sp, #0
 81096aa:	6078      	str	r0, [r7, #4]
 81096ac:	6039      	str	r1, [r7, #0]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 81096ae:	687b      	ldr	r3, [r7, #4]
 81096b0:	689b      	ldr	r3, [r3, #8]
 81096b2:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 81096b6:	683b      	ldr	r3, [r7, #0]
 81096b8:	431a      	orrs	r2, r3
 81096ba:	687b      	ldr	r3, [r7, #4]
 81096bc:	609a      	str	r2, [r3, #8]
}
 81096be:	bf00      	nop
 81096c0:	370c      	adds	r7, #12
 81096c2:	46bd      	mov	sp, r7
 81096c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81096c8:	4770      	bx	lr
	...

081096cc <LL_USART_SetBaudRate>:
{
 81096cc:	b480      	push	{r7}
 81096ce:	b087      	sub	sp, #28
 81096d0:	af00      	add	r7, sp, #0
 81096d2:	60f8      	str	r0, [r7, #12]
 81096d4:	60b9      	str	r1, [r7, #8]
 81096d6:	607a      	str	r2, [r7, #4]
 81096d8:	603b      	str	r3, [r7, #0]
  if (PrescalerValue > LL_USART_PRESCALER_DIV256)
 81096da:	687b      	ldr	r3, [r7, #4]
 81096dc:	2b0b      	cmp	r3, #11
 81096de:	d83c      	bhi.n	810975a <LL_USART_SetBaudRate+0x8e>
  else if (BaudRate == 0U)
 81096e0:	6a3b      	ldr	r3, [r7, #32]
 81096e2:	2b00      	cmp	r3, #0
 81096e4:	d039      	beq.n	810975a <LL_USART_SetBaudRate+0x8e>
  else if (OverSampling == LL_USART_OVERSAMPLING_8)
 81096e6:	683b      	ldr	r3, [r7, #0]
 81096e8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 81096ec:	d122      	bne.n	8109734 <LL_USART_SetBaudRate+0x68>
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 81096ee:	687b      	ldr	r3, [r7, #4]
 81096f0:	b2db      	uxtb	r3, r3
 81096f2:	461a      	mov	r2, r3
 81096f4:	4b1c      	ldr	r3, [pc, #112]	@ (8109768 <LL_USART_SetBaudRate+0x9c>)
 81096f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 81096fa:	68ba      	ldr	r2, [r7, #8]
 81096fc:	fbb2 f3f3 	udiv	r3, r2, r3
 8109700:	005a      	lsls	r2, r3, #1
 8109702:	6a3b      	ldr	r3, [r7, #32]
 8109704:	085b      	lsrs	r3, r3, #1
 8109706:	441a      	add	r2, r3
 8109708:	6a3b      	ldr	r3, [r7, #32]
 810970a:	fbb2 f3f3 	udiv	r3, r2, r3
 810970e:	b29b      	uxth	r3, r3
 8109710:	617b      	str	r3, [r7, #20]
    brrtemp = usartdiv & 0xFFF0U;
 8109712:	697a      	ldr	r2, [r7, #20]
 8109714:	f64f 73f0 	movw	r3, #65520	@ 0xfff0
 8109718:	4013      	ands	r3, r2
 810971a:	613b      	str	r3, [r7, #16]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 810971c:	697b      	ldr	r3, [r7, #20]
 810971e:	085b      	lsrs	r3, r3, #1
 8109720:	b29b      	uxth	r3, r3
 8109722:	f003 0307 	and.w	r3, r3, #7
 8109726:	693a      	ldr	r2, [r7, #16]
 8109728:	4313      	orrs	r3, r2
 810972a:	613b      	str	r3, [r7, #16]
    USARTx->BRR = brrtemp;
 810972c:	68fb      	ldr	r3, [r7, #12]
 810972e:	693a      	ldr	r2, [r7, #16]
 8109730:	60da      	str	r2, [r3, #12]
}
 8109732:	e012      	b.n	810975a <LL_USART_SetBaudRate+0x8e>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 8109734:	687b      	ldr	r3, [r7, #4]
 8109736:	b2db      	uxtb	r3, r3
 8109738:	461a      	mov	r2, r3
 810973a:	4b0b      	ldr	r3, [pc, #44]	@ (8109768 <LL_USART_SetBaudRate+0x9c>)
 810973c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8109740:	68ba      	ldr	r2, [r7, #8]
 8109742:	fbb2 f2f3 	udiv	r2, r2, r3
 8109746:	6a3b      	ldr	r3, [r7, #32]
 8109748:	085b      	lsrs	r3, r3, #1
 810974a:	441a      	add	r2, r3
 810974c:	6a3b      	ldr	r3, [r7, #32]
 810974e:	fbb2 f3f3 	udiv	r3, r2, r3
 8109752:	b29b      	uxth	r3, r3
 8109754:	461a      	mov	r2, r3
 8109756:	68fb      	ldr	r3, [r7, #12]
 8109758:	60da      	str	r2, [r3, #12]
}
 810975a:	bf00      	nop
 810975c:	371c      	adds	r7, #28
 810975e:	46bd      	mov	sp, r7
 8109760:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109764:	4770      	bx	lr
 8109766:	bf00      	nop
 8109768:	0810da24 	.word	0x0810da24

0810976c <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, const LL_USART_InitTypeDef *USART_InitStruct)
{
 810976c:	b580      	push	{r7, lr}
 810976e:	b086      	sub	sp, #24
 8109770:	af02      	add	r7, sp, #8
 8109772:	6078      	str	r0, [r7, #4]
 8109774:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 8109776:	2301      	movs	r3, #1
 8109778:	73fb      	strb	r3, [r7, #15]
  uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
 810977a:	2300      	movs	r3, #0
 810977c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 810977e:	6878      	ldr	r0, [r7, #4]
 8109780:	f7ff ff56 	bl	8109630 <LL_USART_IsEnabled>
 8109784:	4603      	mov	r3, r0
 8109786:	2b00      	cmp	r3, #0
 8109788:	d17f      	bne.n	810988a <LL_USART_Init+0x11e>
     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
     */
    MODIFY_REG(USARTx->CR1,
 810978a:	687b      	ldr	r3, [r7, #4]
 810978c:	681a      	ldr	r2, [r3, #0]
 810978e:	4b41      	ldr	r3, [pc, #260]	@ (8109894 <LL_USART_Init+0x128>)
 8109790:	4013      	ands	r3, r2
 8109792:	683a      	ldr	r2, [r7, #0]
 8109794:	6891      	ldr	r1, [r2, #8]
 8109796:	683a      	ldr	r2, [r7, #0]
 8109798:	6912      	ldr	r2, [r2, #16]
 810979a:	4311      	orrs	r1, r2
 810979c:	683a      	ldr	r2, [r7, #0]
 810979e:	6952      	ldr	r2, [r2, #20]
 81097a0:	4311      	orrs	r1, r2
 81097a2:	683a      	ldr	r2, [r7, #0]
 81097a4:	69d2      	ldr	r2, [r2, #28]
 81097a6:	430a      	orrs	r2, r1
 81097a8:	431a      	orrs	r2, r3
 81097aa:	687b      	ldr	r3, [r7, #4]
 81097ac:	601a      	str	r2, [r3, #0]
    /*---------------------------- USART CR2 Configuration ---------------------
     * Configure USARTx CR2 (Stop bits) with parameters:
     * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
     * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
     */
    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
 81097ae:	683b      	ldr	r3, [r7, #0]
 81097b0:	68db      	ldr	r3, [r3, #12]
 81097b2:	4619      	mov	r1, r3
 81097b4:	6878      	ldr	r0, [r7, #4]
 81097b6:	f7ff ff62 	bl	810967e <LL_USART_SetStopBitsLength>
    /*---------------------------- USART CR3 Configuration ---------------------
     * Configure USARTx CR3 (Hardware Flow Control) with parameters:
     * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to
     *   USART_InitStruct->HardwareFlowControl value.
     */
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
 81097ba:	683b      	ldr	r3, [r7, #0]
 81097bc:	699b      	ldr	r3, [r3, #24]
 81097be:	4619      	mov	r1, r3
 81097c0:	6878      	ldr	r0, [r7, #4]
 81097c2:	f7ff ff6f 	bl	81096a4 <LL_USART_SetHWFlowCtrl>

    /*---------------------------- USART BRR Configuration ---------------------
     * Retrieve Clock frequency used for USART Peripheral
     */
    if (USARTx == USART1)
 81097c6:	687b      	ldr	r3, [r7, #4]
 81097c8:	4a33      	ldr	r2, [pc, #204]	@ (8109898 <LL_USART_Init+0x12c>)
 81097ca:	4293      	cmp	r3, r2
 81097cc:	d104      	bne.n	81097d8 <LL_USART_Init+0x6c>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);
 81097ce:	4833      	ldr	r0, [pc, #204]	@ (810989c <LL_USART_Init+0x130>)
 81097d0:	f7ff f8b4 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 81097d4:	60b8      	str	r0, [r7, #8]
 81097d6:	e03d      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == USART2)
 81097d8:	687b      	ldr	r3, [r7, #4]
 81097da:	4a31      	ldr	r2, [pc, #196]	@ (81098a0 <LL_USART_Init+0x134>)
 81097dc:	4293      	cmp	r3, r2
 81097de:	d104      	bne.n	81097ea <LL_USART_Init+0x7e>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 81097e0:	4830      	ldr	r0, [pc, #192]	@ (81098a4 <LL_USART_Init+0x138>)
 81097e2:	f7ff f8ab 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 81097e6:	60b8      	str	r0, [r7, #8]
 81097e8:	e034      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == USART3)
 81097ea:	687b      	ldr	r3, [r7, #4]
 81097ec:	4a2e      	ldr	r2, [pc, #184]	@ (81098a8 <LL_USART_Init+0x13c>)
 81097ee:	4293      	cmp	r3, r2
 81097f0:	d104      	bne.n	81097fc <LL_USART_Init+0x90>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 81097f2:	482c      	ldr	r0, [pc, #176]	@ (81098a4 <LL_USART_Init+0x138>)
 81097f4:	f7ff f8a2 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 81097f8:	60b8      	str	r0, [r7, #8]
 81097fa:	e02b      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == UART4)
 81097fc:	687b      	ldr	r3, [r7, #4]
 81097fe:	4a2b      	ldr	r2, [pc, #172]	@ (81098ac <LL_USART_Init+0x140>)
 8109800:	4293      	cmp	r3, r2
 8109802:	d104      	bne.n	810980e <LL_USART_Init+0xa2>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 8109804:	4827      	ldr	r0, [pc, #156]	@ (81098a4 <LL_USART_Init+0x138>)
 8109806:	f7ff f899 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 810980a:	60b8      	str	r0, [r7, #8]
 810980c:	e022      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == UART5)
 810980e:	687b      	ldr	r3, [r7, #4]
 8109810:	4a27      	ldr	r2, [pc, #156]	@ (81098b0 <LL_USART_Init+0x144>)
 8109812:	4293      	cmp	r3, r2
 8109814:	d104      	bne.n	8109820 <LL_USART_Init+0xb4>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 8109816:	4823      	ldr	r0, [pc, #140]	@ (81098a4 <LL_USART_Init+0x138>)
 8109818:	f7ff f890 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 810981c:	60b8      	str	r0, [r7, #8]
 810981e:	e019      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == USART6)
 8109820:	687b      	ldr	r3, [r7, #4]
 8109822:	4a24      	ldr	r2, [pc, #144]	@ (81098b4 <LL_USART_Init+0x148>)
 8109824:	4293      	cmp	r3, r2
 8109826:	d104      	bne.n	8109832 <LL_USART_Init+0xc6>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);
 8109828:	481c      	ldr	r0, [pc, #112]	@ (810989c <LL_USART_Init+0x130>)
 810982a:	f7ff f887 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 810982e:	60b8      	str	r0, [r7, #8]
 8109830:	e010      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == UART7)
 8109832:	687b      	ldr	r3, [r7, #4]
 8109834:	4a20      	ldr	r2, [pc, #128]	@ (81098b8 <LL_USART_Init+0x14c>)
 8109836:	4293      	cmp	r3, r2
 8109838:	d104      	bne.n	8109844 <LL_USART_Init+0xd8>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 810983a:	481a      	ldr	r0, [pc, #104]	@ (81098a4 <LL_USART_Init+0x138>)
 810983c:	f7ff f87e 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 8109840:	60b8      	str	r0, [r7, #8]
 8109842:	e007      	b.n	8109854 <LL_USART_Init+0xe8>
    }
    else if (USARTx == UART8)
 8109844:	687b      	ldr	r3, [r7, #4]
 8109846:	4a1d      	ldr	r2, [pc, #116]	@ (81098bc <LL_USART_Init+0x150>)
 8109848:	4293      	cmp	r3, r2
 810984a:	d103      	bne.n	8109854 <LL_USART_Init+0xe8>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 810984c:	4815      	ldr	r0, [pc, #84]	@ (81098a4 <LL_USART_Init+0x138>)
 810984e:	f7ff f875 	bl	810893c <LL_RCC_GetUSARTClockFreq>
 8109852:	60b8      	str	r0, [r7, #8]
    /* Configure the USART Baud Rate :
       - prescaler value is required
       - valid baud rate value (different from 0) is required
       - Peripheral clock as returned by RCC service, should be valid (different from 0).
    */
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 8109854:	68bb      	ldr	r3, [r7, #8]
 8109856:	2b00      	cmp	r3, #0
 8109858:	d011      	beq.n	810987e <LL_USART_Init+0x112>
        && (USART_InitStruct->BaudRate != 0U))
 810985a:	683b      	ldr	r3, [r7, #0]
 810985c:	685b      	ldr	r3, [r3, #4]
 810985e:	2b00      	cmp	r3, #0
 8109860:	d00d      	beq.n	810987e <LL_USART_Init+0x112>
    {
      status = SUCCESS;
 8109862:	2300      	movs	r3, #0
 8109864:	73fb      	strb	r3, [r7, #15]
      LL_USART_SetBaudRate(USARTx,
                           periphclk,
                           USART_InitStruct->PrescalerValue,
 8109866:	683b      	ldr	r3, [r7, #0]
 8109868:	681a      	ldr	r2, [r3, #0]
                           USART_InitStruct->OverSampling,
 810986a:	683b      	ldr	r3, [r7, #0]
 810986c:	69d9      	ldr	r1, [r3, #28]
                           USART_InitStruct->BaudRate);
 810986e:	683b      	ldr	r3, [r7, #0]
 8109870:	685b      	ldr	r3, [r3, #4]
      LL_USART_SetBaudRate(USARTx,
 8109872:	9300      	str	r3, [sp, #0]
 8109874:	460b      	mov	r3, r1
 8109876:	68b9      	ldr	r1, [r7, #8]
 8109878:	6878      	ldr	r0, [r7, #4]
 810987a:	f7ff ff27 	bl	81096cc <LL_USART_SetBaudRate>

    /*---------------------------- USART PRESC Configuration -----------------------
     * Configure USARTx PRESC (Prescaler) with parameters:
     * - PrescalerValue: USART_PRESC_PRESCALER bits according to USART_InitStruct->PrescalerValue value.
     */
    LL_USART_SetPrescaler(USARTx, USART_InitStruct->PrescalerValue);
 810987e:	683b      	ldr	r3, [r7, #0]
 8109880:	681b      	ldr	r3, [r3, #0]
 8109882:	4619      	mov	r1, r3
 8109884:	6878      	ldr	r0, [r7, #4]
 8109886:	f7ff fee6 	bl	8109656 <LL_USART_SetPrescaler>
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
 810988a:	7bfb      	ldrb	r3, [r7, #15]
}
 810988c:	4618      	mov	r0, r3
 810988e:	3710      	adds	r7, #16
 8109890:	46bd      	mov	sp, r7
 8109892:	bd80      	pop	{r7, pc}
 8109894:	efff69f3 	.word	0xefff69f3
 8109898:	40011000 	.word	0x40011000
 810989c:	07000308 	.word	0x07000308
 81098a0:	40004400 	.word	0x40004400
 81098a4:	07000008 	.word	0x07000008
 81098a8:	40004800 	.word	0x40004800
 81098ac:	40004c00 	.word	0x40004c00
 81098b0:	40005000 	.word	0x40005000
 81098b4:	40011400 	.word	0x40011400
 81098b8:	40007800 	.word	0x40007800
 81098bc:	40007c00 	.word	0x40007c00

081098c0 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 81098c0:	b084      	sub	sp, #16
 81098c2:	b580      	push	{r7, lr}
 81098c4:	b084      	sub	sp, #16
 81098c6:	af00      	add	r7, sp, #0
 81098c8:	6078      	str	r0, [r7, #4]
 81098ca:	f107 001c 	add.w	r0, r7, #28
 81098ce:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 81098d2:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 81098d6:	2b01      	cmp	r3, #1
 81098d8:	d123      	bne.n	8109922 <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 81098da:	687b      	ldr	r3, [r7, #4]
 81098dc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 81098de:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 81098e2:	687b      	ldr	r3, [r7, #4]
 81098e4:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 81098e6:	687b      	ldr	r3, [r7, #4]
 81098e8:	68db      	ldr	r3, [r3, #12]
 81098ea:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 81098ee:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 81098f2:	687a      	ldr	r2, [r7, #4]
 81098f4:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 81098f6:	687b      	ldr	r3, [r7, #4]
 81098f8:	68db      	ldr	r3, [r3, #12]
 81098fa:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 81098fe:	687b      	ldr	r3, [r7, #4]
 8109900:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8109902:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8109906:	2b01      	cmp	r3, #1
 8109908:	d105      	bne.n	8109916 <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 810990a:	687b      	ldr	r3, [r7, #4]
 810990c:	68db      	ldr	r3, [r3, #12]
 810990e:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 8109912:	687b      	ldr	r3, [r7, #4]
 8109914:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8109916:	6878      	ldr	r0, [r7, #4]
 8109918:	f001 faf0 	bl	810aefc <USB_CoreReset>
 810991c:	4603      	mov	r3, r0
 810991e:	73fb      	strb	r3, [r7, #15]
 8109920:	e01b      	b.n	810995a <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8109922:	687b      	ldr	r3, [r7, #4]
 8109924:	68db      	ldr	r3, [r3, #12]
 8109926:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 810992a:	687b      	ldr	r3, [r7, #4]
 810992c:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 810992e:	6878      	ldr	r0, [r7, #4]
 8109930:	f001 fae4 	bl	810aefc <USB_CoreReset>
 8109934:	4603      	mov	r3, r0
 8109936:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8109938:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 810993c:	2b00      	cmp	r3, #0
 810993e:	d106      	bne.n	810994e <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8109940:	687b      	ldr	r3, [r7, #4]
 8109942:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8109944:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8109948:	687b      	ldr	r3, [r7, #4]
 810994a:	639a      	str	r2, [r3, #56]	@ 0x38
 810994c:	e005      	b.n	810995a <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 810994e:	687b      	ldr	r3, [r7, #4]
 8109950:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8109952:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8109956:	687b      	ldr	r3, [r7, #4]
 8109958:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 810995a:	7fbb      	ldrb	r3, [r7, #30]
 810995c:	2b01      	cmp	r3, #1
 810995e:	d118      	bne.n	8109992 <USB_CoreInit+0xd2>
  {
    /* make sure to reserve 18 fifo Locations for DMA buffers */
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 8109960:	687b      	ldr	r3, [r7, #4]
 8109962:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8109964:	b29a      	uxth	r2, r3
 8109966:	687b      	ldr	r3, [r7, #4]
 8109968:	65da      	str	r2, [r3, #92]	@ 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 810996a:	687b      	ldr	r3, [r7, #4]
 810996c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810996e:	f043 737b 	orr.w	r3, r3, #65798144	@ 0x3ec0000
 8109972:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8109976:	687a      	ldr	r2, [r7, #4]
 8109978:	65d3      	str	r3, [r2, #92]	@ 0x5c

    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 810997a:	687b      	ldr	r3, [r7, #4]
 810997c:	689b      	ldr	r3, [r3, #8]
 810997e:	f043 0206 	orr.w	r2, r3, #6
 8109982:	687b      	ldr	r3, [r7, #4]
 8109984:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8109986:	687b      	ldr	r3, [r7, #4]
 8109988:	689b      	ldr	r3, [r3, #8]
 810998a:	f043 0220 	orr.w	r2, r3, #32
 810998e:	687b      	ldr	r3, [r7, #4]
 8109990:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8109992:	7bfb      	ldrb	r3, [r7, #15]
}
 8109994:	4618      	mov	r0, r3
 8109996:	3710      	adds	r7, #16
 8109998:	46bd      	mov	sp, r7
 810999a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 810999e:	b004      	add	sp, #16
 81099a0:	4770      	bx	lr
	...

081099a4 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 81099a4:	b480      	push	{r7}
 81099a6:	b087      	sub	sp, #28
 81099a8:	af00      	add	r7, sp, #0
 81099aa:	60f8      	str	r0, [r7, #12]
 81099ac:	60b9      	str	r1, [r7, #8]
 81099ae:	4613      	mov	r3, r2
 81099b0:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 81099b2:	79fb      	ldrb	r3, [r7, #7]
 81099b4:	2b02      	cmp	r3, #2
 81099b6:	d165      	bne.n	8109a84 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 81099b8:	68bb      	ldr	r3, [r7, #8]
 81099ba:	4a41      	ldr	r2, [pc, #260]	@ (8109ac0 <USB_SetTurnaroundTime+0x11c>)
 81099bc:	4293      	cmp	r3, r2
 81099be:	d906      	bls.n	81099ce <USB_SetTurnaroundTime+0x2a>
 81099c0:	68bb      	ldr	r3, [r7, #8]
 81099c2:	4a40      	ldr	r2, [pc, #256]	@ (8109ac4 <USB_SetTurnaroundTime+0x120>)
 81099c4:	4293      	cmp	r3, r2
 81099c6:	d202      	bcs.n	81099ce <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 81099c8:	230f      	movs	r3, #15
 81099ca:	617b      	str	r3, [r7, #20]
 81099cc:	e062      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 81099ce:	68bb      	ldr	r3, [r7, #8]
 81099d0:	4a3c      	ldr	r2, [pc, #240]	@ (8109ac4 <USB_SetTurnaroundTime+0x120>)
 81099d2:	4293      	cmp	r3, r2
 81099d4:	d306      	bcc.n	81099e4 <USB_SetTurnaroundTime+0x40>
 81099d6:	68bb      	ldr	r3, [r7, #8]
 81099d8:	4a3b      	ldr	r2, [pc, #236]	@ (8109ac8 <USB_SetTurnaroundTime+0x124>)
 81099da:	4293      	cmp	r3, r2
 81099dc:	d202      	bcs.n	81099e4 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 81099de:	230e      	movs	r3, #14
 81099e0:	617b      	str	r3, [r7, #20]
 81099e2:	e057      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 81099e4:	68bb      	ldr	r3, [r7, #8]
 81099e6:	4a38      	ldr	r2, [pc, #224]	@ (8109ac8 <USB_SetTurnaroundTime+0x124>)
 81099e8:	4293      	cmp	r3, r2
 81099ea:	d306      	bcc.n	81099fa <USB_SetTurnaroundTime+0x56>
 81099ec:	68bb      	ldr	r3, [r7, #8]
 81099ee:	4a37      	ldr	r2, [pc, #220]	@ (8109acc <USB_SetTurnaroundTime+0x128>)
 81099f0:	4293      	cmp	r3, r2
 81099f2:	d202      	bcs.n	81099fa <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 81099f4:	230d      	movs	r3, #13
 81099f6:	617b      	str	r3, [r7, #20]
 81099f8:	e04c      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 81099fa:	68bb      	ldr	r3, [r7, #8]
 81099fc:	4a33      	ldr	r2, [pc, #204]	@ (8109acc <USB_SetTurnaroundTime+0x128>)
 81099fe:	4293      	cmp	r3, r2
 8109a00:	d306      	bcc.n	8109a10 <USB_SetTurnaroundTime+0x6c>
 8109a02:	68bb      	ldr	r3, [r7, #8]
 8109a04:	4a32      	ldr	r2, [pc, #200]	@ (8109ad0 <USB_SetTurnaroundTime+0x12c>)
 8109a06:	4293      	cmp	r3, r2
 8109a08:	d802      	bhi.n	8109a10 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 8109a0a:	230c      	movs	r3, #12
 8109a0c:	617b      	str	r3, [r7, #20]
 8109a0e:	e041      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8109a10:	68bb      	ldr	r3, [r7, #8]
 8109a12:	4a2f      	ldr	r2, [pc, #188]	@ (8109ad0 <USB_SetTurnaroundTime+0x12c>)
 8109a14:	4293      	cmp	r3, r2
 8109a16:	d906      	bls.n	8109a26 <USB_SetTurnaroundTime+0x82>
 8109a18:	68bb      	ldr	r3, [r7, #8]
 8109a1a:	4a2e      	ldr	r2, [pc, #184]	@ (8109ad4 <USB_SetTurnaroundTime+0x130>)
 8109a1c:	4293      	cmp	r3, r2
 8109a1e:	d802      	bhi.n	8109a26 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 8109a20:	230b      	movs	r3, #11
 8109a22:	617b      	str	r3, [r7, #20]
 8109a24:	e036      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8109a26:	68bb      	ldr	r3, [r7, #8]
 8109a28:	4a2a      	ldr	r2, [pc, #168]	@ (8109ad4 <USB_SetTurnaroundTime+0x130>)
 8109a2a:	4293      	cmp	r3, r2
 8109a2c:	d906      	bls.n	8109a3c <USB_SetTurnaroundTime+0x98>
 8109a2e:	68bb      	ldr	r3, [r7, #8]
 8109a30:	4a29      	ldr	r2, [pc, #164]	@ (8109ad8 <USB_SetTurnaroundTime+0x134>)
 8109a32:	4293      	cmp	r3, r2
 8109a34:	d802      	bhi.n	8109a3c <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 8109a36:	230a      	movs	r3, #10
 8109a38:	617b      	str	r3, [r7, #20]
 8109a3a:	e02b      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8109a3c:	68bb      	ldr	r3, [r7, #8]
 8109a3e:	4a26      	ldr	r2, [pc, #152]	@ (8109ad8 <USB_SetTurnaroundTime+0x134>)
 8109a40:	4293      	cmp	r3, r2
 8109a42:	d906      	bls.n	8109a52 <USB_SetTurnaroundTime+0xae>
 8109a44:	68bb      	ldr	r3, [r7, #8]
 8109a46:	4a25      	ldr	r2, [pc, #148]	@ (8109adc <USB_SetTurnaroundTime+0x138>)
 8109a48:	4293      	cmp	r3, r2
 8109a4a:	d202      	bcs.n	8109a52 <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 8109a4c:	2309      	movs	r3, #9
 8109a4e:	617b      	str	r3, [r7, #20]
 8109a50:	e020      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8109a52:	68bb      	ldr	r3, [r7, #8]
 8109a54:	4a21      	ldr	r2, [pc, #132]	@ (8109adc <USB_SetTurnaroundTime+0x138>)
 8109a56:	4293      	cmp	r3, r2
 8109a58:	d306      	bcc.n	8109a68 <USB_SetTurnaroundTime+0xc4>
 8109a5a:	68bb      	ldr	r3, [r7, #8]
 8109a5c:	4a20      	ldr	r2, [pc, #128]	@ (8109ae0 <USB_SetTurnaroundTime+0x13c>)
 8109a5e:	4293      	cmp	r3, r2
 8109a60:	d802      	bhi.n	8109a68 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 8109a62:	2308      	movs	r3, #8
 8109a64:	617b      	str	r3, [r7, #20]
 8109a66:	e015      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8109a68:	68bb      	ldr	r3, [r7, #8]
 8109a6a:	4a1d      	ldr	r2, [pc, #116]	@ (8109ae0 <USB_SetTurnaroundTime+0x13c>)
 8109a6c:	4293      	cmp	r3, r2
 8109a6e:	d906      	bls.n	8109a7e <USB_SetTurnaroundTime+0xda>
 8109a70:	68bb      	ldr	r3, [r7, #8]
 8109a72:	4a1c      	ldr	r2, [pc, #112]	@ (8109ae4 <USB_SetTurnaroundTime+0x140>)
 8109a74:	4293      	cmp	r3, r2
 8109a76:	d202      	bcs.n	8109a7e <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 8109a78:	2307      	movs	r3, #7
 8109a7a:	617b      	str	r3, [r7, #20]
 8109a7c:	e00a      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 8109a7e:	2306      	movs	r3, #6
 8109a80:	617b      	str	r3, [r7, #20]
 8109a82:	e007      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 8109a84:	79fb      	ldrb	r3, [r7, #7]
 8109a86:	2b00      	cmp	r3, #0
 8109a88:	d102      	bne.n	8109a90 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 8109a8a:	2309      	movs	r3, #9
 8109a8c:	617b      	str	r3, [r7, #20]
 8109a8e:	e001      	b.n	8109a94 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 8109a90:	2309      	movs	r3, #9
 8109a92:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8109a94:	68fb      	ldr	r3, [r7, #12]
 8109a96:	68db      	ldr	r3, [r3, #12]
 8109a98:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 8109a9c:	68fb      	ldr	r3, [r7, #12]
 8109a9e:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 8109aa0:	68fb      	ldr	r3, [r7, #12]
 8109aa2:	68da      	ldr	r2, [r3, #12]
 8109aa4:	697b      	ldr	r3, [r7, #20]
 8109aa6:	029b      	lsls	r3, r3, #10
 8109aa8:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 8109aac:	431a      	orrs	r2, r3
 8109aae:	68fb      	ldr	r3, [r7, #12]
 8109ab0:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 8109ab2:	2300      	movs	r3, #0
}
 8109ab4:	4618      	mov	r0, r3
 8109ab6:	371c      	adds	r7, #28
 8109ab8:	46bd      	mov	sp, r7
 8109aba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109abe:	4770      	bx	lr
 8109ac0:	00d8acbf 	.word	0x00d8acbf
 8109ac4:	00e4e1c0 	.word	0x00e4e1c0
 8109ac8:	00f42400 	.word	0x00f42400
 8109acc:	01067380 	.word	0x01067380
 8109ad0:	011a499f 	.word	0x011a499f
 8109ad4:	01312cff 	.word	0x01312cff
 8109ad8:	014ca43f 	.word	0x014ca43f
 8109adc:	016e3600 	.word	0x016e3600
 8109ae0:	01a6ab1f 	.word	0x01a6ab1f
 8109ae4:	01e84800 	.word	0x01e84800

08109ae8 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8109ae8:	b480      	push	{r7}
 8109aea:	b083      	sub	sp, #12
 8109aec:	af00      	add	r7, sp, #0
 8109aee:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8109af0:	687b      	ldr	r3, [r7, #4]
 8109af2:	689b      	ldr	r3, [r3, #8]
 8109af4:	f043 0201 	orr.w	r2, r3, #1
 8109af8:	687b      	ldr	r3, [r7, #4]
 8109afa:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8109afc:	2300      	movs	r3, #0
}
 8109afe:	4618      	mov	r0, r3
 8109b00:	370c      	adds	r7, #12
 8109b02:	46bd      	mov	sp, r7
 8109b04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109b08:	4770      	bx	lr

08109b0a <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8109b0a:	b480      	push	{r7}
 8109b0c:	b083      	sub	sp, #12
 8109b0e:	af00      	add	r7, sp, #0
 8109b10:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8109b12:	687b      	ldr	r3, [r7, #4]
 8109b14:	689b      	ldr	r3, [r3, #8]
 8109b16:	f023 0201 	bic.w	r2, r3, #1
 8109b1a:	687b      	ldr	r3, [r7, #4]
 8109b1c:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8109b1e:	2300      	movs	r3, #0
}
 8109b20:	4618      	mov	r0, r3
 8109b22:	370c      	adds	r7, #12
 8109b24:	46bd      	mov	sp, r7
 8109b26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109b2a:	4770      	bx	lr

08109b2c <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8109b2c:	b580      	push	{r7, lr}
 8109b2e:	b084      	sub	sp, #16
 8109b30:	af00      	add	r7, sp, #0
 8109b32:	6078      	str	r0, [r7, #4]
 8109b34:	460b      	mov	r3, r1
 8109b36:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8109b38:	2300      	movs	r3, #0
 8109b3a:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8109b3c:	687b      	ldr	r3, [r7, #4]
 8109b3e:	68db      	ldr	r3, [r3, #12]
 8109b40:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 8109b44:	687b      	ldr	r3, [r7, #4]
 8109b46:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8109b48:	78fb      	ldrb	r3, [r7, #3]
 8109b4a:	2b01      	cmp	r3, #1
 8109b4c:	d115      	bne.n	8109b7a <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8109b4e:	687b      	ldr	r3, [r7, #4]
 8109b50:	68db      	ldr	r3, [r3, #12]
 8109b52:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 8109b56:	687b      	ldr	r3, [r7, #4]
 8109b58:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 8109b5a:	200a      	movs	r0, #10
 8109b5c:	f7f7 ff10 	bl	8101980 <HAL_Delay>
      ms += 10U;
 8109b60:	68fb      	ldr	r3, [r7, #12]
 8109b62:	330a      	adds	r3, #10
 8109b64:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8109b66:	6878      	ldr	r0, [r7, #4]
 8109b68:	f001 f939 	bl	810adde <USB_GetMode>
 8109b6c:	4603      	mov	r3, r0
 8109b6e:	2b01      	cmp	r3, #1
 8109b70:	d01e      	beq.n	8109bb0 <USB_SetCurrentMode+0x84>
 8109b72:	68fb      	ldr	r3, [r7, #12]
 8109b74:	2bc7      	cmp	r3, #199	@ 0xc7
 8109b76:	d9f0      	bls.n	8109b5a <USB_SetCurrentMode+0x2e>
 8109b78:	e01a      	b.n	8109bb0 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8109b7a:	78fb      	ldrb	r3, [r7, #3]
 8109b7c:	2b00      	cmp	r3, #0
 8109b7e:	d115      	bne.n	8109bac <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8109b80:	687b      	ldr	r3, [r7, #4]
 8109b82:	68db      	ldr	r3, [r3, #12]
 8109b84:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8109b88:	687b      	ldr	r3, [r7, #4]
 8109b8a:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 8109b8c:	200a      	movs	r0, #10
 8109b8e:	f7f7 fef7 	bl	8101980 <HAL_Delay>
      ms += 10U;
 8109b92:	68fb      	ldr	r3, [r7, #12]
 8109b94:	330a      	adds	r3, #10
 8109b96:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8109b98:	6878      	ldr	r0, [r7, #4]
 8109b9a:	f001 f920 	bl	810adde <USB_GetMode>
 8109b9e:	4603      	mov	r3, r0
 8109ba0:	2b00      	cmp	r3, #0
 8109ba2:	d005      	beq.n	8109bb0 <USB_SetCurrentMode+0x84>
 8109ba4:	68fb      	ldr	r3, [r7, #12]
 8109ba6:	2bc7      	cmp	r3, #199	@ 0xc7
 8109ba8:	d9f0      	bls.n	8109b8c <USB_SetCurrentMode+0x60>
 8109baa:	e001      	b.n	8109bb0 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8109bac:	2301      	movs	r3, #1
 8109bae:	e005      	b.n	8109bbc <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 8109bb0:	68fb      	ldr	r3, [r7, #12]
 8109bb2:	2bc8      	cmp	r3, #200	@ 0xc8
 8109bb4:	d101      	bne.n	8109bba <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8109bb6:	2301      	movs	r3, #1
 8109bb8:	e000      	b.n	8109bbc <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8109bba:	2300      	movs	r3, #0
}
 8109bbc:	4618      	mov	r0, r3
 8109bbe:	3710      	adds	r7, #16
 8109bc0:	46bd      	mov	sp, r7
 8109bc2:	bd80      	pop	{r7, pc}

08109bc4 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8109bc4:	b084      	sub	sp, #16
 8109bc6:	b580      	push	{r7, lr}
 8109bc8:	b086      	sub	sp, #24
 8109bca:	af00      	add	r7, sp, #0
 8109bcc:	6078      	str	r0, [r7, #4]
 8109bce:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 8109bd2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8109bd6:	2300      	movs	r3, #0
 8109bd8:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8109bda:	687b      	ldr	r3, [r7, #4]
 8109bdc:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 8109bde:	2300      	movs	r3, #0
 8109be0:	613b      	str	r3, [r7, #16]
 8109be2:	e009      	b.n	8109bf8 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 8109be4:	687a      	ldr	r2, [r7, #4]
 8109be6:	693b      	ldr	r3, [r7, #16]
 8109be8:	3340      	adds	r3, #64	@ 0x40
 8109bea:	009b      	lsls	r3, r3, #2
 8109bec:	4413      	add	r3, r2
 8109bee:	2200      	movs	r2, #0
 8109bf0:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 8109bf2:	693b      	ldr	r3, [r7, #16]
 8109bf4:	3301      	adds	r3, #1
 8109bf6:	613b      	str	r3, [r7, #16]
 8109bf8:	693b      	ldr	r3, [r7, #16]
 8109bfa:	2b0e      	cmp	r3, #14
 8109bfc:	d9f2      	bls.n	8109be4 <USB_DevInit+0x20>
  }

  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 8109bfe:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109c02:	2b00      	cmp	r3, #0
 8109c04:	d11c      	bne.n	8109c40 <USB_DevInit+0x7c>
  {
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8109c06:	68fb      	ldr	r3, [r7, #12]
 8109c08:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109c0c:	685b      	ldr	r3, [r3, #4]
 8109c0e:	68fa      	ldr	r2, [r7, #12]
 8109c10:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8109c14:	f043 0302 	orr.w	r3, r3, #2
 8109c18:	6053      	str	r3, [r2, #4]

    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 8109c1a:	687b      	ldr	r3, [r7, #4]
 8109c1c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8109c1e:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 8109c22:	687b      	ldr	r3, [r7, #4]
 8109c24:	639a      	str	r2, [r3, #56]	@ 0x38

    /* B-peripheral session valid override enable */
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 8109c26:	687b      	ldr	r3, [r7, #4]
 8109c28:	681b      	ldr	r3, [r3, #0]
 8109c2a:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8109c2e:	687b      	ldr	r3, [r7, #4]
 8109c30:	601a      	str	r2, [r3, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 8109c32:	687b      	ldr	r3, [r7, #4]
 8109c34:	681b      	ldr	r3, [r3, #0]
 8109c36:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8109c3a:	687b      	ldr	r3, [r7, #4]
 8109c3c:	601a      	str	r2, [r3, #0]
 8109c3e:	e005      	b.n	8109c4c <USB_DevInit+0x88>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8109c40:	687b      	ldr	r3, [r7, #4]
 8109c42:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8109c44:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 8109c48:	687b      	ldr	r3, [r7, #4]
 8109c4a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8109c4c:	68fb      	ldr	r3, [r7, #12]
 8109c4e:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8109c52:	461a      	mov	r2, r3
 8109c54:	2300      	movs	r3, #0
 8109c56:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8109c58:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8109c5c:	2b01      	cmp	r3, #1
 8109c5e:	d10d      	bne.n	8109c7c <USB_DevInit+0xb8>
  {
    if (cfg.speed == USBD_HS_SPEED)
 8109c60:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8109c64:	2b00      	cmp	r3, #0
 8109c66:	d104      	bne.n	8109c72 <USB_DevInit+0xae>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8109c68:	2100      	movs	r1, #0
 8109c6a:	6878      	ldr	r0, [r7, #4]
 8109c6c:	f000 f968 	bl	8109f40 <USB_SetDevSpeed>
 8109c70:	e008      	b.n	8109c84 <USB_DevInit+0xc0>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 8109c72:	2101      	movs	r1, #1
 8109c74:	6878      	ldr	r0, [r7, #4]
 8109c76:	f000 f963 	bl	8109f40 <USB_SetDevSpeed>
 8109c7a:	e003      	b.n	8109c84 <USB_DevInit+0xc0>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8109c7c:	2103      	movs	r1, #3
 8109c7e:	6878      	ldr	r0, [r7, #4]
 8109c80:	f000 f95e 	bl	8109f40 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8109c84:	2110      	movs	r1, #16
 8109c86:	6878      	ldr	r0, [r7, #4]
 8109c88:	f000 f8fa 	bl	8109e80 <USB_FlushTxFifo>
 8109c8c:	4603      	mov	r3, r0
 8109c8e:	2b00      	cmp	r3, #0
 8109c90:	d001      	beq.n	8109c96 <USB_DevInit+0xd2>
  {
    ret = HAL_ERROR;
 8109c92:	2301      	movs	r3, #1
 8109c94:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8109c96:	6878      	ldr	r0, [r7, #4]
 8109c98:	f000 f924 	bl	8109ee4 <USB_FlushRxFifo>
 8109c9c:	4603      	mov	r3, r0
 8109c9e:	2b00      	cmp	r3, #0
 8109ca0:	d001      	beq.n	8109ca6 <USB_DevInit+0xe2>
  {
    ret = HAL_ERROR;
 8109ca2:	2301      	movs	r3, #1
 8109ca4:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8109ca6:	68fb      	ldr	r3, [r7, #12]
 8109ca8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109cac:	461a      	mov	r2, r3
 8109cae:	2300      	movs	r3, #0
 8109cb0:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8109cb2:	68fb      	ldr	r3, [r7, #12]
 8109cb4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109cb8:	461a      	mov	r2, r3
 8109cba:	2300      	movs	r3, #0
 8109cbc:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8109cbe:	68fb      	ldr	r3, [r7, #12]
 8109cc0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109cc4:	461a      	mov	r2, r3
 8109cc6:	2300      	movs	r3, #0
 8109cc8:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8109cca:	2300      	movs	r3, #0
 8109ccc:	613b      	str	r3, [r7, #16]
 8109cce:	e043      	b.n	8109d58 <USB_DevInit+0x194>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8109cd0:	693b      	ldr	r3, [r7, #16]
 8109cd2:	015a      	lsls	r2, r3, #5
 8109cd4:	68fb      	ldr	r3, [r7, #12]
 8109cd6:	4413      	add	r3, r2
 8109cd8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109cdc:	681b      	ldr	r3, [r3, #0]
 8109cde:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8109ce2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8109ce6:	d118      	bne.n	8109d1a <USB_DevInit+0x156>
    {
      if (i == 0U)
 8109ce8:	693b      	ldr	r3, [r7, #16]
 8109cea:	2b00      	cmp	r3, #0
 8109cec:	d10a      	bne.n	8109d04 <USB_DevInit+0x140>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8109cee:	693b      	ldr	r3, [r7, #16]
 8109cf0:	015a      	lsls	r2, r3, #5
 8109cf2:	68fb      	ldr	r3, [r7, #12]
 8109cf4:	4413      	add	r3, r2
 8109cf6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109cfa:	461a      	mov	r2, r3
 8109cfc:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8109d00:	6013      	str	r3, [r2, #0]
 8109d02:	e013      	b.n	8109d2c <USB_DevInit+0x168>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8109d04:	693b      	ldr	r3, [r7, #16]
 8109d06:	015a      	lsls	r2, r3, #5
 8109d08:	68fb      	ldr	r3, [r7, #12]
 8109d0a:	4413      	add	r3, r2
 8109d0c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109d10:	461a      	mov	r2, r3
 8109d12:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8109d16:	6013      	str	r3, [r2, #0]
 8109d18:	e008      	b.n	8109d2c <USB_DevInit+0x168>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8109d1a:	693b      	ldr	r3, [r7, #16]
 8109d1c:	015a      	lsls	r2, r3, #5
 8109d1e:	68fb      	ldr	r3, [r7, #12]
 8109d20:	4413      	add	r3, r2
 8109d22:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109d26:	461a      	mov	r2, r3
 8109d28:	2300      	movs	r3, #0
 8109d2a:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 8109d2c:	693b      	ldr	r3, [r7, #16]
 8109d2e:	015a      	lsls	r2, r3, #5
 8109d30:	68fb      	ldr	r3, [r7, #12]
 8109d32:	4413      	add	r3, r2
 8109d34:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109d38:	461a      	mov	r2, r3
 8109d3a:	2300      	movs	r3, #0
 8109d3c:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8109d3e:	693b      	ldr	r3, [r7, #16]
 8109d40:	015a      	lsls	r2, r3, #5
 8109d42:	68fb      	ldr	r3, [r7, #12]
 8109d44:	4413      	add	r3, r2
 8109d46:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8109d4a:	461a      	mov	r2, r3
 8109d4c:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8109d50:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8109d52:	693b      	ldr	r3, [r7, #16]
 8109d54:	3301      	adds	r3, #1
 8109d56:	613b      	str	r3, [r7, #16]
 8109d58:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8109d5c:	461a      	mov	r2, r3
 8109d5e:	693b      	ldr	r3, [r7, #16]
 8109d60:	4293      	cmp	r3, r2
 8109d62:	d3b5      	bcc.n	8109cd0 <USB_DevInit+0x10c>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8109d64:	2300      	movs	r3, #0
 8109d66:	613b      	str	r3, [r7, #16]
 8109d68:	e043      	b.n	8109df2 <USB_DevInit+0x22e>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8109d6a:	693b      	ldr	r3, [r7, #16]
 8109d6c:	015a      	lsls	r2, r3, #5
 8109d6e:	68fb      	ldr	r3, [r7, #12]
 8109d70:	4413      	add	r3, r2
 8109d72:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109d76:	681b      	ldr	r3, [r3, #0]
 8109d78:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8109d7c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8109d80:	d118      	bne.n	8109db4 <USB_DevInit+0x1f0>
    {
      if (i == 0U)
 8109d82:	693b      	ldr	r3, [r7, #16]
 8109d84:	2b00      	cmp	r3, #0
 8109d86:	d10a      	bne.n	8109d9e <USB_DevInit+0x1da>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8109d88:	693b      	ldr	r3, [r7, #16]
 8109d8a:	015a      	lsls	r2, r3, #5
 8109d8c:	68fb      	ldr	r3, [r7, #12]
 8109d8e:	4413      	add	r3, r2
 8109d90:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109d94:	461a      	mov	r2, r3
 8109d96:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8109d9a:	6013      	str	r3, [r2, #0]
 8109d9c:	e013      	b.n	8109dc6 <USB_DevInit+0x202>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8109d9e:	693b      	ldr	r3, [r7, #16]
 8109da0:	015a      	lsls	r2, r3, #5
 8109da2:	68fb      	ldr	r3, [r7, #12]
 8109da4:	4413      	add	r3, r2
 8109da6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109daa:	461a      	mov	r2, r3
 8109dac:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8109db0:	6013      	str	r3, [r2, #0]
 8109db2:	e008      	b.n	8109dc6 <USB_DevInit+0x202>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8109db4:	693b      	ldr	r3, [r7, #16]
 8109db6:	015a      	lsls	r2, r3, #5
 8109db8:	68fb      	ldr	r3, [r7, #12]
 8109dba:	4413      	add	r3, r2
 8109dbc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109dc0:	461a      	mov	r2, r3
 8109dc2:	2300      	movs	r3, #0
 8109dc4:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8109dc6:	693b      	ldr	r3, [r7, #16]
 8109dc8:	015a      	lsls	r2, r3, #5
 8109dca:	68fb      	ldr	r3, [r7, #12]
 8109dcc:	4413      	add	r3, r2
 8109dce:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109dd2:	461a      	mov	r2, r3
 8109dd4:	2300      	movs	r3, #0
 8109dd6:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8109dd8:	693b      	ldr	r3, [r7, #16]
 8109dda:	015a      	lsls	r2, r3, #5
 8109ddc:	68fb      	ldr	r3, [r7, #12]
 8109dde:	4413      	add	r3, r2
 8109de0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8109de4:	461a      	mov	r2, r3
 8109de6:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8109dea:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8109dec:	693b      	ldr	r3, [r7, #16]
 8109dee:	3301      	adds	r3, #1
 8109df0:	613b      	str	r3, [r7, #16]
 8109df2:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8109df6:	461a      	mov	r2, r3
 8109df8:	693b      	ldr	r3, [r7, #16]
 8109dfa:	4293      	cmp	r3, r2
 8109dfc:	d3b5      	bcc.n	8109d6a <USB_DevInit+0x1a6>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8109dfe:	68fb      	ldr	r3, [r7, #12]
 8109e00:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109e04:	691b      	ldr	r3, [r3, #16]
 8109e06:	68fa      	ldr	r2, [r7, #12]
 8109e08:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8109e0c:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8109e10:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8109e12:	687b      	ldr	r3, [r7, #4]
 8109e14:	2200      	movs	r2, #0
 8109e16:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8109e18:	687b      	ldr	r3, [r7, #4]
 8109e1a:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 8109e1e:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8109e20:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8109e24:	2b00      	cmp	r3, #0
 8109e26:	d105      	bne.n	8109e34 <USB_DevInit+0x270>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8109e28:	687b      	ldr	r3, [r7, #4]
 8109e2a:	699b      	ldr	r3, [r3, #24]
 8109e2c:	f043 0210 	orr.w	r2, r3, #16
 8109e30:	687b      	ldr	r3, [r7, #4]
 8109e32:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8109e34:	687b      	ldr	r3, [r7, #4]
 8109e36:	699a      	ldr	r2, [r3, #24]
 8109e38:	4b10      	ldr	r3, [pc, #64]	@ (8109e7c <USB_DevInit+0x2b8>)
 8109e3a:	4313      	orrs	r3, r2
 8109e3c:	687a      	ldr	r2, [r7, #4]
 8109e3e:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 8109e40:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8109e44:	2b00      	cmp	r3, #0
 8109e46:	d005      	beq.n	8109e54 <USB_DevInit+0x290>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8109e48:	687b      	ldr	r3, [r7, #4]
 8109e4a:	699b      	ldr	r3, [r3, #24]
 8109e4c:	f043 0208 	orr.w	r2, r3, #8
 8109e50:	687b      	ldr	r3, [r7, #4]
 8109e52:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 8109e54:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109e58:	2b01      	cmp	r3, #1
 8109e5a:	d107      	bne.n	8109e6c <USB_DevInit+0x2a8>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8109e5c:	687b      	ldr	r3, [r7, #4]
 8109e5e:	699b      	ldr	r3, [r3, #24]
 8109e60:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8109e64:	f043 0304 	orr.w	r3, r3, #4
 8109e68:	687a      	ldr	r2, [r7, #4]
 8109e6a:	6193      	str	r3, [r2, #24]
  }

  return ret;
 8109e6c:	7dfb      	ldrb	r3, [r7, #23]
}
 8109e6e:	4618      	mov	r0, r3
 8109e70:	3718      	adds	r7, #24
 8109e72:	46bd      	mov	sp, r7
 8109e74:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8109e78:	b004      	add	sp, #16
 8109e7a:	4770      	bx	lr
 8109e7c:	803c3800 	.word	0x803c3800

08109e80 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8109e80:	b480      	push	{r7}
 8109e82:	b085      	sub	sp, #20
 8109e84:	af00      	add	r7, sp, #0
 8109e86:	6078      	str	r0, [r7, #4]
 8109e88:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8109e8a:	2300      	movs	r3, #0
 8109e8c:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8109e8e:	68fb      	ldr	r3, [r7, #12]
 8109e90:	3301      	adds	r3, #1
 8109e92:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8109e94:	68fb      	ldr	r3, [r7, #12]
 8109e96:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8109e9a:	d901      	bls.n	8109ea0 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8109e9c:	2303      	movs	r3, #3
 8109e9e:	e01b      	b.n	8109ed8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8109ea0:	687b      	ldr	r3, [r7, #4]
 8109ea2:	691b      	ldr	r3, [r3, #16]
 8109ea4:	2b00      	cmp	r3, #0
 8109ea6:	daf2      	bge.n	8109e8e <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8109ea8:	2300      	movs	r3, #0
 8109eaa:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8109eac:	683b      	ldr	r3, [r7, #0]
 8109eae:	019b      	lsls	r3, r3, #6
 8109eb0:	f043 0220 	orr.w	r2, r3, #32
 8109eb4:	687b      	ldr	r3, [r7, #4]
 8109eb6:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8109eb8:	68fb      	ldr	r3, [r7, #12]
 8109eba:	3301      	adds	r3, #1
 8109ebc:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8109ebe:	68fb      	ldr	r3, [r7, #12]
 8109ec0:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8109ec4:	d901      	bls.n	8109eca <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 8109ec6:	2303      	movs	r3, #3
 8109ec8:	e006      	b.n	8109ed8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8109eca:	687b      	ldr	r3, [r7, #4]
 8109ecc:	691b      	ldr	r3, [r3, #16]
 8109ece:	f003 0320 	and.w	r3, r3, #32
 8109ed2:	2b20      	cmp	r3, #32
 8109ed4:	d0f0      	beq.n	8109eb8 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 8109ed6:	2300      	movs	r3, #0
}
 8109ed8:	4618      	mov	r0, r3
 8109eda:	3714      	adds	r7, #20
 8109edc:	46bd      	mov	sp, r7
 8109ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109ee2:	4770      	bx	lr

08109ee4 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8109ee4:	b480      	push	{r7}
 8109ee6:	b085      	sub	sp, #20
 8109ee8:	af00      	add	r7, sp, #0
 8109eea:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8109eec:	2300      	movs	r3, #0
 8109eee:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8109ef0:	68fb      	ldr	r3, [r7, #12]
 8109ef2:	3301      	adds	r3, #1
 8109ef4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8109ef6:	68fb      	ldr	r3, [r7, #12]
 8109ef8:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8109efc:	d901      	bls.n	8109f02 <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 8109efe:	2303      	movs	r3, #3
 8109f00:	e018      	b.n	8109f34 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8109f02:	687b      	ldr	r3, [r7, #4]
 8109f04:	691b      	ldr	r3, [r3, #16]
 8109f06:	2b00      	cmp	r3, #0
 8109f08:	daf2      	bge.n	8109ef0 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8109f0a:	2300      	movs	r3, #0
 8109f0c:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8109f0e:	687b      	ldr	r3, [r7, #4]
 8109f10:	2210      	movs	r2, #16
 8109f12:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8109f14:	68fb      	ldr	r3, [r7, #12]
 8109f16:	3301      	adds	r3, #1
 8109f18:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8109f1a:	68fb      	ldr	r3, [r7, #12]
 8109f1c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8109f20:	d901      	bls.n	8109f26 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 8109f22:	2303      	movs	r3, #3
 8109f24:	e006      	b.n	8109f34 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8109f26:	687b      	ldr	r3, [r7, #4]
 8109f28:	691b      	ldr	r3, [r3, #16]
 8109f2a:	f003 0310 	and.w	r3, r3, #16
 8109f2e:	2b10      	cmp	r3, #16
 8109f30:	d0f0      	beq.n	8109f14 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 8109f32:	2300      	movs	r3, #0
}
 8109f34:	4618      	mov	r0, r3
 8109f36:	3714      	adds	r7, #20
 8109f38:	46bd      	mov	sp, r7
 8109f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109f3e:	4770      	bx	lr

08109f40 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 8109f40:	b480      	push	{r7}
 8109f42:	b085      	sub	sp, #20
 8109f44:	af00      	add	r7, sp, #0
 8109f46:	6078      	str	r0, [r7, #4]
 8109f48:	460b      	mov	r3, r1
 8109f4a:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8109f4c:	687b      	ldr	r3, [r7, #4]
 8109f4e:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 8109f50:	68fb      	ldr	r3, [r7, #12]
 8109f52:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109f56:	681a      	ldr	r2, [r3, #0]
 8109f58:	78fb      	ldrb	r3, [r7, #3]
 8109f5a:	68f9      	ldr	r1, [r7, #12]
 8109f5c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8109f60:	4313      	orrs	r3, r2
 8109f62:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 8109f64:	2300      	movs	r3, #0
}
 8109f66:	4618      	mov	r0, r3
 8109f68:	3714      	adds	r7, #20
 8109f6a:	46bd      	mov	sp, r7
 8109f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109f70:	4770      	bx	lr

08109f72 <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 8109f72:	b480      	push	{r7}
 8109f74:	b087      	sub	sp, #28
 8109f76:	af00      	add	r7, sp, #0
 8109f78:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8109f7a:	687b      	ldr	r3, [r7, #4]
 8109f7c:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8109f7e:	693b      	ldr	r3, [r7, #16]
 8109f80:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109f84:	689b      	ldr	r3, [r3, #8]
 8109f86:	f003 0306 	and.w	r3, r3, #6
 8109f8a:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8109f8c:	68fb      	ldr	r3, [r7, #12]
 8109f8e:	2b00      	cmp	r3, #0
 8109f90:	d102      	bne.n	8109f98 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 8109f92:	2300      	movs	r3, #0
 8109f94:	75fb      	strb	r3, [r7, #23]
 8109f96:	e00a      	b.n	8109fae <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8109f98:	68fb      	ldr	r3, [r7, #12]
 8109f9a:	2b02      	cmp	r3, #2
 8109f9c:	d002      	beq.n	8109fa4 <USB_GetDevSpeed+0x32>
 8109f9e:	68fb      	ldr	r3, [r7, #12]
 8109fa0:	2b06      	cmp	r3, #6
 8109fa2:	d102      	bne.n	8109faa <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 8109fa4:	2302      	movs	r3, #2
 8109fa6:	75fb      	strb	r3, [r7, #23]
 8109fa8:	e001      	b.n	8109fae <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8109faa:	230f      	movs	r3, #15
 8109fac:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 8109fae:	7dfb      	ldrb	r3, [r7, #23]
}
 8109fb0:	4618      	mov	r0, r3
 8109fb2:	371c      	adds	r7, #28
 8109fb4:	46bd      	mov	sp, r7
 8109fb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109fba:	4770      	bx	lr

08109fbc <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8109fbc:	b480      	push	{r7}
 8109fbe:	b085      	sub	sp, #20
 8109fc0:	af00      	add	r7, sp, #0
 8109fc2:	6078      	str	r0, [r7, #4]
 8109fc4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8109fc6:	687b      	ldr	r3, [r7, #4]
 8109fc8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8109fca:	683b      	ldr	r3, [r7, #0]
 8109fcc:	781b      	ldrb	r3, [r3, #0]
 8109fce:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8109fd0:	683b      	ldr	r3, [r7, #0]
 8109fd2:	785b      	ldrb	r3, [r3, #1]
 8109fd4:	2b01      	cmp	r3, #1
 8109fd6:	d13a      	bne.n	810a04e <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8109fd8:	68fb      	ldr	r3, [r7, #12]
 8109fda:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8109fde:	69da      	ldr	r2, [r3, #28]
 8109fe0:	683b      	ldr	r3, [r7, #0]
 8109fe2:	781b      	ldrb	r3, [r3, #0]
 8109fe4:	f003 030f 	and.w	r3, r3, #15
 8109fe8:	2101      	movs	r1, #1
 8109fea:	fa01 f303 	lsl.w	r3, r1, r3
 8109fee:	b29b      	uxth	r3, r3
 8109ff0:	68f9      	ldr	r1, [r7, #12]
 8109ff2:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8109ff6:	4313      	orrs	r3, r2
 8109ff8:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8109ffa:	68bb      	ldr	r3, [r7, #8]
 8109ffc:	015a      	lsls	r2, r3, #5
 8109ffe:	68fb      	ldr	r3, [r7, #12]
 810a000:	4413      	add	r3, r2
 810a002:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a006:	681b      	ldr	r3, [r3, #0]
 810a008:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 810a00c:	2b00      	cmp	r3, #0
 810a00e:	d155      	bne.n	810a0bc <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810a010:	68bb      	ldr	r3, [r7, #8]
 810a012:	015a      	lsls	r2, r3, #5
 810a014:	68fb      	ldr	r3, [r7, #12]
 810a016:	4413      	add	r3, r2
 810a018:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a01c:	681a      	ldr	r2, [r3, #0]
 810a01e:	683b      	ldr	r3, [r7, #0]
 810a020:	689b      	ldr	r3, [r3, #8]
 810a022:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 810a026:	683b      	ldr	r3, [r7, #0]
 810a028:	791b      	ldrb	r3, [r3, #4]
 810a02a:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810a02c:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 810a02e:	68bb      	ldr	r3, [r7, #8]
 810a030:	059b      	lsls	r3, r3, #22
 810a032:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810a034:	4313      	orrs	r3, r2
 810a036:	68ba      	ldr	r2, [r7, #8]
 810a038:	0151      	lsls	r1, r2, #5
 810a03a:	68fa      	ldr	r2, [r7, #12]
 810a03c:	440a      	add	r2, r1
 810a03e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a042:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810a046:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 810a04a:	6013      	str	r3, [r2, #0]
 810a04c:	e036      	b.n	810a0bc <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 810a04e:	68fb      	ldr	r3, [r7, #12]
 810a050:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a054:	69da      	ldr	r2, [r3, #28]
 810a056:	683b      	ldr	r3, [r7, #0]
 810a058:	781b      	ldrb	r3, [r3, #0]
 810a05a:	f003 030f 	and.w	r3, r3, #15
 810a05e:	2101      	movs	r1, #1
 810a060:	fa01 f303 	lsl.w	r3, r1, r3
 810a064:	041b      	lsls	r3, r3, #16
 810a066:	68f9      	ldr	r1, [r7, #12]
 810a068:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a06c:	4313      	orrs	r3, r2
 810a06e:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 810a070:	68bb      	ldr	r3, [r7, #8]
 810a072:	015a      	lsls	r2, r3, #5
 810a074:	68fb      	ldr	r3, [r7, #12]
 810a076:	4413      	add	r3, r2
 810a078:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a07c:	681b      	ldr	r3, [r3, #0]
 810a07e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 810a082:	2b00      	cmp	r3, #0
 810a084:	d11a      	bne.n	810a0bc <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 810a086:	68bb      	ldr	r3, [r7, #8]
 810a088:	015a      	lsls	r2, r3, #5
 810a08a:	68fb      	ldr	r3, [r7, #12]
 810a08c:	4413      	add	r3, r2
 810a08e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a092:	681a      	ldr	r2, [r3, #0]
 810a094:	683b      	ldr	r3, [r7, #0]
 810a096:	689b      	ldr	r3, [r3, #8]
 810a098:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 810a09c:	683b      	ldr	r3, [r7, #0]
 810a09e:	791b      	ldrb	r3, [r3, #4]
 810a0a0:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 810a0a2:	430b      	orrs	r3, r1
 810a0a4:	4313      	orrs	r3, r2
 810a0a6:	68ba      	ldr	r2, [r7, #8]
 810a0a8:	0151      	lsls	r1, r2, #5
 810a0aa:	68fa      	ldr	r2, [r7, #12]
 810a0ac:	440a      	add	r2, r1
 810a0ae:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a0b2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810a0b6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 810a0ba:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 810a0bc:	2300      	movs	r3, #0
}
 810a0be:	4618      	mov	r0, r3
 810a0c0:	3714      	adds	r7, #20
 810a0c2:	46bd      	mov	sp, r7
 810a0c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a0c8:	4770      	bx	lr
	...

0810a0cc <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810a0cc:	b480      	push	{r7}
 810a0ce:	b085      	sub	sp, #20
 810a0d0:	af00      	add	r7, sp, #0
 810a0d2:	6078      	str	r0, [r7, #4]
 810a0d4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810a0d6:	687b      	ldr	r3, [r7, #4]
 810a0d8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810a0da:	683b      	ldr	r3, [r7, #0]
 810a0dc:	781b      	ldrb	r3, [r3, #0]
 810a0de:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 810a0e0:	683b      	ldr	r3, [r7, #0]
 810a0e2:	785b      	ldrb	r3, [r3, #1]
 810a0e4:	2b01      	cmp	r3, #1
 810a0e6:	d161      	bne.n	810a1ac <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 810a0e8:	68bb      	ldr	r3, [r7, #8]
 810a0ea:	015a      	lsls	r2, r3, #5
 810a0ec:	68fb      	ldr	r3, [r7, #12]
 810a0ee:	4413      	add	r3, r2
 810a0f0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a0f4:	681b      	ldr	r3, [r3, #0]
 810a0f6:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a0fa:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a0fe:	d11f      	bne.n	810a140 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 810a100:	68bb      	ldr	r3, [r7, #8]
 810a102:	015a      	lsls	r2, r3, #5
 810a104:	68fb      	ldr	r3, [r7, #12]
 810a106:	4413      	add	r3, r2
 810a108:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a10c:	681b      	ldr	r3, [r3, #0]
 810a10e:	68ba      	ldr	r2, [r7, #8]
 810a110:	0151      	lsls	r1, r2, #5
 810a112:	68fa      	ldr	r2, [r7, #12]
 810a114:	440a      	add	r2, r1
 810a116:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a11a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 810a11e:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 810a120:	68bb      	ldr	r3, [r7, #8]
 810a122:	015a      	lsls	r2, r3, #5
 810a124:	68fb      	ldr	r3, [r7, #12]
 810a126:	4413      	add	r3, r2
 810a128:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a12c:	681b      	ldr	r3, [r3, #0]
 810a12e:	68ba      	ldr	r2, [r7, #8]
 810a130:	0151      	lsls	r1, r2, #5
 810a132:	68fa      	ldr	r2, [r7, #12]
 810a134:	440a      	add	r2, r1
 810a136:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a13a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 810a13e:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 810a140:	68fb      	ldr	r3, [r7, #12]
 810a142:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a146:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 810a148:	683b      	ldr	r3, [r7, #0]
 810a14a:	781b      	ldrb	r3, [r3, #0]
 810a14c:	f003 030f 	and.w	r3, r3, #15
 810a150:	2101      	movs	r1, #1
 810a152:	fa01 f303 	lsl.w	r3, r1, r3
 810a156:	b29b      	uxth	r3, r3
 810a158:	43db      	mvns	r3, r3
 810a15a:	68f9      	ldr	r1, [r7, #12]
 810a15c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a160:	4013      	ands	r3, r2
 810a162:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 810a164:	68fb      	ldr	r3, [r7, #12]
 810a166:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a16a:	69da      	ldr	r2, [r3, #28]
 810a16c:	683b      	ldr	r3, [r7, #0]
 810a16e:	781b      	ldrb	r3, [r3, #0]
 810a170:	f003 030f 	and.w	r3, r3, #15
 810a174:	2101      	movs	r1, #1
 810a176:	fa01 f303 	lsl.w	r3, r1, r3
 810a17a:	b29b      	uxth	r3, r3
 810a17c:	43db      	mvns	r3, r3
 810a17e:	68f9      	ldr	r1, [r7, #12]
 810a180:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a184:	4013      	ands	r3, r2
 810a186:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 810a188:	68bb      	ldr	r3, [r7, #8]
 810a18a:	015a      	lsls	r2, r3, #5
 810a18c:	68fb      	ldr	r3, [r7, #12]
 810a18e:	4413      	add	r3, r2
 810a190:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a194:	681a      	ldr	r2, [r3, #0]
 810a196:	68bb      	ldr	r3, [r7, #8]
 810a198:	0159      	lsls	r1, r3, #5
 810a19a:	68fb      	ldr	r3, [r7, #12]
 810a19c:	440b      	add	r3, r1
 810a19e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a1a2:	4619      	mov	r1, r3
 810a1a4:	4b35      	ldr	r3, [pc, #212]	@ (810a27c <USB_DeactivateEndpoint+0x1b0>)
 810a1a6:	4013      	ands	r3, r2
 810a1a8:	600b      	str	r3, [r1, #0]
 810a1aa:	e060      	b.n	810a26e <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810a1ac:	68bb      	ldr	r3, [r7, #8]
 810a1ae:	015a      	lsls	r2, r3, #5
 810a1b0:	68fb      	ldr	r3, [r7, #12]
 810a1b2:	4413      	add	r3, r2
 810a1b4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a1b8:	681b      	ldr	r3, [r3, #0]
 810a1ba:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a1be:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a1c2:	d11f      	bne.n	810a204 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 810a1c4:	68bb      	ldr	r3, [r7, #8]
 810a1c6:	015a      	lsls	r2, r3, #5
 810a1c8:	68fb      	ldr	r3, [r7, #12]
 810a1ca:	4413      	add	r3, r2
 810a1cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a1d0:	681b      	ldr	r3, [r3, #0]
 810a1d2:	68ba      	ldr	r2, [r7, #8]
 810a1d4:	0151      	lsls	r1, r2, #5
 810a1d6:	68fa      	ldr	r2, [r7, #12]
 810a1d8:	440a      	add	r2, r1
 810a1da:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a1de:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 810a1e2:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 810a1e4:	68bb      	ldr	r3, [r7, #8]
 810a1e6:	015a      	lsls	r2, r3, #5
 810a1e8:	68fb      	ldr	r3, [r7, #12]
 810a1ea:	4413      	add	r3, r2
 810a1ec:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a1f0:	681b      	ldr	r3, [r3, #0]
 810a1f2:	68ba      	ldr	r2, [r7, #8]
 810a1f4:	0151      	lsls	r1, r2, #5
 810a1f6:	68fa      	ldr	r2, [r7, #12]
 810a1f8:	440a      	add	r2, r1
 810a1fa:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a1fe:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 810a202:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 810a204:	68fb      	ldr	r3, [r7, #12]
 810a206:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a20a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 810a20c:	683b      	ldr	r3, [r7, #0]
 810a20e:	781b      	ldrb	r3, [r3, #0]
 810a210:	f003 030f 	and.w	r3, r3, #15
 810a214:	2101      	movs	r1, #1
 810a216:	fa01 f303 	lsl.w	r3, r1, r3
 810a21a:	041b      	lsls	r3, r3, #16
 810a21c:	43db      	mvns	r3, r3
 810a21e:	68f9      	ldr	r1, [r7, #12]
 810a220:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a224:	4013      	ands	r3, r2
 810a226:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 810a228:	68fb      	ldr	r3, [r7, #12]
 810a22a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a22e:	69da      	ldr	r2, [r3, #28]
 810a230:	683b      	ldr	r3, [r7, #0]
 810a232:	781b      	ldrb	r3, [r3, #0]
 810a234:	f003 030f 	and.w	r3, r3, #15
 810a238:	2101      	movs	r1, #1
 810a23a:	fa01 f303 	lsl.w	r3, r1, r3
 810a23e:	041b      	lsls	r3, r3, #16
 810a240:	43db      	mvns	r3, r3
 810a242:	68f9      	ldr	r1, [r7, #12]
 810a244:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a248:	4013      	ands	r3, r2
 810a24a:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 810a24c:	68bb      	ldr	r3, [r7, #8]
 810a24e:	015a      	lsls	r2, r3, #5
 810a250:	68fb      	ldr	r3, [r7, #12]
 810a252:	4413      	add	r3, r2
 810a254:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a258:	681a      	ldr	r2, [r3, #0]
 810a25a:	68bb      	ldr	r3, [r7, #8]
 810a25c:	0159      	lsls	r1, r3, #5
 810a25e:	68fb      	ldr	r3, [r7, #12]
 810a260:	440b      	add	r3, r1
 810a262:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a266:	4619      	mov	r1, r3
 810a268:	4b05      	ldr	r3, [pc, #20]	@ (810a280 <USB_DeactivateEndpoint+0x1b4>)
 810a26a:	4013      	ands	r3, r2
 810a26c:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 810a26e:	2300      	movs	r3, #0
}
 810a270:	4618      	mov	r0, r3
 810a272:	3714      	adds	r7, #20
 810a274:	46bd      	mov	sp, r7
 810a276:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a27a:	4770      	bx	lr
 810a27c:	ec337800 	.word	0xec337800
 810a280:	eff37800 	.word	0xeff37800

0810a284 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 810a284:	b580      	push	{r7, lr}
 810a286:	b08a      	sub	sp, #40	@ 0x28
 810a288:	af02      	add	r7, sp, #8
 810a28a:	60f8      	str	r0, [r7, #12]
 810a28c:	60b9      	str	r1, [r7, #8]
 810a28e:	4613      	mov	r3, r2
 810a290:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810a292:	68fb      	ldr	r3, [r7, #12]
 810a294:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 810a296:	68bb      	ldr	r3, [r7, #8]
 810a298:	781b      	ldrb	r3, [r3, #0]
 810a29a:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 810a29c:	68bb      	ldr	r3, [r7, #8]
 810a29e:	785b      	ldrb	r3, [r3, #1]
 810a2a0:	2b01      	cmp	r3, #1
 810a2a2:	f040 817f 	bne.w	810a5a4 <USB_EPStartXfer+0x320>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 810a2a6:	68bb      	ldr	r3, [r7, #8]
 810a2a8:	691b      	ldr	r3, [r3, #16]
 810a2aa:	2b00      	cmp	r3, #0
 810a2ac:	d132      	bne.n	810a314 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 810a2ae:	69bb      	ldr	r3, [r7, #24]
 810a2b0:	015a      	lsls	r2, r3, #5
 810a2b2:	69fb      	ldr	r3, [r7, #28]
 810a2b4:	4413      	add	r3, r2
 810a2b6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a2ba:	691b      	ldr	r3, [r3, #16]
 810a2bc:	69ba      	ldr	r2, [r7, #24]
 810a2be:	0151      	lsls	r1, r2, #5
 810a2c0:	69fa      	ldr	r2, [r7, #28]
 810a2c2:	440a      	add	r2, r1
 810a2c4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a2c8:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 810a2cc:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 810a2d0:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 810a2d2:	69bb      	ldr	r3, [r7, #24]
 810a2d4:	015a      	lsls	r2, r3, #5
 810a2d6:	69fb      	ldr	r3, [r7, #28]
 810a2d8:	4413      	add	r3, r2
 810a2da:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a2de:	691b      	ldr	r3, [r3, #16]
 810a2e0:	69ba      	ldr	r2, [r7, #24]
 810a2e2:	0151      	lsls	r1, r2, #5
 810a2e4:	69fa      	ldr	r2, [r7, #28]
 810a2e6:	440a      	add	r2, r1
 810a2e8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a2ec:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810a2f0:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 810a2f2:	69bb      	ldr	r3, [r7, #24]
 810a2f4:	015a      	lsls	r2, r3, #5
 810a2f6:	69fb      	ldr	r3, [r7, #28]
 810a2f8:	4413      	add	r3, r2
 810a2fa:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a2fe:	691b      	ldr	r3, [r3, #16]
 810a300:	69ba      	ldr	r2, [r7, #24]
 810a302:	0151      	lsls	r1, r2, #5
 810a304:	69fa      	ldr	r2, [r7, #28]
 810a306:	440a      	add	r2, r1
 810a308:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a30c:	0cdb      	lsrs	r3, r3, #19
 810a30e:	04db      	lsls	r3, r3, #19
 810a310:	6113      	str	r3, [r2, #16]
 810a312:	e097      	b.n	810a444 <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 810a314:	69bb      	ldr	r3, [r7, #24]
 810a316:	015a      	lsls	r2, r3, #5
 810a318:	69fb      	ldr	r3, [r7, #28]
 810a31a:	4413      	add	r3, r2
 810a31c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a320:	691b      	ldr	r3, [r3, #16]
 810a322:	69ba      	ldr	r2, [r7, #24]
 810a324:	0151      	lsls	r1, r2, #5
 810a326:	69fa      	ldr	r2, [r7, #28]
 810a328:	440a      	add	r2, r1
 810a32a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a32e:	0cdb      	lsrs	r3, r3, #19
 810a330:	04db      	lsls	r3, r3, #19
 810a332:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 810a334:	69bb      	ldr	r3, [r7, #24]
 810a336:	015a      	lsls	r2, r3, #5
 810a338:	69fb      	ldr	r3, [r7, #28]
 810a33a:	4413      	add	r3, r2
 810a33c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a340:	691b      	ldr	r3, [r3, #16]
 810a342:	69ba      	ldr	r2, [r7, #24]
 810a344:	0151      	lsls	r1, r2, #5
 810a346:	69fa      	ldr	r2, [r7, #28]
 810a348:	440a      	add	r2, r1
 810a34a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a34e:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 810a352:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 810a356:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 810a358:	69bb      	ldr	r3, [r7, #24]
 810a35a:	2b00      	cmp	r3, #0
 810a35c:	d11a      	bne.n	810a394 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 810a35e:	68bb      	ldr	r3, [r7, #8]
 810a360:	691a      	ldr	r2, [r3, #16]
 810a362:	68bb      	ldr	r3, [r7, #8]
 810a364:	689b      	ldr	r3, [r3, #8]
 810a366:	429a      	cmp	r2, r3
 810a368:	d903      	bls.n	810a372 <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 810a36a:	68bb      	ldr	r3, [r7, #8]
 810a36c:	689a      	ldr	r2, [r3, #8]
 810a36e:	68bb      	ldr	r3, [r7, #8]
 810a370:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 810a372:	69bb      	ldr	r3, [r7, #24]
 810a374:	015a      	lsls	r2, r3, #5
 810a376:	69fb      	ldr	r3, [r7, #28]
 810a378:	4413      	add	r3, r2
 810a37a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a37e:	691b      	ldr	r3, [r3, #16]
 810a380:	69ba      	ldr	r2, [r7, #24]
 810a382:	0151      	lsls	r1, r2, #5
 810a384:	69fa      	ldr	r2, [r7, #28]
 810a386:	440a      	add	r2, r1
 810a388:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a38c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810a390:	6113      	str	r3, [r2, #16]
 810a392:	e044      	b.n	810a41e <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 810a394:	68bb      	ldr	r3, [r7, #8]
 810a396:	691a      	ldr	r2, [r3, #16]
 810a398:	68bb      	ldr	r3, [r7, #8]
 810a39a:	689b      	ldr	r3, [r3, #8]
 810a39c:	4413      	add	r3, r2
 810a39e:	1e5a      	subs	r2, r3, #1
 810a3a0:	68bb      	ldr	r3, [r7, #8]
 810a3a2:	689b      	ldr	r3, [r3, #8]
 810a3a4:	fbb2 f3f3 	udiv	r3, r2, r3
 810a3a8:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19));
 810a3aa:	69bb      	ldr	r3, [r7, #24]
 810a3ac:	015a      	lsls	r2, r3, #5
 810a3ae:	69fb      	ldr	r3, [r7, #28]
 810a3b0:	4413      	add	r3, r2
 810a3b2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a3b6:	691a      	ldr	r2, [r3, #16]
 810a3b8:	8afb      	ldrh	r3, [r7, #22]
 810a3ba:	04d9      	lsls	r1, r3, #19
 810a3bc:	4ba4      	ldr	r3, [pc, #656]	@ (810a650 <USB_EPStartXfer+0x3cc>)
 810a3be:	400b      	ands	r3, r1
 810a3c0:	69b9      	ldr	r1, [r7, #24]
 810a3c2:	0148      	lsls	r0, r1, #5
 810a3c4:	69f9      	ldr	r1, [r7, #28]
 810a3c6:	4401      	add	r1, r0
 810a3c8:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 810a3cc:	4313      	orrs	r3, r2
 810a3ce:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
 810a3d0:	68bb      	ldr	r3, [r7, #8]
 810a3d2:	791b      	ldrb	r3, [r3, #4]
 810a3d4:	2b01      	cmp	r3, #1
 810a3d6:	d122      	bne.n	810a41e <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 810a3d8:	69bb      	ldr	r3, [r7, #24]
 810a3da:	015a      	lsls	r2, r3, #5
 810a3dc:	69fb      	ldr	r3, [r7, #28]
 810a3de:	4413      	add	r3, r2
 810a3e0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a3e4:	691b      	ldr	r3, [r3, #16]
 810a3e6:	69ba      	ldr	r2, [r7, #24]
 810a3e8:	0151      	lsls	r1, r2, #5
 810a3ea:	69fa      	ldr	r2, [r7, #28]
 810a3ec:	440a      	add	r2, r1
 810a3ee:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a3f2:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 810a3f6:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & ((uint32_t)pktcnt << 29));
 810a3f8:	69bb      	ldr	r3, [r7, #24]
 810a3fa:	015a      	lsls	r2, r3, #5
 810a3fc:	69fb      	ldr	r3, [r7, #28]
 810a3fe:	4413      	add	r3, r2
 810a400:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a404:	691a      	ldr	r2, [r3, #16]
 810a406:	8afb      	ldrh	r3, [r7, #22]
 810a408:	075b      	lsls	r3, r3, #29
 810a40a:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 810a40e:	69b9      	ldr	r1, [r7, #24]
 810a410:	0148      	lsls	r0, r1, #5
 810a412:	69f9      	ldr	r1, [r7, #28]
 810a414:	4401      	add	r1, r0
 810a416:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 810a41a:	4313      	orrs	r3, r2
 810a41c:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 810a41e:	69bb      	ldr	r3, [r7, #24]
 810a420:	015a      	lsls	r2, r3, #5
 810a422:	69fb      	ldr	r3, [r7, #28]
 810a424:	4413      	add	r3, r2
 810a426:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a42a:	691a      	ldr	r2, [r3, #16]
 810a42c:	68bb      	ldr	r3, [r7, #8]
 810a42e:	691b      	ldr	r3, [r3, #16]
 810a430:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810a434:	69b9      	ldr	r1, [r7, #24]
 810a436:	0148      	lsls	r0, r1, #5
 810a438:	69f9      	ldr	r1, [r7, #28]
 810a43a:	4401      	add	r1, r0
 810a43c:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 810a440:	4313      	orrs	r3, r2
 810a442:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 810a444:	79fb      	ldrb	r3, [r7, #7]
 810a446:	2b01      	cmp	r3, #1
 810a448:	d14b      	bne.n	810a4e2 <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 810a44a:	68bb      	ldr	r3, [r7, #8]
 810a44c:	69db      	ldr	r3, [r3, #28]
 810a44e:	2b00      	cmp	r3, #0
 810a450:	d009      	beq.n	810a466 <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 810a452:	69bb      	ldr	r3, [r7, #24]
 810a454:	015a      	lsls	r2, r3, #5
 810a456:	69fb      	ldr	r3, [r7, #28]
 810a458:	4413      	add	r3, r2
 810a45a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a45e:	461a      	mov	r2, r3
 810a460:	68bb      	ldr	r3, [r7, #8]
 810a462:	69db      	ldr	r3, [r3, #28]
 810a464:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 810a466:	68bb      	ldr	r3, [r7, #8]
 810a468:	791b      	ldrb	r3, [r3, #4]
 810a46a:	2b01      	cmp	r3, #1
 810a46c:	d128      	bne.n	810a4c0 <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810a46e:	69fb      	ldr	r3, [r7, #28]
 810a470:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a474:	689b      	ldr	r3, [r3, #8]
 810a476:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810a47a:	2b00      	cmp	r3, #0
 810a47c:	d110      	bne.n	810a4a0 <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 810a47e:	69bb      	ldr	r3, [r7, #24]
 810a480:	015a      	lsls	r2, r3, #5
 810a482:	69fb      	ldr	r3, [r7, #28]
 810a484:	4413      	add	r3, r2
 810a486:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a48a:	681b      	ldr	r3, [r3, #0]
 810a48c:	69ba      	ldr	r2, [r7, #24]
 810a48e:	0151      	lsls	r1, r2, #5
 810a490:	69fa      	ldr	r2, [r7, #28]
 810a492:	440a      	add	r2, r1
 810a494:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a498:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 810a49c:	6013      	str	r3, [r2, #0]
 810a49e:	e00f      	b.n	810a4c0 <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 810a4a0:	69bb      	ldr	r3, [r7, #24]
 810a4a2:	015a      	lsls	r2, r3, #5
 810a4a4:	69fb      	ldr	r3, [r7, #28]
 810a4a6:	4413      	add	r3, r2
 810a4a8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a4ac:	681b      	ldr	r3, [r3, #0]
 810a4ae:	69ba      	ldr	r2, [r7, #24]
 810a4b0:	0151      	lsls	r1, r2, #5
 810a4b2:	69fa      	ldr	r2, [r7, #28]
 810a4b4:	440a      	add	r2, r1
 810a4b6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a4ba:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810a4be:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 810a4c0:	69bb      	ldr	r3, [r7, #24]
 810a4c2:	015a      	lsls	r2, r3, #5
 810a4c4:	69fb      	ldr	r3, [r7, #28]
 810a4c6:	4413      	add	r3, r2
 810a4c8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a4cc:	681b      	ldr	r3, [r3, #0]
 810a4ce:	69ba      	ldr	r2, [r7, #24]
 810a4d0:	0151      	lsls	r1, r2, #5
 810a4d2:	69fa      	ldr	r2, [r7, #28]
 810a4d4:	440a      	add	r2, r1
 810a4d6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a4da:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 810a4de:	6013      	str	r3, [r2, #0]
 810a4e0:	e166      	b.n	810a7b0 <USB_EPStartXfer+0x52c>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 810a4e2:	69bb      	ldr	r3, [r7, #24]
 810a4e4:	015a      	lsls	r2, r3, #5
 810a4e6:	69fb      	ldr	r3, [r7, #28]
 810a4e8:	4413      	add	r3, r2
 810a4ea:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a4ee:	681b      	ldr	r3, [r3, #0]
 810a4f0:	69ba      	ldr	r2, [r7, #24]
 810a4f2:	0151      	lsls	r1, r2, #5
 810a4f4:	69fa      	ldr	r2, [r7, #28]
 810a4f6:	440a      	add	r2, r1
 810a4f8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a4fc:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 810a500:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 810a502:	68bb      	ldr	r3, [r7, #8]
 810a504:	791b      	ldrb	r3, [r3, #4]
 810a506:	2b01      	cmp	r3, #1
 810a508:	d015      	beq.n	810a536 <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 810a50a:	68bb      	ldr	r3, [r7, #8]
 810a50c:	691b      	ldr	r3, [r3, #16]
 810a50e:	2b00      	cmp	r3, #0
 810a510:	f000 814e 	beq.w	810a7b0 <USB_EPStartXfer+0x52c>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 810a514:	69fb      	ldr	r3, [r7, #28]
 810a516:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a51a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 810a51c:	68bb      	ldr	r3, [r7, #8]
 810a51e:	781b      	ldrb	r3, [r3, #0]
 810a520:	f003 030f 	and.w	r3, r3, #15
 810a524:	2101      	movs	r1, #1
 810a526:	fa01 f303 	lsl.w	r3, r1, r3
 810a52a:	69f9      	ldr	r1, [r7, #28]
 810a52c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810a530:	4313      	orrs	r3, r2
 810a532:	634b      	str	r3, [r1, #52]	@ 0x34
 810a534:	e13c      	b.n	810a7b0 <USB_EPStartXfer+0x52c>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810a536:	69fb      	ldr	r3, [r7, #28]
 810a538:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a53c:	689b      	ldr	r3, [r3, #8]
 810a53e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810a542:	2b00      	cmp	r3, #0
 810a544:	d110      	bne.n	810a568 <USB_EPStartXfer+0x2e4>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 810a546:	69bb      	ldr	r3, [r7, #24]
 810a548:	015a      	lsls	r2, r3, #5
 810a54a:	69fb      	ldr	r3, [r7, #28]
 810a54c:	4413      	add	r3, r2
 810a54e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a552:	681b      	ldr	r3, [r3, #0]
 810a554:	69ba      	ldr	r2, [r7, #24]
 810a556:	0151      	lsls	r1, r2, #5
 810a558:	69fa      	ldr	r2, [r7, #28]
 810a55a:	440a      	add	r2, r1
 810a55c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a560:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 810a564:	6013      	str	r3, [r2, #0]
 810a566:	e00f      	b.n	810a588 <USB_EPStartXfer+0x304>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 810a568:	69bb      	ldr	r3, [r7, #24]
 810a56a:	015a      	lsls	r2, r3, #5
 810a56c:	69fb      	ldr	r3, [r7, #28]
 810a56e:	4413      	add	r3, r2
 810a570:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a574:	681b      	ldr	r3, [r3, #0]
 810a576:	69ba      	ldr	r2, [r7, #24]
 810a578:	0151      	lsls	r1, r2, #5
 810a57a:	69fa      	ldr	r2, [r7, #28]
 810a57c:	440a      	add	r2, r1
 810a57e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a582:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810a586:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 810a588:	68bb      	ldr	r3, [r7, #8]
 810a58a:	68d9      	ldr	r1, [r3, #12]
 810a58c:	68bb      	ldr	r3, [r7, #8]
 810a58e:	781a      	ldrb	r2, [r3, #0]
 810a590:	68bb      	ldr	r3, [r7, #8]
 810a592:	691b      	ldr	r3, [r3, #16]
 810a594:	b298      	uxth	r0, r3
 810a596:	79fb      	ldrb	r3, [r7, #7]
 810a598:	9300      	str	r3, [sp, #0]
 810a59a:	4603      	mov	r3, r0
 810a59c:	68f8      	ldr	r0, [r7, #12]
 810a59e:	f000 f9b9 	bl	810a914 <USB_WritePacket>
 810a5a2:	e105      	b.n	810a7b0 <USB_EPStartXfer+0x52c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 810a5a4:	69bb      	ldr	r3, [r7, #24]
 810a5a6:	015a      	lsls	r2, r3, #5
 810a5a8:	69fb      	ldr	r3, [r7, #28]
 810a5aa:	4413      	add	r3, r2
 810a5ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a5b0:	691b      	ldr	r3, [r3, #16]
 810a5b2:	69ba      	ldr	r2, [r7, #24]
 810a5b4:	0151      	lsls	r1, r2, #5
 810a5b6:	69fa      	ldr	r2, [r7, #28]
 810a5b8:	440a      	add	r2, r1
 810a5ba:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a5be:	0cdb      	lsrs	r3, r3, #19
 810a5c0:	04db      	lsls	r3, r3, #19
 810a5c2:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 810a5c4:	69bb      	ldr	r3, [r7, #24]
 810a5c6:	015a      	lsls	r2, r3, #5
 810a5c8:	69fb      	ldr	r3, [r7, #28]
 810a5ca:	4413      	add	r3, r2
 810a5cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a5d0:	691b      	ldr	r3, [r3, #16]
 810a5d2:	69ba      	ldr	r2, [r7, #24]
 810a5d4:	0151      	lsls	r1, r2, #5
 810a5d6:	69fa      	ldr	r2, [r7, #28]
 810a5d8:	440a      	add	r2, r1
 810a5da:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a5de:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 810a5e2:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 810a5e6:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 810a5e8:	69bb      	ldr	r3, [r7, #24]
 810a5ea:	2b00      	cmp	r3, #0
 810a5ec:	d132      	bne.n	810a654 <USB_EPStartXfer+0x3d0>
    {
      if (ep->xfer_len > 0U)
 810a5ee:	68bb      	ldr	r3, [r7, #8]
 810a5f0:	691b      	ldr	r3, [r3, #16]
 810a5f2:	2b00      	cmp	r3, #0
 810a5f4:	d003      	beq.n	810a5fe <USB_EPStartXfer+0x37a>
      {
        ep->xfer_len = ep->maxpacket;
 810a5f6:	68bb      	ldr	r3, [r7, #8]
 810a5f8:	689a      	ldr	r2, [r3, #8]
 810a5fa:	68bb      	ldr	r3, [r7, #8]
 810a5fc:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 810a5fe:	68bb      	ldr	r3, [r7, #8]
 810a600:	689a      	ldr	r2, [r3, #8]
 810a602:	68bb      	ldr	r3, [r7, #8]
 810a604:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 810a606:	69bb      	ldr	r3, [r7, #24]
 810a608:	015a      	lsls	r2, r3, #5
 810a60a:	69fb      	ldr	r3, [r7, #28]
 810a60c:	4413      	add	r3, r2
 810a60e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a612:	691a      	ldr	r2, [r3, #16]
 810a614:	68bb      	ldr	r3, [r7, #8]
 810a616:	6a1b      	ldr	r3, [r3, #32]
 810a618:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810a61c:	69b9      	ldr	r1, [r7, #24]
 810a61e:	0148      	lsls	r0, r1, #5
 810a620:	69f9      	ldr	r1, [r7, #28]
 810a622:	4401      	add	r1, r0
 810a624:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 810a628:	4313      	orrs	r3, r2
 810a62a:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810a62c:	69bb      	ldr	r3, [r7, #24]
 810a62e:	015a      	lsls	r2, r3, #5
 810a630:	69fb      	ldr	r3, [r7, #28]
 810a632:	4413      	add	r3, r2
 810a634:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a638:	691b      	ldr	r3, [r3, #16]
 810a63a:	69ba      	ldr	r2, [r7, #24]
 810a63c:	0151      	lsls	r1, r2, #5
 810a63e:	69fa      	ldr	r2, [r7, #28]
 810a640:	440a      	add	r2, r1
 810a642:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a646:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810a64a:	6113      	str	r3, [r2, #16]
 810a64c:	e062      	b.n	810a714 <USB_EPStartXfer+0x490>
 810a64e:	bf00      	nop
 810a650:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 810a654:	68bb      	ldr	r3, [r7, #8]
 810a656:	691b      	ldr	r3, [r3, #16]
 810a658:	2b00      	cmp	r3, #0
 810a65a:	d123      	bne.n	810a6a4 <USB_EPStartXfer+0x420>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 810a65c:	69bb      	ldr	r3, [r7, #24]
 810a65e:	015a      	lsls	r2, r3, #5
 810a660:	69fb      	ldr	r3, [r7, #28]
 810a662:	4413      	add	r3, r2
 810a664:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a668:	691a      	ldr	r2, [r3, #16]
 810a66a:	68bb      	ldr	r3, [r7, #8]
 810a66c:	689b      	ldr	r3, [r3, #8]
 810a66e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810a672:	69b9      	ldr	r1, [r7, #24]
 810a674:	0148      	lsls	r0, r1, #5
 810a676:	69f9      	ldr	r1, [r7, #28]
 810a678:	4401      	add	r1, r0
 810a67a:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 810a67e:	4313      	orrs	r3, r2
 810a680:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810a682:	69bb      	ldr	r3, [r7, #24]
 810a684:	015a      	lsls	r2, r3, #5
 810a686:	69fb      	ldr	r3, [r7, #28]
 810a688:	4413      	add	r3, r2
 810a68a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a68e:	691b      	ldr	r3, [r3, #16]
 810a690:	69ba      	ldr	r2, [r7, #24]
 810a692:	0151      	lsls	r1, r2, #5
 810a694:	69fa      	ldr	r2, [r7, #28]
 810a696:	440a      	add	r2, r1
 810a698:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a69c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810a6a0:	6113      	str	r3, [r2, #16]
 810a6a2:	e037      	b.n	810a714 <USB_EPStartXfer+0x490>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 810a6a4:	68bb      	ldr	r3, [r7, #8]
 810a6a6:	691a      	ldr	r2, [r3, #16]
 810a6a8:	68bb      	ldr	r3, [r7, #8]
 810a6aa:	689b      	ldr	r3, [r3, #8]
 810a6ac:	4413      	add	r3, r2
 810a6ae:	1e5a      	subs	r2, r3, #1
 810a6b0:	68bb      	ldr	r3, [r7, #8]
 810a6b2:	689b      	ldr	r3, [r3, #8]
 810a6b4:	fbb2 f3f3 	udiv	r3, r2, r3
 810a6b8:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 810a6ba:	68bb      	ldr	r3, [r7, #8]
 810a6bc:	689b      	ldr	r3, [r3, #8]
 810a6be:	8afa      	ldrh	r2, [r7, #22]
 810a6c0:	fb03 f202 	mul.w	r2, r3, r2
 810a6c4:	68bb      	ldr	r3, [r7, #8]
 810a6c6:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 810a6c8:	69bb      	ldr	r3, [r7, #24]
 810a6ca:	015a      	lsls	r2, r3, #5
 810a6cc:	69fb      	ldr	r3, [r7, #28]
 810a6ce:	4413      	add	r3, r2
 810a6d0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a6d4:	691a      	ldr	r2, [r3, #16]
 810a6d6:	8afb      	ldrh	r3, [r7, #22]
 810a6d8:	04d9      	lsls	r1, r3, #19
 810a6da:	4b38      	ldr	r3, [pc, #224]	@ (810a7bc <USB_EPStartXfer+0x538>)
 810a6dc:	400b      	ands	r3, r1
 810a6de:	69b9      	ldr	r1, [r7, #24]
 810a6e0:	0148      	lsls	r0, r1, #5
 810a6e2:	69f9      	ldr	r1, [r7, #28]
 810a6e4:	4401      	add	r1, r0
 810a6e6:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 810a6ea:	4313      	orrs	r3, r2
 810a6ec:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 810a6ee:	69bb      	ldr	r3, [r7, #24]
 810a6f0:	015a      	lsls	r2, r3, #5
 810a6f2:	69fb      	ldr	r3, [r7, #28]
 810a6f4:	4413      	add	r3, r2
 810a6f6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a6fa:	691a      	ldr	r2, [r3, #16]
 810a6fc:	68bb      	ldr	r3, [r7, #8]
 810a6fe:	6a1b      	ldr	r3, [r3, #32]
 810a700:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810a704:	69b9      	ldr	r1, [r7, #24]
 810a706:	0148      	lsls	r0, r1, #5
 810a708:	69f9      	ldr	r1, [r7, #28]
 810a70a:	4401      	add	r1, r0
 810a70c:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 810a710:	4313      	orrs	r3, r2
 810a712:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 810a714:	79fb      	ldrb	r3, [r7, #7]
 810a716:	2b01      	cmp	r3, #1
 810a718:	d10d      	bne.n	810a736 <USB_EPStartXfer+0x4b2>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 810a71a:	68bb      	ldr	r3, [r7, #8]
 810a71c:	68db      	ldr	r3, [r3, #12]
 810a71e:	2b00      	cmp	r3, #0
 810a720:	d009      	beq.n	810a736 <USB_EPStartXfer+0x4b2>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 810a722:	68bb      	ldr	r3, [r7, #8]
 810a724:	68d9      	ldr	r1, [r3, #12]
 810a726:	69bb      	ldr	r3, [r7, #24]
 810a728:	015a      	lsls	r2, r3, #5
 810a72a:	69fb      	ldr	r3, [r7, #28]
 810a72c:	4413      	add	r3, r2
 810a72e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a732:	460a      	mov	r2, r1
 810a734:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 810a736:	68bb      	ldr	r3, [r7, #8]
 810a738:	791b      	ldrb	r3, [r3, #4]
 810a73a:	2b01      	cmp	r3, #1
 810a73c:	d128      	bne.n	810a790 <USB_EPStartXfer+0x50c>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810a73e:	69fb      	ldr	r3, [r7, #28]
 810a740:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810a744:	689b      	ldr	r3, [r3, #8]
 810a746:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810a74a:	2b00      	cmp	r3, #0
 810a74c:	d110      	bne.n	810a770 <USB_EPStartXfer+0x4ec>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 810a74e:	69bb      	ldr	r3, [r7, #24]
 810a750:	015a      	lsls	r2, r3, #5
 810a752:	69fb      	ldr	r3, [r7, #28]
 810a754:	4413      	add	r3, r2
 810a756:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a75a:	681b      	ldr	r3, [r3, #0]
 810a75c:	69ba      	ldr	r2, [r7, #24]
 810a75e:	0151      	lsls	r1, r2, #5
 810a760:	69fa      	ldr	r2, [r7, #28]
 810a762:	440a      	add	r2, r1
 810a764:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a768:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 810a76c:	6013      	str	r3, [r2, #0]
 810a76e:	e00f      	b.n	810a790 <USB_EPStartXfer+0x50c>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 810a770:	69bb      	ldr	r3, [r7, #24]
 810a772:	015a      	lsls	r2, r3, #5
 810a774:	69fb      	ldr	r3, [r7, #28]
 810a776:	4413      	add	r3, r2
 810a778:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a77c:	681b      	ldr	r3, [r3, #0]
 810a77e:	69ba      	ldr	r2, [r7, #24]
 810a780:	0151      	lsls	r1, r2, #5
 810a782:	69fa      	ldr	r2, [r7, #28]
 810a784:	440a      	add	r2, r1
 810a786:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a78a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810a78e:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 810a790:	69bb      	ldr	r3, [r7, #24]
 810a792:	015a      	lsls	r2, r3, #5
 810a794:	69fb      	ldr	r3, [r7, #28]
 810a796:	4413      	add	r3, r2
 810a798:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a79c:	681b      	ldr	r3, [r3, #0]
 810a79e:	69ba      	ldr	r2, [r7, #24]
 810a7a0:	0151      	lsls	r1, r2, #5
 810a7a2:	69fa      	ldr	r2, [r7, #28]
 810a7a4:	440a      	add	r2, r1
 810a7a6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a7aa:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 810a7ae:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810a7b0:	2300      	movs	r3, #0
}
 810a7b2:	4618      	mov	r0, r3
 810a7b4:	3720      	adds	r7, #32
 810a7b6:	46bd      	mov	sp, r7
 810a7b8:	bd80      	pop	{r7, pc}
 810a7ba:	bf00      	nop
 810a7bc:	1ff80000 	.word	0x1ff80000

0810a7c0 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 810a7c0:	b480      	push	{r7}
 810a7c2:	b087      	sub	sp, #28
 810a7c4:	af00      	add	r7, sp, #0
 810a7c6:	6078      	str	r0, [r7, #4]
 810a7c8:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 810a7ca:	2300      	movs	r3, #0
 810a7cc:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 810a7ce:	2300      	movs	r3, #0
 810a7d0:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810a7d2:	687b      	ldr	r3, [r7, #4]
 810a7d4:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 810a7d6:	683b      	ldr	r3, [r7, #0]
 810a7d8:	785b      	ldrb	r3, [r3, #1]
 810a7da:	2b01      	cmp	r3, #1
 810a7dc:	d14a      	bne.n	810a874 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 810a7de:	683b      	ldr	r3, [r7, #0]
 810a7e0:	781b      	ldrb	r3, [r3, #0]
 810a7e2:	015a      	lsls	r2, r3, #5
 810a7e4:	693b      	ldr	r3, [r7, #16]
 810a7e6:	4413      	add	r3, r2
 810a7e8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a7ec:	681b      	ldr	r3, [r3, #0]
 810a7ee:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a7f2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a7f6:	f040 8086 	bne.w	810a906 <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 810a7fa:	683b      	ldr	r3, [r7, #0]
 810a7fc:	781b      	ldrb	r3, [r3, #0]
 810a7fe:	015a      	lsls	r2, r3, #5
 810a800:	693b      	ldr	r3, [r7, #16]
 810a802:	4413      	add	r3, r2
 810a804:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a808:	681b      	ldr	r3, [r3, #0]
 810a80a:	683a      	ldr	r2, [r7, #0]
 810a80c:	7812      	ldrb	r2, [r2, #0]
 810a80e:	0151      	lsls	r1, r2, #5
 810a810:	693a      	ldr	r2, [r7, #16]
 810a812:	440a      	add	r2, r1
 810a814:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a818:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 810a81c:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 810a81e:	683b      	ldr	r3, [r7, #0]
 810a820:	781b      	ldrb	r3, [r3, #0]
 810a822:	015a      	lsls	r2, r3, #5
 810a824:	693b      	ldr	r3, [r7, #16]
 810a826:	4413      	add	r3, r2
 810a828:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a82c:	681b      	ldr	r3, [r3, #0]
 810a82e:	683a      	ldr	r2, [r7, #0]
 810a830:	7812      	ldrb	r2, [r2, #0]
 810a832:	0151      	lsls	r1, r2, #5
 810a834:	693a      	ldr	r2, [r7, #16]
 810a836:	440a      	add	r2, r1
 810a838:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810a83c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 810a840:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 810a842:	68fb      	ldr	r3, [r7, #12]
 810a844:	3301      	adds	r3, #1
 810a846:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 810a848:	68fb      	ldr	r3, [r7, #12]
 810a84a:	f242 7210 	movw	r2, #10000	@ 0x2710
 810a84e:	4293      	cmp	r3, r2
 810a850:	d902      	bls.n	810a858 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 810a852:	2301      	movs	r3, #1
 810a854:	75fb      	strb	r3, [r7, #23]
          break;
 810a856:	e056      	b.n	810a906 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 810a858:	683b      	ldr	r3, [r7, #0]
 810a85a:	781b      	ldrb	r3, [r3, #0]
 810a85c:	015a      	lsls	r2, r3, #5
 810a85e:	693b      	ldr	r3, [r7, #16]
 810a860:	4413      	add	r3, r2
 810a862:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810a866:	681b      	ldr	r3, [r3, #0]
 810a868:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a86c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a870:	d0e7      	beq.n	810a842 <USB_EPStopXfer+0x82>
 810a872:	e048      	b.n	810a906 <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810a874:	683b      	ldr	r3, [r7, #0]
 810a876:	781b      	ldrb	r3, [r3, #0]
 810a878:	015a      	lsls	r2, r3, #5
 810a87a:	693b      	ldr	r3, [r7, #16]
 810a87c:	4413      	add	r3, r2
 810a87e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a882:	681b      	ldr	r3, [r3, #0]
 810a884:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a888:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a88c:	d13b      	bne.n	810a906 <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 810a88e:	683b      	ldr	r3, [r7, #0]
 810a890:	781b      	ldrb	r3, [r3, #0]
 810a892:	015a      	lsls	r2, r3, #5
 810a894:	693b      	ldr	r3, [r7, #16]
 810a896:	4413      	add	r3, r2
 810a898:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a89c:	681b      	ldr	r3, [r3, #0]
 810a89e:	683a      	ldr	r2, [r7, #0]
 810a8a0:	7812      	ldrb	r2, [r2, #0]
 810a8a2:	0151      	lsls	r1, r2, #5
 810a8a4:	693a      	ldr	r2, [r7, #16]
 810a8a6:	440a      	add	r2, r1
 810a8a8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a8ac:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 810a8b0:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 810a8b2:	683b      	ldr	r3, [r7, #0]
 810a8b4:	781b      	ldrb	r3, [r3, #0]
 810a8b6:	015a      	lsls	r2, r3, #5
 810a8b8:	693b      	ldr	r3, [r7, #16]
 810a8ba:	4413      	add	r3, r2
 810a8bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a8c0:	681b      	ldr	r3, [r3, #0]
 810a8c2:	683a      	ldr	r2, [r7, #0]
 810a8c4:	7812      	ldrb	r2, [r2, #0]
 810a8c6:	0151      	lsls	r1, r2, #5
 810a8c8:	693a      	ldr	r2, [r7, #16]
 810a8ca:	440a      	add	r2, r1
 810a8cc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810a8d0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 810a8d4:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 810a8d6:	68fb      	ldr	r3, [r7, #12]
 810a8d8:	3301      	adds	r3, #1
 810a8da:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 810a8dc:	68fb      	ldr	r3, [r7, #12]
 810a8de:	f242 7210 	movw	r2, #10000	@ 0x2710
 810a8e2:	4293      	cmp	r3, r2
 810a8e4:	d902      	bls.n	810a8ec <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 810a8e6:	2301      	movs	r3, #1
 810a8e8:	75fb      	strb	r3, [r7, #23]
          break;
 810a8ea:	e00c      	b.n	810a906 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 810a8ec:	683b      	ldr	r3, [r7, #0]
 810a8ee:	781b      	ldrb	r3, [r3, #0]
 810a8f0:	015a      	lsls	r2, r3, #5
 810a8f2:	693b      	ldr	r3, [r7, #16]
 810a8f4:	4413      	add	r3, r2
 810a8f6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810a8fa:	681b      	ldr	r3, [r3, #0]
 810a8fc:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810a900:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810a904:	d0e7      	beq.n	810a8d6 <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 810a906:	7dfb      	ldrb	r3, [r7, #23]
}
 810a908:	4618      	mov	r0, r3
 810a90a:	371c      	adds	r7, #28
 810a90c:	46bd      	mov	sp, r7
 810a90e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a912:	4770      	bx	lr

0810a914 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 810a914:	b480      	push	{r7}
 810a916:	b089      	sub	sp, #36	@ 0x24
 810a918:	af00      	add	r7, sp, #0
 810a91a:	60f8      	str	r0, [r7, #12]
 810a91c:	60b9      	str	r1, [r7, #8]
 810a91e:	4611      	mov	r1, r2
 810a920:	461a      	mov	r2, r3
 810a922:	460b      	mov	r3, r1
 810a924:	71fb      	strb	r3, [r7, #7]
 810a926:	4613      	mov	r3, r2
 810a928:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810a92a:	68fb      	ldr	r3, [r7, #12]
 810a92c:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 810a92e:	68bb      	ldr	r3, [r7, #8]
 810a930:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 810a932:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 810a936:	2b00      	cmp	r3, #0
 810a938:	d123      	bne.n	810a982 <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 810a93a:	88bb      	ldrh	r3, [r7, #4]
 810a93c:	3303      	adds	r3, #3
 810a93e:	089b      	lsrs	r3, r3, #2
 810a940:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 810a942:	2300      	movs	r3, #0
 810a944:	61bb      	str	r3, [r7, #24]
 810a946:	e018      	b.n	810a97a <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 810a948:	79fb      	ldrb	r3, [r7, #7]
 810a94a:	031a      	lsls	r2, r3, #12
 810a94c:	697b      	ldr	r3, [r7, #20]
 810a94e:	4413      	add	r3, r2
 810a950:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 810a954:	461a      	mov	r2, r3
 810a956:	69fb      	ldr	r3, [r7, #28]
 810a958:	681b      	ldr	r3, [r3, #0]
 810a95a:	6013      	str	r3, [r2, #0]
      pSrc++;
 810a95c:	69fb      	ldr	r3, [r7, #28]
 810a95e:	3301      	adds	r3, #1
 810a960:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810a962:	69fb      	ldr	r3, [r7, #28]
 810a964:	3301      	adds	r3, #1
 810a966:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810a968:	69fb      	ldr	r3, [r7, #28]
 810a96a:	3301      	adds	r3, #1
 810a96c:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810a96e:	69fb      	ldr	r3, [r7, #28]
 810a970:	3301      	adds	r3, #1
 810a972:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 810a974:	69bb      	ldr	r3, [r7, #24]
 810a976:	3301      	adds	r3, #1
 810a978:	61bb      	str	r3, [r7, #24]
 810a97a:	69ba      	ldr	r2, [r7, #24]
 810a97c:	693b      	ldr	r3, [r7, #16]
 810a97e:	429a      	cmp	r2, r3
 810a980:	d3e2      	bcc.n	810a948 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 810a982:	2300      	movs	r3, #0
}
 810a984:	4618      	mov	r0, r3
 810a986:	3724      	adds	r7, #36	@ 0x24
 810a988:	46bd      	mov	sp, r7
 810a98a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a98e:	4770      	bx	lr

0810a990 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 810a990:	b480      	push	{r7}
 810a992:	b08b      	sub	sp, #44	@ 0x2c
 810a994:	af00      	add	r7, sp, #0
 810a996:	60f8      	str	r0, [r7, #12]
 810a998:	60b9      	str	r1, [r7, #8]
 810a99a:	4613      	mov	r3, r2
 810a99c:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810a99e:	68fb      	ldr	r3, [r7, #12]
 810a9a0:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 810a9a2:	68bb      	ldr	r3, [r7, #8]
 810a9a4:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 810a9a6:	88fb      	ldrh	r3, [r7, #6]
 810a9a8:	089b      	lsrs	r3, r3, #2
 810a9aa:	b29b      	uxth	r3, r3
 810a9ac:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 810a9ae:	88fb      	ldrh	r3, [r7, #6]
 810a9b0:	f003 0303 	and.w	r3, r3, #3
 810a9b4:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 810a9b6:	2300      	movs	r3, #0
 810a9b8:	623b      	str	r3, [r7, #32]
 810a9ba:	e014      	b.n	810a9e6 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 810a9bc:	69bb      	ldr	r3, [r7, #24]
 810a9be:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 810a9c2:	681a      	ldr	r2, [r3, #0]
 810a9c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a9c6:	601a      	str	r2, [r3, #0]
    pDest++;
 810a9c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a9ca:	3301      	adds	r3, #1
 810a9cc:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 810a9ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a9d0:	3301      	adds	r3, #1
 810a9d2:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 810a9d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a9d6:	3301      	adds	r3, #1
 810a9d8:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 810a9da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a9dc:	3301      	adds	r3, #1
 810a9de:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 810a9e0:	6a3b      	ldr	r3, [r7, #32]
 810a9e2:	3301      	adds	r3, #1
 810a9e4:	623b      	str	r3, [r7, #32]
 810a9e6:	6a3a      	ldr	r2, [r7, #32]
 810a9e8:	697b      	ldr	r3, [r7, #20]
 810a9ea:	429a      	cmp	r2, r3
 810a9ec:	d3e6      	bcc.n	810a9bc <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 810a9ee:	8bfb      	ldrh	r3, [r7, #30]
 810a9f0:	2b00      	cmp	r3, #0
 810a9f2:	d01e      	beq.n	810aa32 <USB_ReadPacket+0xa2>
  {
    i = 0U;
 810a9f4:	2300      	movs	r3, #0
 810a9f6:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 810a9f8:	69bb      	ldr	r3, [r7, #24]
 810a9fa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 810a9fe:	461a      	mov	r2, r3
 810aa00:	f107 0310 	add.w	r3, r7, #16
 810aa04:	6812      	ldr	r2, [r2, #0]
 810aa06:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 810aa08:	693a      	ldr	r2, [r7, #16]
 810aa0a:	6a3b      	ldr	r3, [r7, #32]
 810aa0c:	b2db      	uxtb	r3, r3
 810aa0e:	00db      	lsls	r3, r3, #3
 810aa10:	fa22 f303 	lsr.w	r3, r2, r3
 810aa14:	b2da      	uxtb	r2, r3
 810aa16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810aa18:	701a      	strb	r2, [r3, #0]
      i++;
 810aa1a:	6a3b      	ldr	r3, [r7, #32]
 810aa1c:	3301      	adds	r3, #1
 810aa1e:	623b      	str	r3, [r7, #32]
      pDest++;
 810aa20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810aa22:	3301      	adds	r3, #1
 810aa24:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 810aa26:	8bfb      	ldrh	r3, [r7, #30]
 810aa28:	3b01      	subs	r3, #1
 810aa2a:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 810aa2c:	8bfb      	ldrh	r3, [r7, #30]
 810aa2e:	2b00      	cmp	r3, #0
 810aa30:	d1ea      	bne.n	810aa08 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 810aa32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 810aa34:	4618      	mov	r0, r3
 810aa36:	372c      	adds	r7, #44	@ 0x2c
 810aa38:	46bd      	mov	sp, r7
 810aa3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810aa3e:	4770      	bx	lr

0810aa40 <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810aa40:	b480      	push	{r7}
 810aa42:	b085      	sub	sp, #20
 810aa44:	af00      	add	r7, sp, #0
 810aa46:	6078      	str	r0, [r7, #4]
 810aa48:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810aa4a:	687b      	ldr	r3, [r7, #4]
 810aa4c:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810aa4e:	683b      	ldr	r3, [r7, #0]
 810aa50:	781b      	ldrb	r3, [r3, #0]
 810aa52:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 810aa54:	683b      	ldr	r3, [r7, #0]
 810aa56:	785b      	ldrb	r3, [r3, #1]
 810aa58:	2b01      	cmp	r3, #1
 810aa5a:	d12c      	bne.n	810aab6 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 810aa5c:	68bb      	ldr	r3, [r7, #8]
 810aa5e:	015a      	lsls	r2, r3, #5
 810aa60:	68fb      	ldr	r3, [r7, #12]
 810aa62:	4413      	add	r3, r2
 810aa64:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810aa68:	681b      	ldr	r3, [r3, #0]
 810aa6a:	2b00      	cmp	r3, #0
 810aa6c:	db12      	blt.n	810aa94 <USB_EPSetStall+0x54>
 810aa6e:	68bb      	ldr	r3, [r7, #8]
 810aa70:	2b00      	cmp	r3, #0
 810aa72:	d00f      	beq.n	810aa94 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 810aa74:	68bb      	ldr	r3, [r7, #8]
 810aa76:	015a      	lsls	r2, r3, #5
 810aa78:	68fb      	ldr	r3, [r7, #12]
 810aa7a:	4413      	add	r3, r2
 810aa7c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810aa80:	681b      	ldr	r3, [r3, #0]
 810aa82:	68ba      	ldr	r2, [r7, #8]
 810aa84:	0151      	lsls	r1, r2, #5
 810aa86:	68fa      	ldr	r2, [r7, #12]
 810aa88:	440a      	add	r2, r1
 810aa8a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810aa8e:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 810aa92:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 810aa94:	68bb      	ldr	r3, [r7, #8]
 810aa96:	015a      	lsls	r2, r3, #5
 810aa98:	68fb      	ldr	r3, [r7, #12]
 810aa9a:	4413      	add	r3, r2
 810aa9c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810aaa0:	681b      	ldr	r3, [r3, #0]
 810aaa2:	68ba      	ldr	r2, [r7, #8]
 810aaa4:	0151      	lsls	r1, r2, #5
 810aaa6:	68fa      	ldr	r2, [r7, #12]
 810aaa8:	440a      	add	r2, r1
 810aaaa:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810aaae:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 810aab2:	6013      	str	r3, [r2, #0]
 810aab4:	e02b      	b.n	810ab0e <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 810aab6:	68bb      	ldr	r3, [r7, #8]
 810aab8:	015a      	lsls	r2, r3, #5
 810aaba:	68fb      	ldr	r3, [r7, #12]
 810aabc:	4413      	add	r3, r2
 810aabe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aac2:	681b      	ldr	r3, [r3, #0]
 810aac4:	2b00      	cmp	r3, #0
 810aac6:	db12      	blt.n	810aaee <USB_EPSetStall+0xae>
 810aac8:	68bb      	ldr	r3, [r7, #8]
 810aaca:	2b00      	cmp	r3, #0
 810aacc:	d00f      	beq.n	810aaee <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 810aace:	68bb      	ldr	r3, [r7, #8]
 810aad0:	015a      	lsls	r2, r3, #5
 810aad2:	68fb      	ldr	r3, [r7, #12]
 810aad4:	4413      	add	r3, r2
 810aad6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aada:	681b      	ldr	r3, [r3, #0]
 810aadc:	68ba      	ldr	r2, [r7, #8]
 810aade:	0151      	lsls	r1, r2, #5
 810aae0:	68fa      	ldr	r2, [r7, #12]
 810aae2:	440a      	add	r2, r1
 810aae4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810aae8:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 810aaec:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 810aaee:	68bb      	ldr	r3, [r7, #8]
 810aaf0:	015a      	lsls	r2, r3, #5
 810aaf2:	68fb      	ldr	r3, [r7, #12]
 810aaf4:	4413      	add	r3, r2
 810aaf6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aafa:	681b      	ldr	r3, [r3, #0]
 810aafc:	68ba      	ldr	r2, [r7, #8]
 810aafe:	0151      	lsls	r1, r2, #5
 810ab00:	68fa      	ldr	r2, [r7, #12]
 810ab02:	440a      	add	r2, r1
 810ab04:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810ab08:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 810ab0c:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810ab0e:	2300      	movs	r3, #0
}
 810ab10:	4618      	mov	r0, r3
 810ab12:	3714      	adds	r7, #20
 810ab14:	46bd      	mov	sp, r7
 810ab16:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ab1a:	4770      	bx	lr

0810ab1c <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810ab1c:	b480      	push	{r7}
 810ab1e:	b085      	sub	sp, #20
 810ab20:	af00      	add	r7, sp, #0
 810ab22:	6078      	str	r0, [r7, #4]
 810ab24:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ab26:	687b      	ldr	r3, [r7, #4]
 810ab28:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810ab2a:	683b      	ldr	r3, [r7, #0]
 810ab2c:	781b      	ldrb	r3, [r3, #0]
 810ab2e:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 810ab30:	683b      	ldr	r3, [r7, #0]
 810ab32:	785b      	ldrb	r3, [r3, #1]
 810ab34:	2b01      	cmp	r3, #1
 810ab36:	d128      	bne.n	810ab8a <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 810ab38:	68bb      	ldr	r3, [r7, #8]
 810ab3a:	015a      	lsls	r2, r3, #5
 810ab3c:	68fb      	ldr	r3, [r7, #12]
 810ab3e:	4413      	add	r3, r2
 810ab40:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810ab44:	681b      	ldr	r3, [r3, #0]
 810ab46:	68ba      	ldr	r2, [r7, #8]
 810ab48:	0151      	lsls	r1, r2, #5
 810ab4a:	68fa      	ldr	r2, [r7, #12]
 810ab4c:	440a      	add	r2, r1
 810ab4e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810ab52:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 810ab56:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 810ab58:	683b      	ldr	r3, [r7, #0]
 810ab5a:	791b      	ldrb	r3, [r3, #4]
 810ab5c:	2b03      	cmp	r3, #3
 810ab5e:	d003      	beq.n	810ab68 <USB_EPClearStall+0x4c>
 810ab60:	683b      	ldr	r3, [r7, #0]
 810ab62:	791b      	ldrb	r3, [r3, #4]
 810ab64:	2b02      	cmp	r3, #2
 810ab66:	d138      	bne.n	810abda <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 810ab68:	68bb      	ldr	r3, [r7, #8]
 810ab6a:	015a      	lsls	r2, r3, #5
 810ab6c:	68fb      	ldr	r3, [r7, #12]
 810ab6e:	4413      	add	r3, r2
 810ab70:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810ab74:	681b      	ldr	r3, [r3, #0]
 810ab76:	68ba      	ldr	r2, [r7, #8]
 810ab78:	0151      	lsls	r1, r2, #5
 810ab7a:	68fa      	ldr	r2, [r7, #12]
 810ab7c:	440a      	add	r2, r1
 810ab7e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810ab82:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810ab86:	6013      	str	r3, [r2, #0]
 810ab88:	e027      	b.n	810abda <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 810ab8a:	68bb      	ldr	r3, [r7, #8]
 810ab8c:	015a      	lsls	r2, r3, #5
 810ab8e:	68fb      	ldr	r3, [r7, #12]
 810ab90:	4413      	add	r3, r2
 810ab92:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810ab96:	681b      	ldr	r3, [r3, #0]
 810ab98:	68ba      	ldr	r2, [r7, #8]
 810ab9a:	0151      	lsls	r1, r2, #5
 810ab9c:	68fa      	ldr	r2, [r7, #12]
 810ab9e:	440a      	add	r2, r1
 810aba0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810aba4:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 810aba8:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 810abaa:	683b      	ldr	r3, [r7, #0]
 810abac:	791b      	ldrb	r3, [r3, #4]
 810abae:	2b03      	cmp	r3, #3
 810abb0:	d003      	beq.n	810abba <USB_EPClearStall+0x9e>
 810abb2:	683b      	ldr	r3, [r7, #0]
 810abb4:	791b      	ldrb	r3, [r3, #4]
 810abb6:	2b02      	cmp	r3, #2
 810abb8:	d10f      	bne.n	810abda <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 810abba:	68bb      	ldr	r3, [r7, #8]
 810abbc:	015a      	lsls	r2, r3, #5
 810abbe:	68fb      	ldr	r3, [r7, #12]
 810abc0:	4413      	add	r3, r2
 810abc2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810abc6:	681b      	ldr	r3, [r3, #0]
 810abc8:	68ba      	ldr	r2, [r7, #8]
 810abca:	0151      	lsls	r1, r2, #5
 810abcc:	68fa      	ldr	r2, [r7, #12]
 810abce:	440a      	add	r2, r1
 810abd0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810abd4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 810abd8:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 810abda:	2300      	movs	r3, #0
}
 810abdc:	4618      	mov	r0, r3
 810abde:	3714      	adds	r7, #20
 810abe0:	46bd      	mov	sp, r7
 810abe2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810abe6:	4770      	bx	lr

0810abe8 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 810abe8:	b480      	push	{r7}
 810abea:	b085      	sub	sp, #20
 810abec:	af00      	add	r7, sp, #0
 810abee:	6078      	str	r0, [r7, #4]
 810abf0:	460b      	mov	r3, r1
 810abf2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810abf4:	687b      	ldr	r3, [r7, #4]
 810abf6:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 810abf8:	68fb      	ldr	r3, [r7, #12]
 810abfa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810abfe:	681b      	ldr	r3, [r3, #0]
 810ac00:	68fa      	ldr	r2, [r7, #12]
 810ac02:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 810ac06:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 810ac0a:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 810ac0c:	68fb      	ldr	r3, [r7, #12]
 810ac0e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ac12:	681a      	ldr	r2, [r3, #0]
 810ac14:	78fb      	ldrb	r3, [r7, #3]
 810ac16:	011b      	lsls	r3, r3, #4
 810ac18:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 810ac1c:	68f9      	ldr	r1, [r7, #12]
 810ac1e:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 810ac22:	4313      	orrs	r3, r2
 810ac24:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 810ac26:	2300      	movs	r3, #0
}
 810ac28:	4618      	mov	r0, r3
 810ac2a:	3714      	adds	r7, #20
 810ac2c:	46bd      	mov	sp, r7
 810ac2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ac32:	4770      	bx	lr

0810ac34 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 810ac34:	b480      	push	{r7}
 810ac36:	b085      	sub	sp, #20
 810ac38:	af00      	add	r7, sp, #0
 810ac3a:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ac3c:	687b      	ldr	r3, [r7, #4]
 810ac3e:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 810ac40:	68fb      	ldr	r3, [r7, #12]
 810ac42:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 810ac46:	681b      	ldr	r3, [r3, #0]
 810ac48:	68fa      	ldr	r2, [r7, #12]
 810ac4a:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 810ac4e:	f023 0303 	bic.w	r3, r3, #3
 810ac52:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 810ac54:	68fb      	ldr	r3, [r7, #12]
 810ac56:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ac5a:	685b      	ldr	r3, [r3, #4]
 810ac5c:	68fa      	ldr	r2, [r7, #12]
 810ac5e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 810ac62:	f023 0302 	bic.w	r3, r3, #2
 810ac66:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810ac68:	2300      	movs	r3, #0
}
 810ac6a:	4618      	mov	r0, r3
 810ac6c:	3714      	adds	r7, #20
 810ac6e:	46bd      	mov	sp, r7
 810ac70:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ac74:	4770      	bx	lr

0810ac76 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 810ac76:	b480      	push	{r7}
 810ac78:	b085      	sub	sp, #20
 810ac7a:	af00      	add	r7, sp, #0
 810ac7c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ac7e:	687b      	ldr	r3, [r7, #4]
 810ac80:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 810ac82:	68fb      	ldr	r3, [r7, #12]
 810ac84:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 810ac88:	681b      	ldr	r3, [r3, #0]
 810ac8a:	68fa      	ldr	r2, [r7, #12]
 810ac8c:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 810ac90:	f023 0303 	bic.w	r3, r3, #3
 810ac94:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 810ac96:	68fb      	ldr	r3, [r7, #12]
 810ac98:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ac9c:	685b      	ldr	r3, [r3, #4]
 810ac9e:	68fa      	ldr	r2, [r7, #12]
 810aca0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 810aca4:	f043 0302 	orr.w	r3, r3, #2
 810aca8:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810acaa:	2300      	movs	r3, #0
}
 810acac:	4618      	mov	r0, r3
 810acae:	3714      	adds	r7, #20
 810acb0:	46bd      	mov	sp, r7
 810acb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810acb6:	4770      	bx	lr

0810acb8 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 810acb8:	b480      	push	{r7}
 810acba:	b085      	sub	sp, #20
 810acbc:	af00      	add	r7, sp, #0
 810acbe:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 810acc0:	687b      	ldr	r3, [r7, #4]
 810acc2:	695b      	ldr	r3, [r3, #20]
 810acc4:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 810acc6:	687b      	ldr	r3, [r7, #4]
 810acc8:	699b      	ldr	r3, [r3, #24]
 810acca:	68fa      	ldr	r2, [r7, #12]
 810accc:	4013      	ands	r3, r2
 810acce:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 810acd0:	68fb      	ldr	r3, [r7, #12]
}
 810acd2:	4618      	mov	r0, r3
 810acd4:	3714      	adds	r7, #20
 810acd6:	46bd      	mov	sp, r7
 810acd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810acdc:	4770      	bx	lr

0810acde <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 810acde:	b480      	push	{r7}
 810ace0:	b085      	sub	sp, #20
 810ace2:	af00      	add	r7, sp, #0
 810ace4:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ace6:	687b      	ldr	r3, [r7, #4]
 810ace8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 810acea:	68fb      	ldr	r3, [r7, #12]
 810acec:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810acf0:	699b      	ldr	r3, [r3, #24]
 810acf2:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 810acf4:	68fb      	ldr	r3, [r7, #12]
 810acf6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810acfa:	69db      	ldr	r3, [r3, #28]
 810acfc:	68ba      	ldr	r2, [r7, #8]
 810acfe:	4013      	ands	r3, r2
 810ad00:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 810ad02:	68bb      	ldr	r3, [r7, #8]
 810ad04:	0c1b      	lsrs	r3, r3, #16
}
 810ad06:	4618      	mov	r0, r3
 810ad08:	3714      	adds	r7, #20
 810ad0a:	46bd      	mov	sp, r7
 810ad0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ad10:	4770      	bx	lr

0810ad12 <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 810ad12:	b480      	push	{r7}
 810ad14:	b085      	sub	sp, #20
 810ad16:	af00      	add	r7, sp, #0
 810ad18:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ad1a:	687b      	ldr	r3, [r7, #4]
 810ad1c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 810ad1e:	68fb      	ldr	r3, [r7, #12]
 810ad20:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ad24:	699b      	ldr	r3, [r3, #24]
 810ad26:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 810ad28:	68fb      	ldr	r3, [r7, #12]
 810ad2a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ad2e:	69db      	ldr	r3, [r3, #28]
 810ad30:	68ba      	ldr	r2, [r7, #8]
 810ad32:	4013      	ands	r3, r2
 810ad34:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 810ad36:	68bb      	ldr	r3, [r7, #8]
 810ad38:	b29b      	uxth	r3, r3
}
 810ad3a:	4618      	mov	r0, r3
 810ad3c:	3714      	adds	r7, #20
 810ad3e:	46bd      	mov	sp, r7
 810ad40:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ad44:	4770      	bx	lr

0810ad46 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 810ad46:	b480      	push	{r7}
 810ad48:	b085      	sub	sp, #20
 810ad4a:	af00      	add	r7, sp, #0
 810ad4c:	6078      	str	r0, [r7, #4]
 810ad4e:	460b      	mov	r3, r1
 810ad50:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ad52:	687b      	ldr	r3, [r7, #4]
 810ad54:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 810ad56:	78fb      	ldrb	r3, [r7, #3]
 810ad58:	015a      	lsls	r2, r3, #5
 810ad5a:	68fb      	ldr	r3, [r7, #12]
 810ad5c:	4413      	add	r3, r2
 810ad5e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810ad62:	689b      	ldr	r3, [r3, #8]
 810ad64:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 810ad66:	68fb      	ldr	r3, [r7, #12]
 810ad68:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ad6c:	695b      	ldr	r3, [r3, #20]
 810ad6e:	68ba      	ldr	r2, [r7, #8]
 810ad70:	4013      	ands	r3, r2
 810ad72:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 810ad74:	68bb      	ldr	r3, [r7, #8]
}
 810ad76:	4618      	mov	r0, r3
 810ad78:	3714      	adds	r7, #20
 810ad7a:	46bd      	mov	sp, r7
 810ad7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ad80:	4770      	bx	lr

0810ad82 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 810ad82:	b480      	push	{r7}
 810ad84:	b087      	sub	sp, #28
 810ad86:	af00      	add	r7, sp, #0
 810ad88:	6078      	str	r0, [r7, #4]
 810ad8a:	460b      	mov	r3, r1
 810ad8c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ad8e:	687b      	ldr	r3, [r7, #4]
 810ad90:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 810ad92:	697b      	ldr	r3, [r7, #20]
 810ad94:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ad98:	691b      	ldr	r3, [r3, #16]
 810ad9a:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 810ad9c:	697b      	ldr	r3, [r7, #20]
 810ad9e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ada2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810ada4:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 810ada6:	78fb      	ldrb	r3, [r7, #3]
 810ada8:	f003 030f 	and.w	r3, r3, #15
 810adac:	68fa      	ldr	r2, [r7, #12]
 810adae:	fa22 f303 	lsr.w	r3, r2, r3
 810adb2:	01db      	lsls	r3, r3, #7
 810adb4:	b2db      	uxtb	r3, r3
 810adb6:	693a      	ldr	r2, [r7, #16]
 810adb8:	4313      	orrs	r3, r2
 810adba:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 810adbc:	78fb      	ldrb	r3, [r7, #3]
 810adbe:	015a      	lsls	r2, r3, #5
 810adc0:	697b      	ldr	r3, [r7, #20]
 810adc2:	4413      	add	r3, r2
 810adc4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810adc8:	689b      	ldr	r3, [r3, #8]
 810adca:	693a      	ldr	r2, [r7, #16]
 810adcc:	4013      	ands	r3, r2
 810adce:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 810add0:	68bb      	ldr	r3, [r7, #8]
}
 810add2:	4618      	mov	r0, r3
 810add4:	371c      	adds	r7, #28
 810add6:	46bd      	mov	sp, r7
 810add8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810addc:	4770      	bx	lr

0810adde <USB_GetMode>:
  *          This parameter can be one of these values:
  *           1 : Host
  *           0 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 810adde:	b480      	push	{r7}
 810ade0:	b083      	sub	sp, #12
 810ade2:	af00      	add	r7, sp, #0
 810ade4:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 810ade6:	687b      	ldr	r3, [r7, #4]
 810ade8:	695b      	ldr	r3, [r3, #20]
 810adea:	f003 0301 	and.w	r3, r3, #1
}
 810adee:	4618      	mov	r0, r3
 810adf0:	370c      	adds	r7, #12
 810adf2:	46bd      	mov	sp, r7
 810adf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810adf8:	4770      	bx	lr

0810adfa <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 810adfa:	b480      	push	{r7}
 810adfc:	b085      	sub	sp, #20
 810adfe:	af00      	add	r7, sp, #0
 810ae00:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ae02:	687b      	ldr	r3, [r7, #4]
 810ae04:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 810ae06:	68fb      	ldr	r3, [r7, #12]
 810ae08:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 810ae0c:	681b      	ldr	r3, [r3, #0]
 810ae0e:	68fa      	ldr	r2, [r7, #12]
 810ae10:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 810ae14:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 810ae18:	f023 0307 	bic.w	r3, r3, #7
 810ae1c:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 810ae1e:	68fb      	ldr	r3, [r7, #12]
 810ae20:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810ae24:	685b      	ldr	r3, [r3, #4]
 810ae26:	68fa      	ldr	r2, [r7, #12]
 810ae28:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 810ae2c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 810ae30:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810ae32:	2300      	movs	r3, #0
}
 810ae34:	4618      	mov	r0, r3
 810ae36:	3714      	adds	r7, #20
 810ae38:	46bd      	mov	sp, r7
 810ae3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ae3e:	4770      	bx	lr

0810ae40 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 810ae40:	b480      	push	{r7}
 810ae42:	b087      	sub	sp, #28
 810ae44:	af00      	add	r7, sp, #0
 810ae46:	60f8      	str	r0, [r7, #12]
 810ae48:	460b      	mov	r3, r1
 810ae4a:	607a      	str	r2, [r7, #4]
 810ae4c:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810ae4e:	68fb      	ldr	r3, [r7, #12]
 810ae50:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 810ae52:	68fb      	ldr	r3, [r7, #12]
 810ae54:	333c      	adds	r3, #60	@ 0x3c
 810ae56:	3304      	adds	r3, #4
 810ae58:	681b      	ldr	r3, [r3, #0]
 810ae5a:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 810ae5c:	693b      	ldr	r3, [r7, #16]
 810ae5e:	4a26      	ldr	r2, [pc, #152]	@ (810aef8 <USB_EP0_OutStart+0xb8>)
 810ae60:	4293      	cmp	r3, r2
 810ae62:	d90a      	bls.n	810ae7a <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810ae64:	697b      	ldr	r3, [r7, #20]
 810ae66:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810ae6a:	681b      	ldr	r3, [r3, #0]
 810ae6c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 810ae70:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 810ae74:	d101      	bne.n	810ae7a <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 810ae76:	2300      	movs	r3, #0
 810ae78:	e037      	b.n	810aeea <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 810ae7a:	697b      	ldr	r3, [r7, #20]
 810ae7c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810ae80:	461a      	mov	r2, r3
 810ae82:	2300      	movs	r3, #0
 810ae84:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810ae86:	697b      	ldr	r3, [r7, #20]
 810ae88:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810ae8c:	691b      	ldr	r3, [r3, #16]
 810ae8e:	697a      	ldr	r2, [r7, #20]
 810ae90:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810ae94:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 810ae98:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 810ae9a:	697b      	ldr	r3, [r7, #20]
 810ae9c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aea0:	691b      	ldr	r3, [r3, #16]
 810aea2:	697a      	ldr	r2, [r7, #20]
 810aea4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810aea8:	f043 0318 	orr.w	r3, r3, #24
 810aeac:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 810aeae:	697b      	ldr	r3, [r7, #20]
 810aeb0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aeb4:	691b      	ldr	r3, [r3, #16]
 810aeb6:	697a      	ldr	r2, [r7, #20]
 810aeb8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810aebc:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 810aec0:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 810aec2:	7afb      	ldrb	r3, [r7, #11]
 810aec4:	2b01      	cmp	r3, #1
 810aec6:	d10f      	bne.n	810aee8 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 810aec8:	697b      	ldr	r3, [r7, #20]
 810aeca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aece:	461a      	mov	r2, r3
 810aed0:	687b      	ldr	r3, [r7, #4]
 810aed2:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 810aed4:	697b      	ldr	r3, [r7, #20]
 810aed6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 810aeda:	681b      	ldr	r3, [r3, #0]
 810aedc:	697a      	ldr	r2, [r7, #20]
 810aede:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 810aee2:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 810aee6:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810aee8:	2300      	movs	r3, #0
}
 810aeea:	4618      	mov	r0, r3
 810aeec:	371c      	adds	r7, #28
 810aeee:	46bd      	mov	sp, r7
 810aef0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810aef4:	4770      	bx	lr
 810aef6:	bf00      	nop
 810aef8:	4f54300a 	.word	0x4f54300a

0810aefc <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 810aefc:	b480      	push	{r7}
 810aefe:	b085      	sub	sp, #20
 810af00:	af00      	add	r7, sp, #0
 810af02:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 810af04:	2300      	movs	r3, #0
 810af06:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 810af08:	68fb      	ldr	r3, [r7, #12]
 810af0a:	3301      	adds	r3, #1
 810af0c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810af0e:	68fb      	ldr	r3, [r7, #12]
 810af10:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 810af14:	d901      	bls.n	810af1a <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 810af16:	2303      	movs	r3, #3
 810af18:	e01b      	b.n	810af52 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 810af1a:	687b      	ldr	r3, [r7, #4]
 810af1c:	691b      	ldr	r3, [r3, #16]
 810af1e:	2b00      	cmp	r3, #0
 810af20:	daf2      	bge.n	810af08 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 810af22:	2300      	movs	r3, #0
 810af24:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 810af26:	687b      	ldr	r3, [r7, #4]
 810af28:	691b      	ldr	r3, [r3, #16]
 810af2a:	f043 0201 	orr.w	r2, r3, #1
 810af2e:	687b      	ldr	r3, [r7, #4]
 810af30:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 810af32:	68fb      	ldr	r3, [r7, #12]
 810af34:	3301      	adds	r3, #1
 810af36:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810af38:	68fb      	ldr	r3, [r7, #12]
 810af3a:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 810af3e:	d901      	bls.n	810af44 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 810af40:	2303      	movs	r3, #3
 810af42:	e006      	b.n	810af52 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 810af44:	687b      	ldr	r3, [r7, #4]
 810af46:	691b      	ldr	r3, [r3, #16]
 810af48:	f003 0301 	and.w	r3, r3, #1
 810af4c:	2b01      	cmp	r3, #1
 810af4e:	d0f0      	beq.n	810af32 <USB_CoreReset+0x36>

  return HAL_OK;
 810af50:	2300      	movs	r3, #0
}
 810af52:	4618      	mov	r0, r3
 810af54:	3714      	adds	r7, #20
 810af56:	46bd      	mov	sp, r7
 810af58:	f85d 7b04 	ldr.w	r7, [sp], #4
 810af5c:	4770      	bx	lr
	...

0810af60 <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810af60:	b580      	push	{r7, lr}
 810af62:	b084      	sub	sp, #16
 810af64:	af00      	add	r7, sp, #0
 810af66:	6078      	str	r0, [r7, #4]
 810af68:	460b      	mov	r3, r1
 810af6a:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 810af6c:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 810af70:	f002 fc98 	bl	810d8a4 <USBD_static_malloc>
 810af74:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 810af76:	68fb      	ldr	r3, [r7, #12]
 810af78:	2b00      	cmp	r3, #0
 810af7a:	d109      	bne.n	810af90 <USBD_CDC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 810af7c:	687b      	ldr	r3, [r7, #4]
 810af7e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810af82:	687b      	ldr	r3, [r7, #4]
 810af84:	32b0      	adds	r2, #176	@ 0xb0
 810af86:	2100      	movs	r1, #0
 810af88:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 810af8c:	2302      	movs	r3, #2
 810af8e:	e0d4      	b.n	810b13a <USBD_CDC_Init+0x1da>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 810af90:	f44f 7207 	mov.w	r2, #540	@ 0x21c
 810af94:	2100      	movs	r1, #0
 810af96:	68f8      	ldr	r0, [r7, #12]
 810af98:	f002 fcc8 	bl	810d92c <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 810af9c:	687b      	ldr	r3, [r7, #4]
 810af9e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810afa2:	687b      	ldr	r3, [r7, #4]
 810afa4:	32b0      	adds	r2, #176	@ 0xb0
 810afa6:	68f9      	ldr	r1, [r7, #12]
 810afa8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 810afac:	687b      	ldr	r3, [r7, #4]
 810afae:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810afb2:	687b      	ldr	r3, [r7, #4]
 810afb4:	32b0      	adds	r2, #176	@ 0xb0
 810afb6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 810afba:	687b      	ldr	r3, [r7, #4]
 810afbc:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 810afc0:	687b      	ldr	r3, [r7, #4]
 810afc2:	7c1b      	ldrb	r3, [r3, #16]
 810afc4:	2b00      	cmp	r3, #0
 810afc6:	d138      	bne.n	810b03a <USBD_CDC_Init+0xda>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 810afc8:	4b5e      	ldr	r3, [pc, #376]	@ (810b144 <USBD_CDC_Init+0x1e4>)
 810afca:	7819      	ldrb	r1, [r3, #0]
 810afcc:	f44f 7300 	mov.w	r3, #512	@ 0x200
 810afd0:	2202      	movs	r2, #2
 810afd2:	6878      	ldr	r0, [r7, #4]
 810afd4:	f002 fb43 	bl	810d65e <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 810afd8:	4b5a      	ldr	r3, [pc, #360]	@ (810b144 <USBD_CDC_Init+0x1e4>)
 810afda:	781b      	ldrb	r3, [r3, #0]
 810afdc:	f003 020f 	and.w	r2, r3, #15
 810afe0:	6879      	ldr	r1, [r7, #4]
 810afe2:	4613      	mov	r3, r2
 810afe4:	009b      	lsls	r3, r3, #2
 810afe6:	4413      	add	r3, r2
 810afe8:	009b      	lsls	r3, r3, #2
 810afea:	440b      	add	r3, r1
 810afec:	3324      	adds	r3, #36	@ 0x24
 810afee:	2201      	movs	r2, #1
 810aff0:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 810aff2:	4b55      	ldr	r3, [pc, #340]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810aff4:	7819      	ldrb	r1, [r3, #0]
 810aff6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 810affa:	2202      	movs	r2, #2
 810affc:	6878      	ldr	r0, [r7, #4]
 810affe:	f002 fb2e 	bl	810d65e <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 810b002:	4b51      	ldr	r3, [pc, #324]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810b004:	781b      	ldrb	r3, [r3, #0]
 810b006:	f003 020f 	and.w	r2, r3, #15
 810b00a:	6879      	ldr	r1, [r7, #4]
 810b00c:	4613      	mov	r3, r2
 810b00e:	009b      	lsls	r3, r3, #2
 810b010:	4413      	add	r3, r2
 810b012:	009b      	lsls	r3, r3, #2
 810b014:	440b      	add	r3, r1
 810b016:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 810b01a:	2201      	movs	r2, #1
 810b01c:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 810b01e:	4b4b      	ldr	r3, [pc, #300]	@ (810b14c <USBD_CDC_Init+0x1ec>)
 810b020:	781b      	ldrb	r3, [r3, #0]
 810b022:	f003 020f 	and.w	r2, r3, #15
 810b026:	6879      	ldr	r1, [r7, #4]
 810b028:	4613      	mov	r3, r2
 810b02a:	009b      	lsls	r3, r3, #2
 810b02c:	4413      	add	r3, r2
 810b02e:	009b      	lsls	r3, r3, #2
 810b030:	440b      	add	r3, r1
 810b032:	3326      	adds	r3, #38	@ 0x26
 810b034:	2210      	movs	r2, #16
 810b036:	801a      	strh	r2, [r3, #0]
 810b038:	e035      	b.n	810b0a6 <USBD_CDC_Init+0x146>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 810b03a:	4b42      	ldr	r3, [pc, #264]	@ (810b144 <USBD_CDC_Init+0x1e4>)
 810b03c:	7819      	ldrb	r1, [r3, #0]
 810b03e:	2340      	movs	r3, #64	@ 0x40
 810b040:	2202      	movs	r2, #2
 810b042:	6878      	ldr	r0, [r7, #4]
 810b044:	f002 fb0b 	bl	810d65e <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 810b048:	4b3e      	ldr	r3, [pc, #248]	@ (810b144 <USBD_CDC_Init+0x1e4>)
 810b04a:	781b      	ldrb	r3, [r3, #0]
 810b04c:	f003 020f 	and.w	r2, r3, #15
 810b050:	6879      	ldr	r1, [r7, #4]
 810b052:	4613      	mov	r3, r2
 810b054:	009b      	lsls	r3, r3, #2
 810b056:	4413      	add	r3, r2
 810b058:	009b      	lsls	r3, r3, #2
 810b05a:	440b      	add	r3, r1
 810b05c:	3324      	adds	r3, #36	@ 0x24
 810b05e:	2201      	movs	r2, #1
 810b060:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 810b062:	4b39      	ldr	r3, [pc, #228]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810b064:	7819      	ldrb	r1, [r3, #0]
 810b066:	2340      	movs	r3, #64	@ 0x40
 810b068:	2202      	movs	r2, #2
 810b06a:	6878      	ldr	r0, [r7, #4]
 810b06c:	f002 faf7 	bl	810d65e <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 810b070:	4b35      	ldr	r3, [pc, #212]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810b072:	781b      	ldrb	r3, [r3, #0]
 810b074:	f003 020f 	and.w	r2, r3, #15
 810b078:	6879      	ldr	r1, [r7, #4]
 810b07a:	4613      	mov	r3, r2
 810b07c:	009b      	lsls	r3, r3, #2
 810b07e:	4413      	add	r3, r2
 810b080:	009b      	lsls	r3, r3, #2
 810b082:	440b      	add	r3, r1
 810b084:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 810b088:	2201      	movs	r2, #1
 810b08a:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 810b08c:	4b2f      	ldr	r3, [pc, #188]	@ (810b14c <USBD_CDC_Init+0x1ec>)
 810b08e:	781b      	ldrb	r3, [r3, #0]
 810b090:	f003 020f 	and.w	r2, r3, #15
 810b094:	6879      	ldr	r1, [r7, #4]
 810b096:	4613      	mov	r3, r2
 810b098:	009b      	lsls	r3, r3, #2
 810b09a:	4413      	add	r3, r2
 810b09c:	009b      	lsls	r3, r3, #2
 810b09e:	440b      	add	r3, r1
 810b0a0:	3326      	adds	r3, #38	@ 0x26
 810b0a2:	2210      	movs	r2, #16
 810b0a4:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 810b0a6:	4b29      	ldr	r3, [pc, #164]	@ (810b14c <USBD_CDC_Init+0x1ec>)
 810b0a8:	7819      	ldrb	r1, [r3, #0]
 810b0aa:	2308      	movs	r3, #8
 810b0ac:	2203      	movs	r2, #3
 810b0ae:	6878      	ldr	r0, [r7, #4]
 810b0b0:	f002 fad5 	bl	810d65e <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 810b0b4:	4b25      	ldr	r3, [pc, #148]	@ (810b14c <USBD_CDC_Init+0x1ec>)
 810b0b6:	781b      	ldrb	r3, [r3, #0]
 810b0b8:	f003 020f 	and.w	r2, r3, #15
 810b0bc:	6879      	ldr	r1, [r7, #4]
 810b0be:	4613      	mov	r3, r2
 810b0c0:	009b      	lsls	r3, r3, #2
 810b0c2:	4413      	add	r3, r2
 810b0c4:	009b      	lsls	r3, r3, #2
 810b0c6:	440b      	add	r3, r1
 810b0c8:	3324      	adds	r3, #36	@ 0x24
 810b0ca:	2201      	movs	r2, #1
 810b0cc:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 810b0ce:	68fb      	ldr	r3, [r7, #12]
 810b0d0:	2200      	movs	r2, #0
 810b0d2:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 810b0d6:	687b      	ldr	r3, [r7, #4]
 810b0d8:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b0dc:	687a      	ldr	r2, [r7, #4]
 810b0de:	33b0      	adds	r3, #176	@ 0xb0
 810b0e0:	009b      	lsls	r3, r3, #2
 810b0e2:	4413      	add	r3, r2
 810b0e4:	685b      	ldr	r3, [r3, #4]
 810b0e6:	681b      	ldr	r3, [r3, #0]
 810b0e8:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 810b0ea:	68fb      	ldr	r3, [r7, #12]
 810b0ec:	2200      	movs	r2, #0
 810b0ee:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
  hcdc->RxState = 0U;
 810b0f2:	68fb      	ldr	r3, [r7, #12]
 810b0f4:	2200      	movs	r2, #0
 810b0f6:	f8c3 2218 	str.w	r2, [r3, #536]	@ 0x218

  if (hcdc->RxBuffer == NULL)
 810b0fa:	68fb      	ldr	r3, [r7, #12]
 810b0fc:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
 810b100:	2b00      	cmp	r3, #0
 810b102:	d101      	bne.n	810b108 <USBD_CDC_Init+0x1a8>
  {
    return (uint8_t)USBD_EMEM;
 810b104:	2302      	movs	r3, #2
 810b106:	e018      	b.n	810b13a <USBD_CDC_Init+0x1da>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 810b108:	687b      	ldr	r3, [r7, #4]
 810b10a:	7c1b      	ldrb	r3, [r3, #16]
 810b10c:	2b00      	cmp	r3, #0
 810b10e:	d10a      	bne.n	810b126 <USBD_CDC_Init+0x1c6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 810b110:	4b0d      	ldr	r3, [pc, #52]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810b112:	7819      	ldrb	r1, [r3, #0]
 810b114:	68fb      	ldr	r3, [r7, #12]
 810b116:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 810b11a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 810b11e:	6878      	ldr	r0, [r7, #4]
 810b120:	f002 fb8c 	bl	810d83c <USBD_LL_PrepareReceive>
 810b124:	e008      	b.n	810b138 <USBD_CDC_Init+0x1d8>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 810b126:	4b08      	ldr	r3, [pc, #32]	@ (810b148 <USBD_CDC_Init+0x1e8>)
 810b128:	7819      	ldrb	r1, [r3, #0]
 810b12a:	68fb      	ldr	r3, [r7, #12]
 810b12c:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 810b130:	2340      	movs	r3, #64	@ 0x40
 810b132:	6878      	ldr	r0, [r7, #4]
 810b134:	f002 fb82 	bl	810d83c <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 810b138:	2300      	movs	r3, #0
}
 810b13a:	4618      	mov	r0, r3
 810b13c:	3710      	adds	r7, #16
 810b13e:	46bd      	mov	sp, r7
 810b140:	bd80      	pop	{r7, pc}
 810b142:	bf00      	nop
 810b144:	100320bf 	.word	0x100320bf
 810b148:	100320c0 	.word	0x100320c0
 810b14c:	100320c1 	.word	0x100320c1

0810b150 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810b150:	b580      	push	{r7, lr}
 810b152:	b082      	sub	sp, #8
 810b154:	af00      	add	r7, sp, #0
 810b156:	6078      	str	r0, [r7, #4]
 810b158:	460b      	mov	r3, r1
 810b15a:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 810b15c:	4b3a      	ldr	r3, [pc, #232]	@ (810b248 <USBD_CDC_DeInit+0xf8>)
 810b15e:	781b      	ldrb	r3, [r3, #0]
 810b160:	4619      	mov	r1, r3
 810b162:	6878      	ldr	r0, [r7, #4]
 810b164:	f002 faa1 	bl	810d6aa <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 810b168:	4b37      	ldr	r3, [pc, #220]	@ (810b248 <USBD_CDC_DeInit+0xf8>)
 810b16a:	781b      	ldrb	r3, [r3, #0]
 810b16c:	f003 020f 	and.w	r2, r3, #15
 810b170:	6879      	ldr	r1, [r7, #4]
 810b172:	4613      	mov	r3, r2
 810b174:	009b      	lsls	r3, r3, #2
 810b176:	4413      	add	r3, r2
 810b178:	009b      	lsls	r3, r3, #2
 810b17a:	440b      	add	r3, r1
 810b17c:	3324      	adds	r3, #36	@ 0x24
 810b17e:	2200      	movs	r2, #0
 810b180:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 810b182:	4b32      	ldr	r3, [pc, #200]	@ (810b24c <USBD_CDC_DeInit+0xfc>)
 810b184:	781b      	ldrb	r3, [r3, #0]
 810b186:	4619      	mov	r1, r3
 810b188:	6878      	ldr	r0, [r7, #4]
 810b18a:	f002 fa8e 	bl	810d6aa <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 810b18e:	4b2f      	ldr	r3, [pc, #188]	@ (810b24c <USBD_CDC_DeInit+0xfc>)
 810b190:	781b      	ldrb	r3, [r3, #0]
 810b192:	f003 020f 	and.w	r2, r3, #15
 810b196:	6879      	ldr	r1, [r7, #4]
 810b198:	4613      	mov	r3, r2
 810b19a:	009b      	lsls	r3, r3, #2
 810b19c:	4413      	add	r3, r2
 810b19e:	009b      	lsls	r3, r3, #2
 810b1a0:	440b      	add	r3, r1
 810b1a2:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 810b1a6:	2200      	movs	r2, #0
 810b1a8:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 810b1aa:	4b29      	ldr	r3, [pc, #164]	@ (810b250 <USBD_CDC_DeInit+0x100>)
 810b1ac:	781b      	ldrb	r3, [r3, #0]
 810b1ae:	4619      	mov	r1, r3
 810b1b0:	6878      	ldr	r0, [r7, #4]
 810b1b2:	f002 fa7a 	bl	810d6aa <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 810b1b6:	4b26      	ldr	r3, [pc, #152]	@ (810b250 <USBD_CDC_DeInit+0x100>)
 810b1b8:	781b      	ldrb	r3, [r3, #0]
 810b1ba:	f003 020f 	and.w	r2, r3, #15
 810b1be:	6879      	ldr	r1, [r7, #4]
 810b1c0:	4613      	mov	r3, r2
 810b1c2:	009b      	lsls	r3, r3, #2
 810b1c4:	4413      	add	r3, r2
 810b1c6:	009b      	lsls	r3, r3, #2
 810b1c8:	440b      	add	r3, r1
 810b1ca:	3324      	adds	r3, #36	@ 0x24
 810b1cc:	2200      	movs	r2, #0
 810b1ce:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 810b1d0:	4b1f      	ldr	r3, [pc, #124]	@ (810b250 <USBD_CDC_DeInit+0x100>)
 810b1d2:	781b      	ldrb	r3, [r3, #0]
 810b1d4:	f003 020f 	and.w	r2, r3, #15
 810b1d8:	6879      	ldr	r1, [r7, #4]
 810b1da:	4613      	mov	r3, r2
 810b1dc:	009b      	lsls	r3, r3, #2
 810b1de:	4413      	add	r3, r2
 810b1e0:	009b      	lsls	r3, r3, #2
 810b1e2:	440b      	add	r3, r1
 810b1e4:	3326      	adds	r3, #38	@ 0x26
 810b1e6:	2200      	movs	r2, #0
 810b1e8:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 810b1ea:	687b      	ldr	r3, [r7, #4]
 810b1ec:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b1f0:	687b      	ldr	r3, [r7, #4]
 810b1f2:	32b0      	adds	r2, #176	@ 0xb0
 810b1f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b1f8:	2b00      	cmp	r3, #0
 810b1fa:	d01f      	beq.n	810b23c <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 810b1fc:	687b      	ldr	r3, [r7, #4]
 810b1fe:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b202:	687a      	ldr	r2, [r7, #4]
 810b204:	33b0      	adds	r3, #176	@ 0xb0
 810b206:	009b      	lsls	r3, r3, #2
 810b208:	4413      	add	r3, r2
 810b20a:	685b      	ldr	r3, [r3, #4]
 810b20c:	685b      	ldr	r3, [r3, #4]
 810b20e:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 810b210:	687b      	ldr	r3, [r7, #4]
 810b212:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b216:	687b      	ldr	r3, [r7, #4]
 810b218:	32b0      	adds	r2, #176	@ 0xb0
 810b21a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b21e:	4618      	mov	r0, r3
 810b220:	f002 fb4e 	bl	810d8c0 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 810b224:	687b      	ldr	r3, [r7, #4]
 810b226:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b22a:	687b      	ldr	r3, [r7, #4]
 810b22c:	32b0      	adds	r2, #176	@ 0xb0
 810b22e:	2100      	movs	r1, #0
 810b230:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 810b234:	687b      	ldr	r3, [r7, #4]
 810b236:	2200      	movs	r2, #0
 810b238:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 810b23c:	2300      	movs	r3, #0
}
 810b23e:	4618      	mov	r0, r3
 810b240:	3708      	adds	r7, #8
 810b242:	46bd      	mov	sp, r7
 810b244:	bd80      	pop	{r7, pc}
 810b246:	bf00      	nop
 810b248:	100320bf 	.word	0x100320bf
 810b24c:	100320c0 	.word	0x100320c0
 810b250:	100320c1 	.word	0x100320c1

0810b254 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 810b254:	b580      	push	{r7, lr}
 810b256:	b086      	sub	sp, #24
 810b258:	af00      	add	r7, sp, #0
 810b25a:	6078      	str	r0, [r7, #4]
 810b25c:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b25e:	687b      	ldr	r3, [r7, #4]
 810b260:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b264:	687b      	ldr	r3, [r7, #4]
 810b266:	32b0      	adds	r2, #176	@ 0xb0
 810b268:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b26c:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 810b26e:	2300      	movs	r3, #0
 810b270:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 810b272:	2300      	movs	r3, #0
 810b274:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 810b276:	2300      	movs	r3, #0
 810b278:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 810b27a:	693b      	ldr	r3, [r7, #16]
 810b27c:	2b00      	cmp	r3, #0
 810b27e:	d101      	bne.n	810b284 <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 810b280:	2303      	movs	r3, #3
 810b282:	e0bf      	b.n	810b404 <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810b284:	683b      	ldr	r3, [r7, #0]
 810b286:	781b      	ldrb	r3, [r3, #0]
 810b288:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 810b28c:	2b00      	cmp	r3, #0
 810b28e:	d050      	beq.n	810b332 <USBD_CDC_Setup+0xde>
 810b290:	2b20      	cmp	r3, #32
 810b292:	f040 80af 	bne.w	810b3f4 <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 810b296:	683b      	ldr	r3, [r7, #0]
 810b298:	88db      	ldrh	r3, [r3, #6]
 810b29a:	2b00      	cmp	r3, #0
 810b29c:	d03a      	beq.n	810b314 <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 810b29e:	683b      	ldr	r3, [r7, #0]
 810b2a0:	781b      	ldrb	r3, [r3, #0]
 810b2a2:	b25b      	sxtb	r3, r3
 810b2a4:	2b00      	cmp	r3, #0
 810b2a6:	da1b      	bge.n	810b2e0 <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 810b2a8:	687b      	ldr	r3, [r7, #4]
 810b2aa:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b2ae:	687a      	ldr	r2, [r7, #4]
 810b2b0:	33b0      	adds	r3, #176	@ 0xb0
 810b2b2:	009b      	lsls	r3, r3, #2
 810b2b4:	4413      	add	r3, r2
 810b2b6:	685b      	ldr	r3, [r3, #4]
 810b2b8:	689b      	ldr	r3, [r3, #8]
 810b2ba:	683a      	ldr	r2, [r7, #0]
 810b2bc:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 810b2be:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 810b2c0:	683a      	ldr	r2, [r7, #0]
 810b2c2:	88d2      	ldrh	r2, [r2, #6]
 810b2c4:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 810b2c6:	683b      	ldr	r3, [r7, #0]
 810b2c8:	88db      	ldrh	r3, [r3, #6]
 810b2ca:	2b07      	cmp	r3, #7
 810b2cc:	bf28      	it	cs
 810b2ce:	2307      	movcs	r3, #7
 810b2d0:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 810b2d2:	693b      	ldr	r3, [r7, #16]
 810b2d4:	89fa      	ldrh	r2, [r7, #14]
 810b2d6:	4619      	mov	r1, r3
 810b2d8:	6878      	ldr	r0, [r7, #4]
 810b2da:	f001 fd7d 	bl	810cdd8 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 810b2de:	e090      	b.n	810b402 <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 810b2e0:	683b      	ldr	r3, [r7, #0]
 810b2e2:	785a      	ldrb	r2, [r3, #1]
 810b2e4:	693b      	ldr	r3, [r7, #16]
 810b2e6:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 810b2ea:	683b      	ldr	r3, [r7, #0]
 810b2ec:	88db      	ldrh	r3, [r3, #6]
 810b2ee:	2b3f      	cmp	r3, #63	@ 0x3f
 810b2f0:	d803      	bhi.n	810b2fa <USBD_CDC_Setup+0xa6>
 810b2f2:	683b      	ldr	r3, [r7, #0]
 810b2f4:	88db      	ldrh	r3, [r3, #6]
 810b2f6:	b2da      	uxtb	r2, r3
 810b2f8:	e000      	b.n	810b2fc <USBD_CDC_Setup+0xa8>
 810b2fa:	2240      	movs	r2, #64	@ 0x40
 810b2fc:	693b      	ldr	r3, [r7, #16]
 810b2fe:	f883 2201 	strb.w	r2, [r3, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 810b302:	6939      	ldr	r1, [r7, #16]
 810b304:	693b      	ldr	r3, [r7, #16]
 810b306:	f893 3201 	ldrb.w	r3, [r3, #513]	@ 0x201
 810b30a:	461a      	mov	r2, r3
 810b30c:	6878      	ldr	r0, [r7, #4]
 810b30e:	f001 fd8f 	bl	810ce30 <USBD_CtlPrepareRx>
      break;
 810b312:	e076      	b.n	810b402 <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 810b314:	687b      	ldr	r3, [r7, #4]
 810b316:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b31a:	687a      	ldr	r2, [r7, #4]
 810b31c:	33b0      	adds	r3, #176	@ 0xb0
 810b31e:	009b      	lsls	r3, r3, #2
 810b320:	4413      	add	r3, r2
 810b322:	685b      	ldr	r3, [r3, #4]
 810b324:	689b      	ldr	r3, [r3, #8]
 810b326:	683a      	ldr	r2, [r7, #0]
 810b328:	7850      	ldrb	r0, [r2, #1]
 810b32a:	2200      	movs	r2, #0
 810b32c:	6839      	ldr	r1, [r7, #0]
 810b32e:	4798      	blx	r3
      break;
 810b330:	e067      	b.n	810b402 <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810b332:	683b      	ldr	r3, [r7, #0]
 810b334:	785b      	ldrb	r3, [r3, #1]
 810b336:	2b0b      	cmp	r3, #11
 810b338:	d851      	bhi.n	810b3de <USBD_CDC_Setup+0x18a>
 810b33a:	a201      	add	r2, pc, #4	@ (adr r2, 810b340 <USBD_CDC_Setup+0xec>)
 810b33c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810b340:	0810b371 	.word	0x0810b371
 810b344:	0810b3ed 	.word	0x0810b3ed
 810b348:	0810b3df 	.word	0x0810b3df
 810b34c:	0810b3df 	.word	0x0810b3df
 810b350:	0810b3df 	.word	0x0810b3df
 810b354:	0810b3df 	.word	0x0810b3df
 810b358:	0810b3df 	.word	0x0810b3df
 810b35c:	0810b3df 	.word	0x0810b3df
 810b360:	0810b3df 	.word	0x0810b3df
 810b364:	0810b3df 	.word	0x0810b3df
 810b368:	0810b39b 	.word	0x0810b39b
 810b36c:	0810b3c5 	.word	0x0810b3c5
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810b370:	687b      	ldr	r3, [r7, #4]
 810b372:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810b376:	b2db      	uxtb	r3, r3
 810b378:	2b03      	cmp	r3, #3
 810b37a:	d107      	bne.n	810b38c <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 810b37c:	f107 030a 	add.w	r3, r7, #10
 810b380:	2202      	movs	r2, #2
 810b382:	4619      	mov	r1, r3
 810b384:	6878      	ldr	r0, [r7, #4]
 810b386:	f001 fd27 	bl	810cdd8 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 810b38a:	e032      	b.n	810b3f2 <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 810b38c:	6839      	ldr	r1, [r7, #0]
 810b38e:	6878      	ldr	r0, [r7, #4]
 810b390:	f001 fca5 	bl	810ccde <USBD_CtlError>
            ret = USBD_FAIL;
 810b394:	2303      	movs	r3, #3
 810b396:	75fb      	strb	r3, [r7, #23]
          break;
 810b398:	e02b      	b.n	810b3f2 <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810b39a:	687b      	ldr	r3, [r7, #4]
 810b39c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810b3a0:	b2db      	uxtb	r3, r3
 810b3a2:	2b03      	cmp	r3, #3
 810b3a4:	d107      	bne.n	810b3b6 <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 810b3a6:	f107 030d 	add.w	r3, r7, #13
 810b3aa:	2201      	movs	r2, #1
 810b3ac:	4619      	mov	r1, r3
 810b3ae:	6878      	ldr	r0, [r7, #4]
 810b3b0:	f001 fd12 	bl	810cdd8 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 810b3b4:	e01d      	b.n	810b3f2 <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 810b3b6:	6839      	ldr	r1, [r7, #0]
 810b3b8:	6878      	ldr	r0, [r7, #4]
 810b3ba:	f001 fc90 	bl	810ccde <USBD_CtlError>
            ret = USBD_FAIL;
 810b3be:	2303      	movs	r3, #3
 810b3c0:	75fb      	strb	r3, [r7, #23]
          break;
 810b3c2:	e016      	b.n	810b3f2 <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 810b3c4:	687b      	ldr	r3, [r7, #4]
 810b3c6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810b3ca:	b2db      	uxtb	r3, r3
 810b3cc:	2b03      	cmp	r3, #3
 810b3ce:	d00f      	beq.n	810b3f0 <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 810b3d0:	6839      	ldr	r1, [r7, #0]
 810b3d2:	6878      	ldr	r0, [r7, #4]
 810b3d4:	f001 fc83 	bl	810ccde <USBD_CtlError>
            ret = USBD_FAIL;
 810b3d8:	2303      	movs	r3, #3
 810b3da:	75fb      	strb	r3, [r7, #23]
          }
          break;
 810b3dc:	e008      	b.n	810b3f0 <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 810b3de:	6839      	ldr	r1, [r7, #0]
 810b3e0:	6878      	ldr	r0, [r7, #4]
 810b3e2:	f001 fc7c 	bl	810ccde <USBD_CtlError>
          ret = USBD_FAIL;
 810b3e6:	2303      	movs	r3, #3
 810b3e8:	75fb      	strb	r3, [r7, #23]
          break;
 810b3ea:	e002      	b.n	810b3f2 <USBD_CDC_Setup+0x19e>
          break;
 810b3ec:	bf00      	nop
 810b3ee:	e008      	b.n	810b402 <USBD_CDC_Setup+0x1ae>
          break;
 810b3f0:	bf00      	nop
      }
      break;
 810b3f2:	e006      	b.n	810b402 <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 810b3f4:	6839      	ldr	r1, [r7, #0]
 810b3f6:	6878      	ldr	r0, [r7, #4]
 810b3f8:	f001 fc71 	bl	810ccde <USBD_CtlError>
      ret = USBD_FAIL;
 810b3fc:	2303      	movs	r3, #3
 810b3fe:	75fb      	strb	r3, [r7, #23]
      break;
 810b400:	bf00      	nop
  }

  return (uint8_t)ret;
 810b402:	7dfb      	ldrb	r3, [r7, #23]
}
 810b404:	4618      	mov	r0, r3
 810b406:	3718      	adds	r7, #24
 810b408:	46bd      	mov	sp, r7
 810b40a:	bd80      	pop	{r7, pc}

0810b40c <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 810b40c:	b580      	push	{r7, lr}
 810b40e:	b084      	sub	sp, #16
 810b410:	af00      	add	r7, sp, #0
 810b412:	6078      	str	r0, [r7, #4]
 810b414:	460b      	mov	r3, r1
 810b416:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 810b418:	687b      	ldr	r3, [r7, #4]
 810b41a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810b41e:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 810b420:	687b      	ldr	r3, [r7, #4]
 810b422:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b426:	687b      	ldr	r3, [r7, #4]
 810b428:	32b0      	adds	r2, #176	@ 0xb0
 810b42a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b42e:	2b00      	cmp	r3, #0
 810b430:	d101      	bne.n	810b436 <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 810b432:	2303      	movs	r3, #3
 810b434:	e065      	b.n	810b502 <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b436:	687b      	ldr	r3, [r7, #4]
 810b438:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b43c:	687b      	ldr	r3, [r7, #4]
 810b43e:	32b0      	adds	r2, #176	@ 0xb0
 810b440:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b444:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 810b446:	78fb      	ldrb	r3, [r7, #3]
 810b448:	f003 020f 	and.w	r2, r3, #15
 810b44c:	6879      	ldr	r1, [r7, #4]
 810b44e:	4613      	mov	r3, r2
 810b450:	009b      	lsls	r3, r3, #2
 810b452:	4413      	add	r3, r2
 810b454:	009b      	lsls	r3, r3, #2
 810b456:	440b      	add	r3, r1
 810b458:	3318      	adds	r3, #24
 810b45a:	681b      	ldr	r3, [r3, #0]
 810b45c:	2b00      	cmp	r3, #0
 810b45e:	d02f      	beq.n	810b4c0 <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 810b460:	78fb      	ldrb	r3, [r7, #3]
 810b462:	f003 020f 	and.w	r2, r3, #15
 810b466:	6879      	ldr	r1, [r7, #4]
 810b468:	4613      	mov	r3, r2
 810b46a:	009b      	lsls	r3, r3, #2
 810b46c:	4413      	add	r3, r2
 810b46e:	009b      	lsls	r3, r3, #2
 810b470:	440b      	add	r3, r1
 810b472:	3318      	adds	r3, #24
 810b474:	681a      	ldr	r2, [r3, #0]
 810b476:	78fb      	ldrb	r3, [r7, #3]
 810b478:	f003 010f 	and.w	r1, r3, #15
 810b47c:	68f8      	ldr	r0, [r7, #12]
 810b47e:	460b      	mov	r3, r1
 810b480:	00db      	lsls	r3, r3, #3
 810b482:	440b      	add	r3, r1
 810b484:	009b      	lsls	r3, r3, #2
 810b486:	4403      	add	r3, r0
 810b488:	331c      	adds	r3, #28
 810b48a:	681b      	ldr	r3, [r3, #0]
 810b48c:	fbb2 f1f3 	udiv	r1, r2, r3
 810b490:	fb01 f303 	mul.w	r3, r1, r3
 810b494:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 810b496:	2b00      	cmp	r3, #0
 810b498:	d112      	bne.n	810b4c0 <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 810b49a:	78fb      	ldrb	r3, [r7, #3]
 810b49c:	f003 020f 	and.w	r2, r3, #15
 810b4a0:	6879      	ldr	r1, [r7, #4]
 810b4a2:	4613      	mov	r3, r2
 810b4a4:	009b      	lsls	r3, r3, #2
 810b4a6:	4413      	add	r3, r2
 810b4a8:	009b      	lsls	r3, r3, #2
 810b4aa:	440b      	add	r3, r1
 810b4ac:	3318      	adds	r3, #24
 810b4ae:	2200      	movs	r2, #0
 810b4b0:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 810b4b2:	78f9      	ldrb	r1, [r7, #3]
 810b4b4:	2300      	movs	r3, #0
 810b4b6:	2200      	movs	r2, #0
 810b4b8:	6878      	ldr	r0, [r7, #4]
 810b4ba:	f002 f99e 	bl	810d7fa <USBD_LL_Transmit>
 810b4be:	e01f      	b.n	810b500 <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 810b4c0:	68bb      	ldr	r3, [r7, #8]
 810b4c2:	2200      	movs	r2, #0
 810b4c4:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 810b4c8:	687b      	ldr	r3, [r7, #4]
 810b4ca:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b4ce:	687a      	ldr	r2, [r7, #4]
 810b4d0:	33b0      	adds	r3, #176	@ 0xb0
 810b4d2:	009b      	lsls	r3, r3, #2
 810b4d4:	4413      	add	r3, r2
 810b4d6:	685b      	ldr	r3, [r3, #4]
 810b4d8:	691b      	ldr	r3, [r3, #16]
 810b4da:	2b00      	cmp	r3, #0
 810b4dc:	d010      	beq.n	810b500 <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 810b4de:	687b      	ldr	r3, [r7, #4]
 810b4e0:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b4e4:	687a      	ldr	r2, [r7, #4]
 810b4e6:	33b0      	adds	r3, #176	@ 0xb0
 810b4e8:	009b      	lsls	r3, r3, #2
 810b4ea:	4413      	add	r3, r2
 810b4ec:	685b      	ldr	r3, [r3, #4]
 810b4ee:	691b      	ldr	r3, [r3, #16]
 810b4f0:	68ba      	ldr	r2, [r7, #8]
 810b4f2:	f8d2 0208 	ldr.w	r0, [r2, #520]	@ 0x208
 810b4f6:	68ba      	ldr	r2, [r7, #8]
 810b4f8:	f502 7104 	add.w	r1, r2, #528	@ 0x210
 810b4fc:	78fa      	ldrb	r2, [r7, #3]
 810b4fe:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 810b500:	2300      	movs	r3, #0
}
 810b502:	4618      	mov	r0, r3
 810b504:	3710      	adds	r7, #16
 810b506:	46bd      	mov	sp, r7
 810b508:	bd80      	pop	{r7, pc}

0810b50a <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 810b50a:	b580      	push	{r7, lr}
 810b50c:	b084      	sub	sp, #16
 810b50e:	af00      	add	r7, sp, #0
 810b510:	6078      	str	r0, [r7, #4]
 810b512:	460b      	mov	r3, r1
 810b514:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b516:	687b      	ldr	r3, [r7, #4]
 810b518:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b51c:	687b      	ldr	r3, [r7, #4]
 810b51e:	32b0      	adds	r2, #176	@ 0xb0
 810b520:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b524:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 810b526:	687b      	ldr	r3, [r7, #4]
 810b528:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b52c:	687b      	ldr	r3, [r7, #4]
 810b52e:	32b0      	adds	r2, #176	@ 0xb0
 810b530:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b534:	2b00      	cmp	r3, #0
 810b536:	d101      	bne.n	810b53c <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 810b538:	2303      	movs	r3, #3
 810b53a:	e01a      	b.n	810b572 <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 810b53c:	78fb      	ldrb	r3, [r7, #3]
 810b53e:	4619      	mov	r1, r3
 810b540:	6878      	ldr	r0, [r7, #4]
 810b542:	f002 f99c 	bl	810d87e <USBD_LL_GetRxDataSize>
 810b546:	4602      	mov	r2, r0
 810b548:	68fb      	ldr	r3, [r7, #12]
 810b54a:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 810b54e:	687b      	ldr	r3, [r7, #4]
 810b550:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b554:	687a      	ldr	r2, [r7, #4]
 810b556:	33b0      	adds	r3, #176	@ 0xb0
 810b558:	009b      	lsls	r3, r3, #2
 810b55a:	4413      	add	r3, r2
 810b55c:	685b      	ldr	r3, [r3, #4]
 810b55e:	68db      	ldr	r3, [r3, #12]
 810b560:	68fa      	ldr	r2, [r7, #12]
 810b562:	f8d2 0204 	ldr.w	r0, [r2, #516]	@ 0x204
 810b566:	68fa      	ldr	r2, [r7, #12]
 810b568:	f502 7203 	add.w	r2, r2, #524	@ 0x20c
 810b56c:	4611      	mov	r1, r2
 810b56e:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 810b570:	2300      	movs	r3, #0
}
 810b572:	4618      	mov	r0, r3
 810b574:	3710      	adds	r7, #16
 810b576:	46bd      	mov	sp, r7
 810b578:	bd80      	pop	{r7, pc}

0810b57a <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 810b57a:	b580      	push	{r7, lr}
 810b57c:	b084      	sub	sp, #16
 810b57e:	af00      	add	r7, sp, #0
 810b580:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b582:	687b      	ldr	r3, [r7, #4]
 810b584:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b588:	687b      	ldr	r3, [r7, #4]
 810b58a:	32b0      	adds	r2, #176	@ 0xb0
 810b58c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b590:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 810b592:	68fb      	ldr	r3, [r7, #12]
 810b594:	2b00      	cmp	r3, #0
 810b596:	d101      	bne.n	810b59c <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 810b598:	2303      	movs	r3, #3
 810b59a:	e024      	b.n	810b5e6 <USBD_CDC_EP0_RxReady+0x6c>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 810b59c:	687b      	ldr	r3, [r7, #4]
 810b59e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b5a2:	687a      	ldr	r2, [r7, #4]
 810b5a4:	33b0      	adds	r3, #176	@ 0xb0
 810b5a6:	009b      	lsls	r3, r3, #2
 810b5a8:	4413      	add	r3, r2
 810b5aa:	685b      	ldr	r3, [r3, #4]
 810b5ac:	2b00      	cmp	r3, #0
 810b5ae:	d019      	beq.n	810b5e4 <USBD_CDC_EP0_RxReady+0x6a>
 810b5b0:	68fb      	ldr	r3, [r7, #12]
 810b5b2:	f893 3200 	ldrb.w	r3, [r3, #512]	@ 0x200
 810b5b6:	2bff      	cmp	r3, #255	@ 0xff
 810b5b8:	d014      	beq.n	810b5e4 <USBD_CDC_EP0_RxReady+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 810b5ba:	687b      	ldr	r3, [r7, #4]
 810b5bc:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b5c0:	687a      	ldr	r2, [r7, #4]
 810b5c2:	33b0      	adds	r3, #176	@ 0xb0
 810b5c4:	009b      	lsls	r3, r3, #2
 810b5c6:	4413      	add	r3, r2
 810b5c8:	685b      	ldr	r3, [r3, #4]
 810b5ca:	689b      	ldr	r3, [r3, #8]
 810b5cc:	68fa      	ldr	r2, [r7, #12]
 810b5ce:	f892 0200 	ldrb.w	r0, [r2, #512]	@ 0x200
                                                                     (uint8_t *)hcdc->data,
 810b5d2:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 810b5d4:	68fa      	ldr	r2, [r7, #12]
 810b5d6:	f892 2201 	ldrb.w	r2, [r2, #513]	@ 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 810b5da:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 810b5dc:	68fb      	ldr	r3, [r7, #12]
 810b5de:	22ff      	movs	r2, #255	@ 0xff
 810b5e0:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 810b5e4:	2300      	movs	r3, #0
}
 810b5e6:	4618      	mov	r0, r3
 810b5e8:	3710      	adds	r7, #16
 810b5ea:	46bd      	mov	sp, r7
 810b5ec:	bd80      	pop	{r7, pc}
	...

0810b5f0 <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 810b5f0:	b580      	push	{r7, lr}
 810b5f2:	b086      	sub	sp, #24
 810b5f4:	af00      	add	r7, sp, #0
 810b5f6:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 810b5f8:	2182      	movs	r1, #130	@ 0x82
 810b5fa:	4818      	ldr	r0, [pc, #96]	@ (810b65c <USBD_CDC_GetFSCfgDesc+0x6c>)
 810b5fc:	f000 fd0f 	bl	810c01e <USBD_GetEpDesc>
 810b600:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 810b602:	2101      	movs	r1, #1
 810b604:	4815      	ldr	r0, [pc, #84]	@ (810b65c <USBD_CDC_GetFSCfgDesc+0x6c>)
 810b606:	f000 fd0a 	bl	810c01e <USBD_GetEpDesc>
 810b60a:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 810b60c:	2181      	movs	r1, #129	@ 0x81
 810b60e:	4813      	ldr	r0, [pc, #76]	@ (810b65c <USBD_CDC_GetFSCfgDesc+0x6c>)
 810b610:	f000 fd05 	bl	810c01e <USBD_GetEpDesc>
 810b614:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 810b616:	697b      	ldr	r3, [r7, #20]
 810b618:	2b00      	cmp	r3, #0
 810b61a:	d002      	beq.n	810b622 <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 810b61c:	697b      	ldr	r3, [r7, #20]
 810b61e:	2210      	movs	r2, #16
 810b620:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 810b622:	693b      	ldr	r3, [r7, #16]
 810b624:	2b00      	cmp	r3, #0
 810b626:	d006      	beq.n	810b636 <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 810b628:	693b      	ldr	r3, [r7, #16]
 810b62a:	2200      	movs	r2, #0
 810b62c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 810b630:	711a      	strb	r2, [r3, #4]
 810b632:	2200      	movs	r2, #0
 810b634:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 810b636:	68fb      	ldr	r3, [r7, #12]
 810b638:	2b00      	cmp	r3, #0
 810b63a:	d006      	beq.n	810b64a <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 810b63c:	68fb      	ldr	r3, [r7, #12]
 810b63e:	2200      	movs	r2, #0
 810b640:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 810b644:	711a      	strb	r2, [r3, #4]
 810b646:	2200      	movs	r2, #0
 810b648:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 810b64a:	687b      	ldr	r3, [r7, #4]
 810b64c:	2243      	movs	r2, #67	@ 0x43
 810b64e:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 810b650:	4b02      	ldr	r3, [pc, #8]	@ (810b65c <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 810b652:	4618      	mov	r0, r3
 810b654:	3718      	adds	r7, #24
 810b656:	46bd      	mov	sp, r7
 810b658:	bd80      	pop	{r7, pc}
 810b65a:	bf00      	nop
 810b65c:	1003207c 	.word	0x1003207c

0810b660 <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 810b660:	b580      	push	{r7, lr}
 810b662:	b086      	sub	sp, #24
 810b664:	af00      	add	r7, sp, #0
 810b666:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 810b668:	2182      	movs	r1, #130	@ 0x82
 810b66a:	4818      	ldr	r0, [pc, #96]	@ (810b6cc <USBD_CDC_GetHSCfgDesc+0x6c>)
 810b66c:	f000 fcd7 	bl	810c01e <USBD_GetEpDesc>
 810b670:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 810b672:	2101      	movs	r1, #1
 810b674:	4815      	ldr	r0, [pc, #84]	@ (810b6cc <USBD_CDC_GetHSCfgDesc+0x6c>)
 810b676:	f000 fcd2 	bl	810c01e <USBD_GetEpDesc>
 810b67a:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 810b67c:	2181      	movs	r1, #129	@ 0x81
 810b67e:	4813      	ldr	r0, [pc, #76]	@ (810b6cc <USBD_CDC_GetHSCfgDesc+0x6c>)
 810b680:	f000 fccd 	bl	810c01e <USBD_GetEpDesc>
 810b684:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 810b686:	697b      	ldr	r3, [r7, #20]
 810b688:	2b00      	cmp	r3, #0
 810b68a:	d002      	beq.n	810b692 <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 810b68c:	697b      	ldr	r3, [r7, #20]
 810b68e:	2210      	movs	r2, #16
 810b690:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 810b692:	693b      	ldr	r3, [r7, #16]
 810b694:	2b00      	cmp	r3, #0
 810b696:	d006      	beq.n	810b6a6 <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 810b698:	693b      	ldr	r3, [r7, #16]
 810b69a:	2200      	movs	r2, #0
 810b69c:	711a      	strb	r2, [r3, #4]
 810b69e:	2200      	movs	r2, #0
 810b6a0:	f042 0202 	orr.w	r2, r2, #2
 810b6a4:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 810b6a6:	68fb      	ldr	r3, [r7, #12]
 810b6a8:	2b00      	cmp	r3, #0
 810b6aa:	d006      	beq.n	810b6ba <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 810b6ac:	68fb      	ldr	r3, [r7, #12]
 810b6ae:	2200      	movs	r2, #0
 810b6b0:	711a      	strb	r2, [r3, #4]
 810b6b2:	2200      	movs	r2, #0
 810b6b4:	f042 0202 	orr.w	r2, r2, #2
 810b6b8:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 810b6ba:	687b      	ldr	r3, [r7, #4]
 810b6bc:	2243      	movs	r2, #67	@ 0x43
 810b6be:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 810b6c0:	4b02      	ldr	r3, [pc, #8]	@ (810b6cc <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 810b6c2:	4618      	mov	r0, r3
 810b6c4:	3718      	adds	r7, #24
 810b6c6:	46bd      	mov	sp, r7
 810b6c8:	bd80      	pop	{r7, pc}
 810b6ca:	bf00      	nop
 810b6cc:	1003207c 	.word	0x1003207c

0810b6d0 <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 810b6d0:	b580      	push	{r7, lr}
 810b6d2:	b086      	sub	sp, #24
 810b6d4:	af00      	add	r7, sp, #0
 810b6d6:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 810b6d8:	2182      	movs	r1, #130	@ 0x82
 810b6da:	4818      	ldr	r0, [pc, #96]	@ (810b73c <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 810b6dc:	f000 fc9f 	bl	810c01e <USBD_GetEpDesc>
 810b6e0:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 810b6e2:	2101      	movs	r1, #1
 810b6e4:	4815      	ldr	r0, [pc, #84]	@ (810b73c <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 810b6e6:	f000 fc9a 	bl	810c01e <USBD_GetEpDesc>
 810b6ea:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 810b6ec:	2181      	movs	r1, #129	@ 0x81
 810b6ee:	4813      	ldr	r0, [pc, #76]	@ (810b73c <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 810b6f0:	f000 fc95 	bl	810c01e <USBD_GetEpDesc>
 810b6f4:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 810b6f6:	697b      	ldr	r3, [r7, #20]
 810b6f8:	2b00      	cmp	r3, #0
 810b6fa:	d002      	beq.n	810b702 <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 810b6fc:	697b      	ldr	r3, [r7, #20]
 810b6fe:	2210      	movs	r2, #16
 810b700:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 810b702:	693b      	ldr	r3, [r7, #16]
 810b704:	2b00      	cmp	r3, #0
 810b706:	d006      	beq.n	810b716 <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 810b708:	693b      	ldr	r3, [r7, #16]
 810b70a:	2200      	movs	r2, #0
 810b70c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 810b710:	711a      	strb	r2, [r3, #4]
 810b712:	2200      	movs	r2, #0
 810b714:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 810b716:	68fb      	ldr	r3, [r7, #12]
 810b718:	2b00      	cmp	r3, #0
 810b71a:	d006      	beq.n	810b72a <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 810b71c:	68fb      	ldr	r3, [r7, #12]
 810b71e:	2200      	movs	r2, #0
 810b720:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 810b724:	711a      	strb	r2, [r3, #4]
 810b726:	2200      	movs	r2, #0
 810b728:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 810b72a:	687b      	ldr	r3, [r7, #4]
 810b72c:	2243      	movs	r2, #67	@ 0x43
 810b72e:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 810b730:	4b02      	ldr	r3, [pc, #8]	@ (810b73c <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 810b732:	4618      	mov	r0, r3
 810b734:	3718      	adds	r7, #24
 810b736:	46bd      	mov	sp, r7
 810b738:	bd80      	pop	{r7, pc}
 810b73a:	bf00      	nop
 810b73c:	1003207c 	.word	0x1003207c

0810b740 <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 810b740:	b480      	push	{r7}
 810b742:	b083      	sub	sp, #12
 810b744:	af00      	add	r7, sp, #0
 810b746:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 810b748:	687b      	ldr	r3, [r7, #4]
 810b74a:	220a      	movs	r2, #10
 810b74c:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 810b74e:	4b03      	ldr	r3, [pc, #12]	@ (810b75c <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 810b750:	4618      	mov	r0, r3
 810b752:	370c      	adds	r7, #12
 810b754:	46bd      	mov	sp, r7
 810b756:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b75a:	4770      	bx	lr
 810b75c:	10032038 	.word	0x10032038

0810b760 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 810b760:	b480      	push	{r7}
 810b762:	b083      	sub	sp, #12
 810b764:	af00      	add	r7, sp, #0
 810b766:	6078      	str	r0, [r7, #4]
 810b768:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 810b76a:	683b      	ldr	r3, [r7, #0]
 810b76c:	2b00      	cmp	r3, #0
 810b76e:	d101      	bne.n	810b774 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 810b770:	2303      	movs	r3, #3
 810b772:	e009      	b.n	810b788 <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 810b774:	687b      	ldr	r3, [r7, #4]
 810b776:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 810b77a:	687a      	ldr	r2, [r7, #4]
 810b77c:	33b0      	adds	r3, #176	@ 0xb0
 810b77e:	009b      	lsls	r3, r3, #2
 810b780:	4413      	add	r3, r2
 810b782:	683a      	ldr	r2, [r7, #0]
 810b784:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 810b786:	2300      	movs	r3, #0
}
 810b788:	4618      	mov	r0, r3
 810b78a:	370c      	adds	r7, #12
 810b78c:	46bd      	mov	sp, r7
 810b78e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b792:	4770      	bx	lr

0810b794 <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 810b794:	b480      	push	{r7}
 810b796:	b087      	sub	sp, #28
 810b798:	af00      	add	r7, sp, #0
 810b79a:	60f8      	str	r0, [r7, #12]
 810b79c:	60b9      	str	r1, [r7, #8]
 810b79e:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b7a0:	68fb      	ldr	r3, [r7, #12]
 810b7a2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b7a6:	68fb      	ldr	r3, [r7, #12]
 810b7a8:	32b0      	adds	r2, #176	@ 0xb0
 810b7aa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b7ae:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 810b7b0:	697b      	ldr	r3, [r7, #20]
 810b7b2:	2b00      	cmp	r3, #0
 810b7b4:	d101      	bne.n	810b7ba <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 810b7b6:	2303      	movs	r3, #3
 810b7b8:	e008      	b.n	810b7cc <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 810b7ba:	697b      	ldr	r3, [r7, #20]
 810b7bc:	68ba      	ldr	r2, [r7, #8]
 810b7be:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 810b7c2:	697b      	ldr	r3, [r7, #20]
 810b7c4:	687a      	ldr	r2, [r7, #4]
 810b7c6:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210

  return (uint8_t)USBD_OK;
 810b7ca:	2300      	movs	r3, #0
}
 810b7cc:	4618      	mov	r0, r3
 810b7ce:	371c      	adds	r7, #28
 810b7d0:	46bd      	mov	sp, r7
 810b7d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b7d6:	4770      	bx	lr

0810b7d8 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 810b7d8:	b480      	push	{r7}
 810b7da:	b085      	sub	sp, #20
 810b7dc:	af00      	add	r7, sp, #0
 810b7de:	6078      	str	r0, [r7, #4]
 810b7e0:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b7e2:	687b      	ldr	r3, [r7, #4]
 810b7e4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b7e8:	687b      	ldr	r3, [r7, #4]
 810b7ea:	32b0      	adds	r2, #176	@ 0xb0
 810b7ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b7f0:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 810b7f2:	68fb      	ldr	r3, [r7, #12]
 810b7f4:	2b00      	cmp	r3, #0
 810b7f6:	d101      	bne.n	810b7fc <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 810b7f8:	2303      	movs	r3, #3
 810b7fa:	e004      	b.n	810b806 <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 810b7fc:	68fb      	ldr	r3, [r7, #12]
 810b7fe:	683a      	ldr	r2, [r7, #0]
 810b800:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  return (uint8_t)USBD_OK;
 810b804:	2300      	movs	r3, #0
}
 810b806:	4618      	mov	r0, r3
 810b808:	3714      	adds	r7, #20
 810b80a:	46bd      	mov	sp, r7
 810b80c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b810:	4770      	bx	lr
	...

0810b814 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 810b814:	b580      	push	{r7, lr}
 810b816:	b084      	sub	sp, #16
 810b818:	af00      	add	r7, sp, #0
 810b81a:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810b81c:	687b      	ldr	r3, [r7, #4]
 810b81e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b822:	687b      	ldr	r3, [r7, #4]
 810b824:	32b0      	adds	r2, #176	@ 0xb0
 810b826:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b82a:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 810b82c:	687b      	ldr	r3, [r7, #4]
 810b82e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b832:	687b      	ldr	r3, [r7, #4]
 810b834:	32b0      	adds	r2, #176	@ 0xb0
 810b836:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b83a:	2b00      	cmp	r3, #0
 810b83c:	d101      	bne.n	810b842 <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 810b83e:	2303      	movs	r3, #3
 810b840:	e018      	b.n	810b874 <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 810b842:	687b      	ldr	r3, [r7, #4]
 810b844:	7c1b      	ldrb	r3, [r3, #16]
 810b846:	2b00      	cmp	r3, #0
 810b848:	d10a      	bne.n	810b860 <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 810b84a:	4b0c      	ldr	r3, [pc, #48]	@ (810b87c <USBD_CDC_ReceivePacket+0x68>)
 810b84c:	7819      	ldrb	r1, [r3, #0]
 810b84e:	68fb      	ldr	r3, [r7, #12]
 810b850:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 810b854:	f44f 7300 	mov.w	r3, #512	@ 0x200
 810b858:	6878      	ldr	r0, [r7, #4]
 810b85a:	f001 ffef 	bl	810d83c <USBD_LL_PrepareReceive>
 810b85e:	e008      	b.n	810b872 <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 810b860:	4b06      	ldr	r3, [pc, #24]	@ (810b87c <USBD_CDC_ReceivePacket+0x68>)
 810b862:	7819      	ldrb	r1, [r3, #0]
 810b864:	68fb      	ldr	r3, [r7, #12]
 810b866:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 810b86a:	2340      	movs	r3, #64	@ 0x40
 810b86c:	6878      	ldr	r0, [r7, #4]
 810b86e:	f001 ffe5 	bl	810d83c <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 810b872:	2300      	movs	r3, #0
}
 810b874:	4618      	mov	r0, r3
 810b876:	3710      	adds	r7, #16
 810b878:	46bd      	mov	sp, r7
 810b87a:	bd80      	pop	{r7, pc}
 810b87c:	100320c0 	.word	0x100320c0

0810b880 <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 810b880:	b580      	push	{r7, lr}
 810b882:	b086      	sub	sp, #24
 810b884:	af00      	add	r7, sp, #0
 810b886:	60f8      	str	r0, [r7, #12]
 810b888:	60b9      	str	r1, [r7, #8]
 810b88a:	4613      	mov	r3, r2
 810b88c:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 810b88e:	68fb      	ldr	r3, [r7, #12]
 810b890:	2b00      	cmp	r3, #0
 810b892:	d101      	bne.n	810b898 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 810b894:	2303      	movs	r3, #3
 810b896:	e01f      	b.n	810b8d8 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 810b898:	68fb      	ldr	r3, [r7, #12]
 810b89a:	2200      	movs	r2, #0
 810b89c:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 810b8a0:	68fb      	ldr	r3, [r7, #12]
 810b8a2:	2200      	movs	r2, #0
 810b8a4:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 810b8a8:	68fb      	ldr	r3, [r7, #12]
 810b8aa:	2200      	movs	r2, #0
 810b8ac:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 810b8b0:	68bb      	ldr	r3, [r7, #8]
 810b8b2:	2b00      	cmp	r3, #0
 810b8b4:	d003      	beq.n	810b8be <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 810b8b6:	68fb      	ldr	r3, [r7, #12]
 810b8b8:	68ba      	ldr	r2, [r7, #8]
 810b8ba:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810b8be:	68fb      	ldr	r3, [r7, #12]
 810b8c0:	2201      	movs	r2, #1
 810b8c2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 810b8c6:	68fb      	ldr	r3, [r7, #12]
 810b8c8:	79fa      	ldrb	r2, [r7, #7]
 810b8ca:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 810b8cc:	68f8      	ldr	r0, [r7, #12]
 810b8ce:	f001 fe5b 	bl	810d588 <USBD_LL_Init>
 810b8d2:	4603      	mov	r3, r0
 810b8d4:	75fb      	strb	r3, [r7, #23]

  return ret;
 810b8d6:	7dfb      	ldrb	r3, [r7, #23]
}
 810b8d8:	4618      	mov	r0, r3
 810b8da:	3718      	adds	r7, #24
 810b8dc:	46bd      	mov	sp, r7
 810b8de:	bd80      	pop	{r7, pc}

0810b8e0 <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 810b8e0:	b580      	push	{r7, lr}
 810b8e2:	b084      	sub	sp, #16
 810b8e4:	af00      	add	r7, sp, #0
 810b8e6:	6078      	str	r0, [r7, #4]
 810b8e8:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 810b8ea:	2300      	movs	r3, #0
 810b8ec:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 810b8ee:	683b      	ldr	r3, [r7, #0]
 810b8f0:	2b00      	cmp	r3, #0
 810b8f2:	d101      	bne.n	810b8f8 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 810b8f4:	2303      	movs	r3, #3
 810b8f6:	e025      	b.n	810b944 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 810b8f8:	687b      	ldr	r3, [r7, #4]
 810b8fa:	683a      	ldr	r2, [r7, #0]
 810b8fc:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 810b900:	687b      	ldr	r3, [r7, #4]
 810b902:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b906:	687b      	ldr	r3, [r7, #4]
 810b908:	32ae      	adds	r2, #174	@ 0xae
 810b90a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b90e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810b910:	2b00      	cmp	r3, #0
 810b912:	d00f      	beq.n	810b934 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 810b914:	687b      	ldr	r3, [r7, #4]
 810b916:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810b91a:	687b      	ldr	r3, [r7, #4]
 810b91c:	32ae      	adds	r2, #174	@ 0xae
 810b91e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810b922:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810b924:	f107 020e 	add.w	r2, r7, #14
 810b928:	4610      	mov	r0, r2
 810b92a:	4798      	blx	r3
 810b92c:	4602      	mov	r2, r0
 810b92e:	687b      	ldr	r3, [r7, #4]
 810b930:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 810b934:	687b      	ldr	r3, [r7, #4]
 810b936:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 810b93a:	1c5a      	adds	r2, r3, #1
 810b93c:	687b      	ldr	r3, [r7, #4]
 810b93e:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 810b942:	2300      	movs	r3, #0
}
 810b944:	4618      	mov	r0, r3
 810b946:	3710      	adds	r7, #16
 810b948:	46bd      	mov	sp, r7
 810b94a:	bd80      	pop	{r7, pc}

0810b94c <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 810b94c:	b580      	push	{r7, lr}
 810b94e:	b082      	sub	sp, #8
 810b950:	af00      	add	r7, sp, #0
 810b952:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 810b954:	6878      	ldr	r0, [r7, #4]
 810b956:	f001 fe67 	bl	810d628 <USBD_LL_Start>
 810b95a:	4603      	mov	r3, r0
}
 810b95c:	4618      	mov	r0, r3
 810b95e:	3708      	adds	r7, #8
 810b960:	46bd      	mov	sp, r7
 810b962:	bd80      	pop	{r7, pc}

0810b964 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 810b964:	b480      	push	{r7}
 810b966:	b083      	sub	sp, #12
 810b968:	af00      	add	r7, sp, #0
 810b96a:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 810b96c:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 810b96e:	4618      	mov	r0, r3
 810b970:	370c      	adds	r7, #12
 810b972:	46bd      	mov	sp, r7
 810b974:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b978:	4770      	bx	lr

0810b97a <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810b97a:	b580      	push	{r7, lr}
 810b97c:	b084      	sub	sp, #16
 810b97e:	af00      	add	r7, sp, #0
 810b980:	6078      	str	r0, [r7, #4]
 810b982:	460b      	mov	r3, r1
 810b984:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 810b986:	2300      	movs	r3, #0
 810b988:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 810b98a:	687b      	ldr	r3, [r7, #4]
 810b98c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810b990:	2b00      	cmp	r3, #0
 810b992:	d009      	beq.n	810b9a8 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 810b994:	687b      	ldr	r3, [r7, #4]
 810b996:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810b99a:	681b      	ldr	r3, [r3, #0]
 810b99c:	78fa      	ldrb	r2, [r7, #3]
 810b99e:	4611      	mov	r1, r2
 810b9a0:	6878      	ldr	r0, [r7, #4]
 810b9a2:	4798      	blx	r3
 810b9a4:	4603      	mov	r3, r0
 810b9a6:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810b9a8:	7bfb      	ldrb	r3, [r7, #15]
}
 810b9aa:	4618      	mov	r0, r3
 810b9ac:	3710      	adds	r7, #16
 810b9ae:	46bd      	mov	sp, r7
 810b9b0:	bd80      	pop	{r7, pc}

0810b9b2 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810b9b2:	b580      	push	{r7, lr}
 810b9b4:	b084      	sub	sp, #16
 810b9b6:	af00      	add	r7, sp, #0
 810b9b8:	6078      	str	r0, [r7, #4]
 810b9ba:	460b      	mov	r3, r1
 810b9bc:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 810b9be:	2300      	movs	r3, #0
 810b9c0:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 810b9c2:	687b      	ldr	r3, [r7, #4]
 810b9c4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810b9c8:	685b      	ldr	r3, [r3, #4]
 810b9ca:	78fa      	ldrb	r2, [r7, #3]
 810b9cc:	4611      	mov	r1, r2
 810b9ce:	6878      	ldr	r0, [r7, #4]
 810b9d0:	4798      	blx	r3
 810b9d2:	4603      	mov	r3, r0
 810b9d4:	2b00      	cmp	r3, #0
 810b9d6:	d001      	beq.n	810b9dc <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 810b9d8:	2303      	movs	r3, #3
 810b9da:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810b9dc:	7bfb      	ldrb	r3, [r7, #15]
}
 810b9de:	4618      	mov	r0, r3
 810b9e0:	3710      	adds	r7, #16
 810b9e2:	46bd      	mov	sp, r7
 810b9e4:	bd80      	pop	{r7, pc}

0810b9e6 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 810b9e6:	b580      	push	{r7, lr}
 810b9e8:	b084      	sub	sp, #16
 810b9ea:	af00      	add	r7, sp, #0
 810b9ec:	6078      	str	r0, [r7, #4]
 810b9ee:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 810b9f0:	687b      	ldr	r3, [r7, #4]
 810b9f2:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 810b9f6:	6839      	ldr	r1, [r7, #0]
 810b9f8:	4618      	mov	r0, r3
 810b9fa:	f001 f936 	bl	810cc6a <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 810b9fe:	687b      	ldr	r3, [r7, #4]
 810ba00:	2201      	movs	r2, #1
 810ba02:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 810ba06:	687b      	ldr	r3, [r7, #4]
 810ba08:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 810ba0c:	461a      	mov	r2, r3
 810ba0e:	687b      	ldr	r3, [r7, #4]
 810ba10:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 810ba14:	687b      	ldr	r3, [r7, #4]
 810ba16:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 810ba1a:	f003 031f 	and.w	r3, r3, #31
 810ba1e:	2b02      	cmp	r3, #2
 810ba20:	d01a      	beq.n	810ba58 <USBD_LL_SetupStage+0x72>
 810ba22:	2b02      	cmp	r3, #2
 810ba24:	d822      	bhi.n	810ba6c <USBD_LL_SetupStage+0x86>
 810ba26:	2b00      	cmp	r3, #0
 810ba28:	d002      	beq.n	810ba30 <USBD_LL_SetupStage+0x4a>
 810ba2a:	2b01      	cmp	r3, #1
 810ba2c:	d00a      	beq.n	810ba44 <USBD_LL_SetupStage+0x5e>
 810ba2e:	e01d      	b.n	810ba6c <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 810ba30:	687b      	ldr	r3, [r7, #4]
 810ba32:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 810ba36:	4619      	mov	r1, r3
 810ba38:	6878      	ldr	r0, [r7, #4]
 810ba3a:	f000 fb63 	bl	810c104 <USBD_StdDevReq>
 810ba3e:	4603      	mov	r3, r0
 810ba40:	73fb      	strb	r3, [r7, #15]
      break;
 810ba42:	e020      	b.n	810ba86 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 810ba44:	687b      	ldr	r3, [r7, #4]
 810ba46:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 810ba4a:	4619      	mov	r1, r3
 810ba4c:	6878      	ldr	r0, [r7, #4]
 810ba4e:	f000 fbcb 	bl	810c1e8 <USBD_StdItfReq>
 810ba52:	4603      	mov	r3, r0
 810ba54:	73fb      	strb	r3, [r7, #15]
      break;
 810ba56:	e016      	b.n	810ba86 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 810ba58:	687b      	ldr	r3, [r7, #4]
 810ba5a:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 810ba5e:	4619      	mov	r1, r3
 810ba60:	6878      	ldr	r0, [r7, #4]
 810ba62:	f000 fc2d 	bl	810c2c0 <USBD_StdEPReq>
 810ba66:	4603      	mov	r3, r0
 810ba68:	73fb      	strb	r3, [r7, #15]
      break;
 810ba6a:	e00c      	b.n	810ba86 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 810ba6c:	687b      	ldr	r3, [r7, #4]
 810ba6e:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 810ba72:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 810ba76:	b2db      	uxtb	r3, r3
 810ba78:	4619      	mov	r1, r3
 810ba7a:	6878      	ldr	r0, [r7, #4]
 810ba7c:	f001 fe34 	bl	810d6e8 <USBD_LL_StallEP>
 810ba80:	4603      	mov	r3, r0
 810ba82:	73fb      	strb	r3, [r7, #15]
      break;
 810ba84:	bf00      	nop
  }

  return ret;
 810ba86:	7bfb      	ldrb	r3, [r7, #15]
}
 810ba88:	4618      	mov	r0, r3
 810ba8a:	3710      	adds	r7, #16
 810ba8c:	46bd      	mov	sp, r7
 810ba8e:	bd80      	pop	{r7, pc}

0810ba90 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 810ba90:	b580      	push	{r7, lr}
 810ba92:	b086      	sub	sp, #24
 810ba94:	af00      	add	r7, sp, #0
 810ba96:	60f8      	str	r0, [r7, #12]
 810ba98:	460b      	mov	r3, r1
 810ba9a:	607a      	str	r2, [r7, #4]
 810ba9c:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 810ba9e:	2300      	movs	r3, #0
 810baa0:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 810baa2:	7afb      	ldrb	r3, [r7, #11]
 810baa4:	2b00      	cmp	r3, #0
 810baa6:	d16e      	bne.n	810bb86 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 810baa8:	68fb      	ldr	r3, [r7, #12]
 810baaa:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 810baae:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 810bab0:	68fb      	ldr	r3, [r7, #12]
 810bab2:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 810bab6:	2b03      	cmp	r3, #3
 810bab8:	f040 8098 	bne.w	810bbec <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 810babc:	693b      	ldr	r3, [r7, #16]
 810babe:	689a      	ldr	r2, [r3, #8]
 810bac0:	693b      	ldr	r3, [r7, #16]
 810bac2:	68db      	ldr	r3, [r3, #12]
 810bac4:	429a      	cmp	r2, r3
 810bac6:	d913      	bls.n	810baf0 <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 810bac8:	693b      	ldr	r3, [r7, #16]
 810baca:	689a      	ldr	r2, [r3, #8]
 810bacc:	693b      	ldr	r3, [r7, #16]
 810bace:	68db      	ldr	r3, [r3, #12]
 810bad0:	1ad2      	subs	r2, r2, r3
 810bad2:	693b      	ldr	r3, [r7, #16]
 810bad4:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 810bad6:	693b      	ldr	r3, [r7, #16]
 810bad8:	68da      	ldr	r2, [r3, #12]
 810bada:	693b      	ldr	r3, [r7, #16]
 810badc:	689b      	ldr	r3, [r3, #8]
 810bade:	4293      	cmp	r3, r2
 810bae0:	bf28      	it	cs
 810bae2:	4613      	movcs	r3, r2
 810bae4:	461a      	mov	r2, r3
 810bae6:	6879      	ldr	r1, [r7, #4]
 810bae8:	68f8      	ldr	r0, [r7, #12]
 810baea:	f001 f9be 	bl	810ce6a <USBD_CtlContinueRx>
 810baee:	e07d      	b.n	810bbec <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 810baf0:	68fb      	ldr	r3, [r7, #12]
 810baf2:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 810baf6:	f003 031f 	and.w	r3, r3, #31
 810bafa:	2b02      	cmp	r3, #2
 810bafc:	d014      	beq.n	810bb28 <USBD_LL_DataOutStage+0x98>
 810bafe:	2b02      	cmp	r3, #2
 810bb00:	d81d      	bhi.n	810bb3e <USBD_LL_DataOutStage+0xae>
 810bb02:	2b00      	cmp	r3, #0
 810bb04:	d002      	beq.n	810bb0c <USBD_LL_DataOutStage+0x7c>
 810bb06:	2b01      	cmp	r3, #1
 810bb08:	d003      	beq.n	810bb12 <USBD_LL_DataOutStage+0x82>
 810bb0a:	e018      	b.n	810bb3e <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 810bb0c:	2300      	movs	r3, #0
 810bb0e:	75bb      	strb	r3, [r7, #22]
            break;
 810bb10:	e018      	b.n	810bb44 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 810bb12:	68fb      	ldr	r3, [r7, #12]
 810bb14:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 810bb18:	b2db      	uxtb	r3, r3
 810bb1a:	4619      	mov	r1, r3
 810bb1c:	68f8      	ldr	r0, [r7, #12]
 810bb1e:	f000 fa64 	bl	810bfea <USBD_CoreFindIF>
 810bb22:	4603      	mov	r3, r0
 810bb24:	75bb      	strb	r3, [r7, #22]
            break;
 810bb26:	e00d      	b.n	810bb44 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 810bb28:	68fb      	ldr	r3, [r7, #12]
 810bb2a:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 810bb2e:	b2db      	uxtb	r3, r3
 810bb30:	4619      	mov	r1, r3
 810bb32:	68f8      	ldr	r0, [r7, #12]
 810bb34:	f000 fa66 	bl	810c004 <USBD_CoreFindEP>
 810bb38:	4603      	mov	r3, r0
 810bb3a:	75bb      	strb	r3, [r7, #22]
            break;
 810bb3c:	e002      	b.n	810bb44 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 810bb3e:	2300      	movs	r3, #0
 810bb40:	75bb      	strb	r3, [r7, #22]
            break;
 810bb42:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 810bb44:	7dbb      	ldrb	r3, [r7, #22]
 810bb46:	2b00      	cmp	r3, #0
 810bb48:	d119      	bne.n	810bb7e <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bb4a:	68fb      	ldr	r3, [r7, #12]
 810bb4c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810bb50:	b2db      	uxtb	r3, r3
 810bb52:	2b03      	cmp	r3, #3
 810bb54:	d113      	bne.n	810bb7e <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 810bb56:	7dba      	ldrb	r2, [r7, #22]
 810bb58:	68fb      	ldr	r3, [r7, #12]
 810bb5a:	32ae      	adds	r2, #174	@ 0xae
 810bb5c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bb60:	691b      	ldr	r3, [r3, #16]
 810bb62:	2b00      	cmp	r3, #0
 810bb64:	d00b      	beq.n	810bb7e <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 810bb66:	7dba      	ldrb	r2, [r7, #22]
 810bb68:	68fb      	ldr	r3, [r7, #12]
 810bb6a:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 810bb6e:	7dba      	ldrb	r2, [r7, #22]
 810bb70:	68fb      	ldr	r3, [r7, #12]
 810bb72:	32ae      	adds	r2, #174	@ 0xae
 810bb74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bb78:	691b      	ldr	r3, [r3, #16]
 810bb7a:	68f8      	ldr	r0, [r7, #12]
 810bb7c:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 810bb7e:	68f8      	ldr	r0, [r7, #12]
 810bb80:	f001 f984 	bl	810ce8c <USBD_CtlSendStatus>
 810bb84:	e032      	b.n	810bbec <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 810bb86:	7afb      	ldrb	r3, [r7, #11]
 810bb88:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810bb8c:	b2db      	uxtb	r3, r3
 810bb8e:	4619      	mov	r1, r3
 810bb90:	68f8      	ldr	r0, [r7, #12]
 810bb92:	f000 fa37 	bl	810c004 <USBD_CoreFindEP>
 810bb96:	4603      	mov	r3, r0
 810bb98:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810bb9a:	7dbb      	ldrb	r3, [r7, #22]
 810bb9c:	2bff      	cmp	r3, #255	@ 0xff
 810bb9e:	d025      	beq.n	810bbec <USBD_LL_DataOutStage+0x15c>
 810bba0:	7dbb      	ldrb	r3, [r7, #22]
 810bba2:	2b00      	cmp	r3, #0
 810bba4:	d122      	bne.n	810bbec <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bba6:	68fb      	ldr	r3, [r7, #12]
 810bba8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810bbac:	b2db      	uxtb	r3, r3
 810bbae:	2b03      	cmp	r3, #3
 810bbb0:	d117      	bne.n	810bbe2 <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 810bbb2:	7dba      	ldrb	r2, [r7, #22]
 810bbb4:	68fb      	ldr	r3, [r7, #12]
 810bbb6:	32ae      	adds	r2, #174	@ 0xae
 810bbb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bbbc:	699b      	ldr	r3, [r3, #24]
 810bbbe:	2b00      	cmp	r3, #0
 810bbc0:	d00f      	beq.n	810bbe2 <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 810bbc2:	7dba      	ldrb	r2, [r7, #22]
 810bbc4:	68fb      	ldr	r3, [r7, #12]
 810bbc6:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 810bbca:	7dba      	ldrb	r2, [r7, #22]
 810bbcc:	68fb      	ldr	r3, [r7, #12]
 810bbce:	32ae      	adds	r2, #174	@ 0xae
 810bbd0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bbd4:	699b      	ldr	r3, [r3, #24]
 810bbd6:	7afa      	ldrb	r2, [r7, #11]
 810bbd8:	4611      	mov	r1, r2
 810bbda:	68f8      	ldr	r0, [r7, #12]
 810bbdc:	4798      	blx	r3
 810bbde:	4603      	mov	r3, r0
 810bbe0:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 810bbe2:	7dfb      	ldrb	r3, [r7, #23]
 810bbe4:	2b00      	cmp	r3, #0
 810bbe6:	d001      	beq.n	810bbec <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 810bbe8:	7dfb      	ldrb	r3, [r7, #23]
 810bbea:	e000      	b.n	810bbee <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 810bbec:	2300      	movs	r3, #0
}
 810bbee:	4618      	mov	r0, r3
 810bbf0:	3718      	adds	r7, #24
 810bbf2:	46bd      	mov	sp, r7
 810bbf4:	bd80      	pop	{r7, pc}

0810bbf6 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 810bbf6:	b580      	push	{r7, lr}
 810bbf8:	b086      	sub	sp, #24
 810bbfa:	af00      	add	r7, sp, #0
 810bbfc:	60f8      	str	r0, [r7, #12]
 810bbfe:	460b      	mov	r3, r1
 810bc00:	607a      	str	r2, [r7, #4]
 810bc02:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 810bc04:	7afb      	ldrb	r3, [r7, #11]
 810bc06:	2b00      	cmp	r3, #0
 810bc08:	d16f      	bne.n	810bcea <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 810bc0a:	68fb      	ldr	r3, [r7, #12]
 810bc0c:	3314      	adds	r3, #20
 810bc0e:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 810bc10:	68fb      	ldr	r3, [r7, #12]
 810bc12:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 810bc16:	2b02      	cmp	r3, #2
 810bc18:	d15a      	bne.n	810bcd0 <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 810bc1a:	693b      	ldr	r3, [r7, #16]
 810bc1c:	689a      	ldr	r2, [r3, #8]
 810bc1e:	693b      	ldr	r3, [r7, #16]
 810bc20:	68db      	ldr	r3, [r3, #12]
 810bc22:	429a      	cmp	r2, r3
 810bc24:	d914      	bls.n	810bc50 <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 810bc26:	693b      	ldr	r3, [r7, #16]
 810bc28:	689a      	ldr	r2, [r3, #8]
 810bc2a:	693b      	ldr	r3, [r7, #16]
 810bc2c:	68db      	ldr	r3, [r3, #12]
 810bc2e:	1ad2      	subs	r2, r2, r3
 810bc30:	693b      	ldr	r3, [r7, #16]
 810bc32:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 810bc34:	693b      	ldr	r3, [r7, #16]
 810bc36:	689b      	ldr	r3, [r3, #8]
 810bc38:	461a      	mov	r2, r3
 810bc3a:	6879      	ldr	r1, [r7, #4]
 810bc3c:	68f8      	ldr	r0, [r7, #12]
 810bc3e:	f001 f8e6 	bl	810ce0e <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810bc42:	2300      	movs	r3, #0
 810bc44:	2200      	movs	r2, #0
 810bc46:	2100      	movs	r1, #0
 810bc48:	68f8      	ldr	r0, [r7, #12]
 810bc4a:	f001 fdf7 	bl	810d83c <USBD_LL_PrepareReceive>
 810bc4e:	e03f      	b.n	810bcd0 <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 810bc50:	693b      	ldr	r3, [r7, #16]
 810bc52:	68da      	ldr	r2, [r3, #12]
 810bc54:	693b      	ldr	r3, [r7, #16]
 810bc56:	689b      	ldr	r3, [r3, #8]
 810bc58:	429a      	cmp	r2, r3
 810bc5a:	d11c      	bne.n	810bc96 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 810bc5c:	693b      	ldr	r3, [r7, #16]
 810bc5e:	685a      	ldr	r2, [r3, #4]
 810bc60:	693b      	ldr	r3, [r7, #16]
 810bc62:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 810bc64:	429a      	cmp	r2, r3
 810bc66:	d316      	bcc.n	810bc96 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 810bc68:	693b      	ldr	r3, [r7, #16]
 810bc6a:	685a      	ldr	r2, [r3, #4]
 810bc6c:	68fb      	ldr	r3, [r7, #12]
 810bc6e:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 810bc72:	429a      	cmp	r2, r3
 810bc74:	d20f      	bcs.n	810bc96 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 810bc76:	2200      	movs	r2, #0
 810bc78:	2100      	movs	r1, #0
 810bc7a:	68f8      	ldr	r0, [r7, #12]
 810bc7c:	f001 f8c7 	bl	810ce0e <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 810bc80:	68fb      	ldr	r3, [r7, #12]
 810bc82:	2200      	movs	r2, #0
 810bc84:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810bc88:	2300      	movs	r3, #0
 810bc8a:	2200      	movs	r2, #0
 810bc8c:	2100      	movs	r1, #0
 810bc8e:	68f8      	ldr	r0, [r7, #12]
 810bc90:	f001 fdd4 	bl	810d83c <USBD_LL_PrepareReceive>
 810bc94:	e01c      	b.n	810bcd0 <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bc96:	68fb      	ldr	r3, [r7, #12]
 810bc98:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810bc9c:	b2db      	uxtb	r3, r3
 810bc9e:	2b03      	cmp	r3, #3
 810bca0:	d10f      	bne.n	810bcc2 <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 810bca2:	68fb      	ldr	r3, [r7, #12]
 810bca4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bca8:	68db      	ldr	r3, [r3, #12]
 810bcaa:	2b00      	cmp	r3, #0
 810bcac:	d009      	beq.n	810bcc2 <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 810bcae:	68fb      	ldr	r3, [r7, #12]
 810bcb0:	2200      	movs	r2, #0
 810bcb2:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 810bcb6:	68fb      	ldr	r3, [r7, #12]
 810bcb8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bcbc:	68db      	ldr	r3, [r3, #12]
 810bcbe:	68f8      	ldr	r0, [r7, #12]
 810bcc0:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 810bcc2:	2180      	movs	r1, #128	@ 0x80
 810bcc4:	68f8      	ldr	r0, [r7, #12]
 810bcc6:	f001 fd0f 	bl	810d6e8 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 810bcca:	68f8      	ldr	r0, [r7, #12]
 810bccc:	f001 f8f1 	bl	810ceb2 <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 810bcd0:	68fb      	ldr	r3, [r7, #12]
 810bcd2:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 810bcd6:	2b00      	cmp	r3, #0
 810bcd8:	d03a      	beq.n	810bd50 <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 810bcda:	68f8      	ldr	r0, [r7, #12]
 810bcdc:	f7ff fe42 	bl	810b964 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 810bce0:	68fb      	ldr	r3, [r7, #12]
 810bce2:	2200      	movs	r2, #0
 810bce4:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 810bce8:	e032      	b.n	810bd50 <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 810bcea:	7afb      	ldrb	r3, [r7, #11]
 810bcec:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 810bcf0:	b2db      	uxtb	r3, r3
 810bcf2:	4619      	mov	r1, r3
 810bcf4:	68f8      	ldr	r0, [r7, #12]
 810bcf6:	f000 f985 	bl	810c004 <USBD_CoreFindEP>
 810bcfa:	4603      	mov	r3, r0
 810bcfc:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810bcfe:	7dfb      	ldrb	r3, [r7, #23]
 810bd00:	2bff      	cmp	r3, #255	@ 0xff
 810bd02:	d025      	beq.n	810bd50 <USBD_LL_DataInStage+0x15a>
 810bd04:	7dfb      	ldrb	r3, [r7, #23]
 810bd06:	2b00      	cmp	r3, #0
 810bd08:	d122      	bne.n	810bd50 <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bd0a:	68fb      	ldr	r3, [r7, #12]
 810bd0c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810bd10:	b2db      	uxtb	r3, r3
 810bd12:	2b03      	cmp	r3, #3
 810bd14:	d11c      	bne.n	810bd50 <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 810bd16:	7dfa      	ldrb	r2, [r7, #23]
 810bd18:	68fb      	ldr	r3, [r7, #12]
 810bd1a:	32ae      	adds	r2, #174	@ 0xae
 810bd1c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bd20:	695b      	ldr	r3, [r3, #20]
 810bd22:	2b00      	cmp	r3, #0
 810bd24:	d014      	beq.n	810bd50 <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 810bd26:	7dfa      	ldrb	r2, [r7, #23]
 810bd28:	68fb      	ldr	r3, [r7, #12]
 810bd2a:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 810bd2e:	7dfa      	ldrb	r2, [r7, #23]
 810bd30:	68fb      	ldr	r3, [r7, #12]
 810bd32:	32ae      	adds	r2, #174	@ 0xae
 810bd34:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bd38:	695b      	ldr	r3, [r3, #20]
 810bd3a:	7afa      	ldrb	r2, [r7, #11]
 810bd3c:	4611      	mov	r1, r2
 810bd3e:	68f8      	ldr	r0, [r7, #12]
 810bd40:	4798      	blx	r3
 810bd42:	4603      	mov	r3, r0
 810bd44:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 810bd46:	7dbb      	ldrb	r3, [r7, #22]
 810bd48:	2b00      	cmp	r3, #0
 810bd4a:	d001      	beq.n	810bd50 <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 810bd4c:	7dbb      	ldrb	r3, [r7, #22]
 810bd4e:	e000      	b.n	810bd52 <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 810bd50:	2300      	movs	r3, #0
}
 810bd52:	4618      	mov	r0, r3
 810bd54:	3718      	adds	r7, #24
 810bd56:	46bd      	mov	sp, r7
 810bd58:	bd80      	pop	{r7, pc}

0810bd5a <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 810bd5a:	b580      	push	{r7, lr}
 810bd5c:	b084      	sub	sp, #16
 810bd5e:	af00      	add	r7, sp, #0
 810bd60:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 810bd62:	2300      	movs	r3, #0
 810bd64:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810bd66:	687b      	ldr	r3, [r7, #4]
 810bd68:	2201      	movs	r2, #1
 810bd6a:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 810bd6e:	687b      	ldr	r3, [r7, #4]
 810bd70:	2200      	movs	r2, #0
 810bd72:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 810bd76:	687b      	ldr	r3, [r7, #4]
 810bd78:	2200      	movs	r2, #0
 810bd7a:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 810bd7c:	687b      	ldr	r3, [r7, #4]
 810bd7e:	2200      	movs	r2, #0
 810bd80:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 810bd84:	687b      	ldr	r3, [r7, #4]
 810bd86:	2200      	movs	r2, #0
 810bd88:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 810bd8c:	687b      	ldr	r3, [r7, #4]
 810bd8e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bd92:	2b00      	cmp	r3, #0
 810bd94:	d014      	beq.n	810bdc0 <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 810bd96:	687b      	ldr	r3, [r7, #4]
 810bd98:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bd9c:	685b      	ldr	r3, [r3, #4]
 810bd9e:	2b00      	cmp	r3, #0
 810bda0:	d00e      	beq.n	810bdc0 <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 810bda2:	687b      	ldr	r3, [r7, #4]
 810bda4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bda8:	685b      	ldr	r3, [r3, #4]
 810bdaa:	687a      	ldr	r2, [r7, #4]
 810bdac:	6852      	ldr	r2, [r2, #4]
 810bdae:	b2d2      	uxtb	r2, r2
 810bdb0:	4611      	mov	r1, r2
 810bdb2:	6878      	ldr	r0, [r7, #4]
 810bdb4:	4798      	blx	r3
 810bdb6:	4603      	mov	r3, r0
 810bdb8:	2b00      	cmp	r3, #0
 810bdba:	d001      	beq.n	810bdc0 <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 810bdbc:	2303      	movs	r3, #3
 810bdbe:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 810bdc0:	2340      	movs	r3, #64	@ 0x40
 810bdc2:	2200      	movs	r2, #0
 810bdc4:	2100      	movs	r1, #0
 810bdc6:	6878      	ldr	r0, [r7, #4]
 810bdc8:	f001 fc49 	bl	810d65e <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 810bdcc:	687b      	ldr	r3, [r7, #4]
 810bdce:	2201      	movs	r2, #1
 810bdd0:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 810bdd4:	687b      	ldr	r3, [r7, #4]
 810bdd6:	2240      	movs	r2, #64	@ 0x40
 810bdd8:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 810bddc:	2340      	movs	r3, #64	@ 0x40
 810bdde:	2200      	movs	r2, #0
 810bde0:	2180      	movs	r1, #128	@ 0x80
 810bde2:	6878      	ldr	r0, [r7, #4]
 810bde4:	f001 fc3b 	bl	810d65e <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 810bde8:	687b      	ldr	r3, [r7, #4]
 810bdea:	2201      	movs	r2, #1
 810bdec:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 810bdee:	687b      	ldr	r3, [r7, #4]
 810bdf0:	2240      	movs	r2, #64	@ 0x40
 810bdf2:	621a      	str	r2, [r3, #32]

  return ret;
 810bdf4:	7bfb      	ldrb	r3, [r7, #15]
}
 810bdf6:	4618      	mov	r0, r3
 810bdf8:	3710      	adds	r7, #16
 810bdfa:	46bd      	mov	sp, r7
 810bdfc:	bd80      	pop	{r7, pc}

0810bdfe <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 810bdfe:	b480      	push	{r7}
 810be00:	b083      	sub	sp, #12
 810be02:	af00      	add	r7, sp, #0
 810be04:	6078      	str	r0, [r7, #4]
 810be06:	460b      	mov	r3, r1
 810be08:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 810be0a:	687b      	ldr	r3, [r7, #4]
 810be0c:	78fa      	ldrb	r2, [r7, #3]
 810be0e:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 810be10:	2300      	movs	r3, #0
}
 810be12:	4618      	mov	r0, r3
 810be14:	370c      	adds	r7, #12
 810be16:	46bd      	mov	sp, r7
 810be18:	f85d 7b04 	ldr.w	r7, [sp], #4
 810be1c:	4770      	bx	lr

0810be1e <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 810be1e:	b480      	push	{r7}
 810be20:	b083      	sub	sp, #12
 810be22:	af00      	add	r7, sp, #0
 810be24:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 810be26:	687b      	ldr	r3, [r7, #4]
 810be28:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810be2c:	b2db      	uxtb	r3, r3
 810be2e:	2b04      	cmp	r3, #4
 810be30:	d006      	beq.n	810be40 <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 810be32:	687b      	ldr	r3, [r7, #4]
 810be34:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810be38:	b2da      	uxtb	r2, r3
 810be3a:	687b      	ldr	r3, [r7, #4]
 810be3c:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 810be40:	687b      	ldr	r3, [r7, #4]
 810be42:	2204      	movs	r2, #4
 810be44:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 810be48:	2300      	movs	r3, #0
}
 810be4a:	4618      	mov	r0, r3
 810be4c:	370c      	adds	r7, #12
 810be4e:	46bd      	mov	sp, r7
 810be50:	f85d 7b04 	ldr.w	r7, [sp], #4
 810be54:	4770      	bx	lr

0810be56 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 810be56:	b480      	push	{r7}
 810be58:	b083      	sub	sp, #12
 810be5a:	af00      	add	r7, sp, #0
 810be5c:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 810be5e:	687b      	ldr	r3, [r7, #4]
 810be60:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810be64:	b2db      	uxtb	r3, r3
 810be66:	2b04      	cmp	r3, #4
 810be68:	d106      	bne.n	810be78 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 810be6a:	687b      	ldr	r3, [r7, #4]
 810be6c:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 810be70:	b2da      	uxtb	r2, r3
 810be72:	687b      	ldr	r3, [r7, #4]
 810be74:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 810be78:	2300      	movs	r3, #0
}
 810be7a:	4618      	mov	r0, r3
 810be7c:	370c      	adds	r7, #12
 810be7e:	46bd      	mov	sp, r7
 810be80:	f85d 7b04 	ldr.w	r7, [sp], #4
 810be84:	4770      	bx	lr

0810be86 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 810be86:	b580      	push	{r7, lr}
 810be88:	b082      	sub	sp, #8
 810be8a:	af00      	add	r7, sp, #0
 810be8c:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810be8e:	687b      	ldr	r3, [r7, #4]
 810be90:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810be94:	b2db      	uxtb	r3, r3
 810be96:	2b03      	cmp	r3, #3
 810be98:	d110      	bne.n	810bebc <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 810be9a:	687b      	ldr	r3, [r7, #4]
 810be9c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bea0:	2b00      	cmp	r3, #0
 810bea2:	d00b      	beq.n	810bebc <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 810bea4:	687b      	ldr	r3, [r7, #4]
 810bea6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810beaa:	69db      	ldr	r3, [r3, #28]
 810beac:	2b00      	cmp	r3, #0
 810beae:	d005      	beq.n	810bebc <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 810beb0:	687b      	ldr	r3, [r7, #4]
 810beb2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810beb6:	69db      	ldr	r3, [r3, #28]
 810beb8:	6878      	ldr	r0, [r7, #4]
 810beba:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 810bebc:	2300      	movs	r3, #0
}
 810bebe:	4618      	mov	r0, r3
 810bec0:	3708      	adds	r7, #8
 810bec2:	46bd      	mov	sp, r7
 810bec4:	bd80      	pop	{r7, pc}

0810bec6 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 810bec6:	b580      	push	{r7, lr}
 810bec8:	b082      	sub	sp, #8
 810beca:	af00      	add	r7, sp, #0
 810becc:	6078      	str	r0, [r7, #4]
 810bece:	460b      	mov	r3, r1
 810bed0:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 810bed2:	687b      	ldr	r3, [r7, #4]
 810bed4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810bed8:	687b      	ldr	r3, [r7, #4]
 810beda:	32ae      	adds	r2, #174	@ 0xae
 810bedc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bee0:	2b00      	cmp	r3, #0
 810bee2:	d101      	bne.n	810bee8 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 810bee4:	2303      	movs	r3, #3
 810bee6:	e01c      	b.n	810bf22 <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bee8:	687b      	ldr	r3, [r7, #4]
 810beea:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810beee:	b2db      	uxtb	r3, r3
 810bef0:	2b03      	cmp	r3, #3
 810bef2:	d115      	bne.n	810bf20 <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 810bef4:	687b      	ldr	r3, [r7, #4]
 810bef6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810befa:	687b      	ldr	r3, [r7, #4]
 810befc:	32ae      	adds	r2, #174	@ 0xae
 810befe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bf02:	6a1b      	ldr	r3, [r3, #32]
 810bf04:	2b00      	cmp	r3, #0
 810bf06:	d00b      	beq.n	810bf20 <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 810bf08:	687b      	ldr	r3, [r7, #4]
 810bf0a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810bf0e:	687b      	ldr	r3, [r7, #4]
 810bf10:	32ae      	adds	r2, #174	@ 0xae
 810bf12:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bf16:	6a1b      	ldr	r3, [r3, #32]
 810bf18:	78fa      	ldrb	r2, [r7, #3]
 810bf1a:	4611      	mov	r1, r2
 810bf1c:	6878      	ldr	r0, [r7, #4]
 810bf1e:	4798      	blx	r3
    }
  }

  return USBD_OK;
 810bf20:	2300      	movs	r3, #0
}
 810bf22:	4618      	mov	r0, r3
 810bf24:	3708      	adds	r7, #8
 810bf26:	46bd      	mov	sp, r7
 810bf28:	bd80      	pop	{r7, pc}

0810bf2a <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 810bf2a:	b580      	push	{r7, lr}
 810bf2c:	b082      	sub	sp, #8
 810bf2e:	af00      	add	r7, sp, #0
 810bf30:	6078      	str	r0, [r7, #4]
 810bf32:	460b      	mov	r3, r1
 810bf34:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 810bf36:	687b      	ldr	r3, [r7, #4]
 810bf38:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810bf3c:	687b      	ldr	r3, [r7, #4]
 810bf3e:	32ae      	adds	r2, #174	@ 0xae
 810bf40:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bf44:	2b00      	cmp	r3, #0
 810bf46:	d101      	bne.n	810bf4c <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 810bf48:	2303      	movs	r3, #3
 810bf4a:	e01c      	b.n	810bf86 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810bf4c:	687b      	ldr	r3, [r7, #4]
 810bf4e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810bf52:	b2db      	uxtb	r3, r3
 810bf54:	2b03      	cmp	r3, #3
 810bf56:	d115      	bne.n	810bf84 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 810bf58:	687b      	ldr	r3, [r7, #4]
 810bf5a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810bf5e:	687b      	ldr	r3, [r7, #4]
 810bf60:	32ae      	adds	r2, #174	@ 0xae
 810bf62:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bf66:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810bf68:	2b00      	cmp	r3, #0
 810bf6a:	d00b      	beq.n	810bf84 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 810bf6c:	687b      	ldr	r3, [r7, #4]
 810bf6e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810bf72:	687b      	ldr	r3, [r7, #4]
 810bf74:	32ae      	adds	r2, #174	@ 0xae
 810bf76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810bf7a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810bf7c:	78fa      	ldrb	r2, [r7, #3]
 810bf7e:	4611      	mov	r1, r2
 810bf80:	6878      	ldr	r0, [r7, #4]
 810bf82:	4798      	blx	r3
    }
  }

  return USBD_OK;
 810bf84:	2300      	movs	r3, #0
}
 810bf86:	4618      	mov	r0, r3
 810bf88:	3708      	adds	r7, #8
 810bf8a:	46bd      	mov	sp, r7
 810bf8c:	bd80      	pop	{r7, pc}

0810bf8e <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 810bf8e:	b480      	push	{r7}
 810bf90:	b083      	sub	sp, #12
 810bf92:	af00      	add	r7, sp, #0
 810bf94:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 810bf96:	2300      	movs	r3, #0
}
 810bf98:	4618      	mov	r0, r3
 810bf9a:	370c      	adds	r7, #12
 810bf9c:	46bd      	mov	sp, r7
 810bf9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bfa2:	4770      	bx	lr

0810bfa4 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 810bfa4:	b580      	push	{r7, lr}
 810bfa6:	b084      	sub	sp, #16
 810bfa8:	af00      	add	r7, sp, #0
 810bfaa:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 810bfac:	2300      	movs	r3, #0
 810bfae:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810bfb0:	687b      	ldr	r3, [r7, #4]
 810bfb2:	2201      	movs	r2, #1
 810bfb4:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 810bfb8:	687b      	ldr	r3, [r7, #4]
 810bfba:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bfbe:	2b00      	cmp	r3, #0
 810bfc0:	d00e      	beq.n	810bfe0 <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 810bfc2:	687b      	ldr	r3, [r7, #4]
 810bfc4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810bfc8:	685b      	ldr	r3, [r3, #4]
 810bfca:	687a      	ldr	r2, [r7, #4]
 810bfcc:	6852      	ldr	r2, [r2, #4]
 810bfce:	b2d2      	uxtb	r2, r2
 810bfd0:	4611      	mov	r1, r2
 810bfd2:	6878      	ldr	r0, [r7, #4]
 810bfd4:	4798      	blx	r3
 810bfd6:	4603      	mov	r3, r0
 810bfd8:	2b00      	cmp	r3, #0
 810bfda:	d001      	beq.n	810bfe0 <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 810bfdc:	2303      	movs	r3, #3
 810bfde:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810bfe0:	7bfb      	ldrb	r3, [r7, #15]
}
 810bfe2:	4618      	mov	r0, r3
 810bfe4:	3710      	adds	r7, #16
 810bfe6:	46bd      	mov	sp, r7
 810bfe8:	bd80      	pop	{r7, pc}

0810bfea <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 810bfea:	b480      	push	{r7}
 810bfec:	b083      	sub	sp, #12
 810bfee:	af00      	add	r7, sp, #0
 810bff0:	6078      	str	r0, [r7, #4]
 810bff2:	460b      	mov	r3, r1
 810bff4:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 810bff6:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 810bff8:	4618      	mov	r0, r3
 810bffa:	370c      	adds	r7, #12
 810bffc:	46bd      	mov	sp, r7
 810bffe:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c002:	4770      	bx	lr

0810c004 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 810c004:	b480      	push	{r7}
 810c006:	b083      	sub	sp, #12
 810c008:	af00      	add	r7, sp, #0
 810c00a:	6078      	str	r0, [r7, #4]
 810c00c:	460b      	mov	r3, r1
 810c00e:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 810c010:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 810c012:	4618      	mov	r0, r3
 810c014:	370c      	adds	r7, #12
 810c016:	46bd      	mov	sp, r7
 810c018:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c01c:	4770      	bx	lr

0810c01e <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 810c01e:	b580      	push	{r7, lr}
 810c020:	b086      	sub	sp, #24
 810c022:	af00      	add	r7, sp, #0
 810c024:	6078      	str	r0, [r7, #4]
 810c026:	460b      	mov	r3, r1
 810c028:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 810c02a:	687b      	ldr	r3, [r7, #4]
 810c02c:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 810c02e:	687b      	ldr	r3, [r7, #4]
 810c030:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 810c032:	2300      	movs	r3, #0
 810c034:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 810c036:	68fb      	ldr	r3, [r7, #12]
 810c038:	885b      	ldrh	r3, [r3, #2]
 810c03a:	b29b      	uxth	r3, r3
 810c03c:	68fa      	ldr	r2, [r7, #12]
 810c03e:	7812      	ldrb	r2, [r2, #0]
 810c040:	4293      	cmp	r3, r2
 810c042:	d91f      	bls.n	810c084 <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
 810c044:	68fb      	ldr	r3, [r7, #12]
 810c046:	781b      	ldrb	r3, [r3, #0]
 810c048:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 810c04a:	e013      	b.n	810c074 <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 810c04c:	f107 030a 	add.w	r3, r7, #10
 810c050:	4619      	mov	r1, r3
 810c052:	6978      	ldr	r0, [r7, #20]
 810c054:	f000 f81b 	bl	810c08e <USBD_GetNextDesc>
 810c058:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 810c05a:	697b      	ldr	r3, [r7, #20]
 810c05c:	785b      	ldrb	r3, [r3, #1]
 810c05e:	2b05      	cmp	r3, #5
 810c060:	d108      	bne.n	810c074 <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 810c062:	697b      	ldr	r3, [r7, #20]
 810c064:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 810c066:	693b      	ldr	r3, [r7, #16]
 810c068:	789b      	ldrb	r3, [r3, #2]
 810c06a:	78fa      	ldrb	r2, [r7, #3]
 810c06c:	429a      	cmp	r2, r3
 810c06e:	d008      	beq.n	810c082 <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 810c070:	2300      	movs	r3, #0
 810c072:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 810c074:	68fb      	ldr	r3, [r7, #12]
 810c076:	885b      	ldrh	r3, [r3, #2]
 810c078:	b29a      	uxth	r2, r3
 810c07a:	897b      	ldrh	r3, [r7, #10]
 810c07c:	429a      	cmp	r2, r3
 810c07e:	d8e5      	bhi.n	810c04c <USBD_GetEpDesc+0x2e>
 810c080:	e000      	b.n	810c084 <USBD_GetEpDesc+0x66>
          break;
 810c082:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 810c084:	693b      	ldr	r3, [r7, #16]
}
 810c086:	4618      	mov	r0, r3
 810c088:	3718      	adds	r7, #24
 810c08a:	46bd      	mov	sp, r7
 810c08c:	bd80      	pop	{r7, pc}

0810c08e <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 810c08e:	b480      	push	{r7}
 810c090:	b085      	sub	sp, #20
 810c092:	af00      	add	r7, sp, #0
 810c094:	6078      	str	r0, [r7, #4]
 810c096:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 810c098:	687b      	ldr	r3, [r7, #4]
 810c09a:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 810c09c:	683b      	ldr	r3, [r7, #0]
 810c09e:	881b      	ldrh	r3, [r3, #0]
 810c0a0:	68fa      	ldr	r2, [r7, #12]
 810c0a2:	7812      	ldrb	r2, [r2, #0]
 810c0a4:	4413      	add	r3, r2
 810c0a6:	b29a      	uxth	r2, r3
 810c0a8:	683b      	ldr	r3, [r7, #0]
 810c0aa:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 810c0ac:	68fb      	ldr	r3, [r7, #12]
 810c0ae:	781b      	ldrb	r3, [r3, #0]
 810c0b0:	461a      	mov	r2, r3
 810c0b2:	687b      	ldr	r3, [r7, #4]
 810c0b4:	4413      	add	r3, r2
 810c0b6:	60fb      	str	r3, [r7, #12]

  return (pnext);
 810c0b8:	68fb      	ldr	r3, [r7, #12]
}
 810c0ba:	4618      	mov	r0, r3
 810c0bc:	3714      	adds	r7, #20
 810c0be:	46bd      	mov	sp, r7
 810c0c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c0c4:	4770      	bx	lr

0810c0c6 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 810c0c6:	b480      	push	{r7}
 810c0c8:	b087      	sub	sp, #28
 810c0ca:	af00      	add	r7, sp, #0
 810c0cc:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 810c0ce:	687b      	ldr	r3, [r7, #4]
 810c0d0:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 810c0d2:	697b      	ldr	r3, [r7, #20]
 810c0d4:	781b      	ldrb	r3, [r3, #0]
 810c0d6:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 810c0d8:	697b      	ldr	r3, [r7, #20]
 810c0da:	3301      	adds	r3, #1
 810c0dc:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 810c0de:	697b      	ldr	r3, [r7, #20]
 810c0e0:	781b      	ldrb	r3, [r3, #0]
 810c0e2:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 810c0e4:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 810c0e8:	021b      	lsls	r3, r3, #8
 810c0ea:	b21a      	sxth	r2, r3
 810c0ec:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 810c0f0:	4313      	orrs	r3, r2
 810c0f2:	b21b      	sxth	r3, r3
 810c0f4:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 810c0f6:	89fb      	ldrh	r3, [r7, #14]
}
 810c0f8:	4618      	mov	r0, r3
 810c0fa:	371c      	adds	r7, #28
 810c0fc:	46bd      	mov	sp, r7
 810c0fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c102:	4770      	bx	lr

0810c104 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c104:	b580      	push	{r7, lr}
 810c106:	b084      	sub	sp, #16
 810c108:	af00      	add	r7, sp, #0
 810c10a:	6078      	str	r0, [r7, #4]
 810c10c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810c10e:	2300      	movs	r3, #0
 810c110:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810c112:	683b      	ldr	r3, [r7, #0]
 810c114:	781b      	ldrb	r3, [r3, #0]
 810c116:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 810c11a:	2b40      	cmp	r3, #64	@ 0x40
 810c11c:	d005      	beq.n	810c12a <USBD_StdDevReq+0x26>
 810c11e:	2b40      	cmp	r3, #64	@ 0x40
 810c120:	d857      	bhi.n	810c1d2 <USBD_StdDevReq+0xce>
 810c122:	2b00      	cmp	r3, #0
 810c124:	d00f      	beq.n	810c146 <USBD_StdDevReq+0x42>
 810c126:	2b20      	cmp	r3, #32
 810c128:	d153      	bne.n	810c1d2 <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 810c12a:	687b      	ldr	r3, [r7, #4]
 810c12c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 810c130:	687b      	ldr	r3, [r7, #4]
 810c132:	32ae      	adds	r2, #174	@ 0xae
 810c134:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c138:	689b      	ldr	r3, [r3, #8]
 810c13a:	6839      	ldr	r1, [r7, #0]
 810c13c:	6878      	ldr	r0, [r7, #4]
 810c13e:	4798      	blx	r3
 810c140:	4603      	mov	r3, r0
 810c142:	73fb      	strb	r3, [r7, #15]
      break;
 810c144:	e04a      	b.n	810c1dc <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810c146:	683b      	ldr	r3, [r7, #0]
 810c148:	785b      	ldrb	r3, [r3, #1]
 810c14a:	2b09      	cmp	r3, #9
 810c14c:	d83b      	bhi.n	810c1c6 <USBD_StdDevReq+0xc2>
 810c14e:	a201      	add	r2, pc, #4	@ (adr r2, 810c154 <USBD_StdDevReq+0x50>)
 810c150:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810c154:	0810c1a9 	.word	0x0810c1a9
 810c158:	0810c1bd 	.word	0x0810c1bd
 810c15c:	0810c1c7 	.word	0x0810c1c7
 810c160:	0810c1b3 	.word	0x0810c1b3
 810c164:	0810c1c7 	.word	0x0810c1c7
 810c168:	0810c187 	.word	0x0810c187
 810c16c:	0810c17d 	.word	0x0810c17d
 810c170:	0810c1c7 	.word	0x0810c1c7
 810c174:	0810c19f 	.word	0x0810c19f
 810c178:	0810c191 	.word	0x0810c191
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 810c17c:	6839      	ldr	r1, [r7, #0]
 810c17e:	6878      	ldr	r0, [r7, #4]
 810c180:	f000 fa3c 	bl	810c5fc <USBD_GetDescriptor>
          break;
 810c184:	e024      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 810c186:	6839      	ldr	r1, [r7, #0]
 810c188:	6878      	ldr	r0, [r7, #4]
 810c18a:	f000 fbcb 	bl	810c924 <USBD_SetAddress>
          break;
 810c18e:	e01f      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 810c190:	6839      	ldr	r1, [r7, #0]
 810c192:	6878      	ldr	r0, [r7, #4]
 810c194:	f000 fc0a 	bl	810c9ac <USBD_SetConfig>
 810c198:	4603      	mov	r3, r0
 810c19a:	73fb      	strb	r3, [r7, #15]
          break;
 810c19c:	e018      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 810c19e:	6839      	ldr	r1, [r7, #0]
 810c1a0:	6878      	ldr	r0, [r7, #4]
 810c1a2:	f000 fcad 	bl	810cb00 <USBD_GetConfig>
          break;
 810c1a6:	e013      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 810c1a8:	6839      	ldr	r1, [r7, #0]
 810c1aa:	6878      	ldr	r0, [r7, #4]
 810c1ac:	f000 fcde 	bl	810cb6c <USBD_GetStatus>
          break;
 810c1b0:	e00e      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 810c1b2:	6839      	ldr	r1, [r7, #0]
 810c1b4:	6878      	ldr	r0, [r7, #4]
 810c1b6:	f000 fd0d 	bl	810cbd4 <USBD_SetFeature>
          break;
 810c1ba:	e009      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 810c1bc:	6839      	ldr	r1, [r7, #0]
 810c1be:	6878      	ldr	r0, [r7, #4]
 810c1c0:	f000 fd31 	bl	810cc26 <USBD_ClrFeature>
          break;
 810c1c4:	e004      	b.n	810c1d0 <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 810c1c6:	6839      	ldr	r1, [r7, #0]
 810c1c8:	6878      	ldr	r0, [r7, #4]
 810c1ca:	f000 fd88 	bl	810ccde <USBD_CtlError>
          break;
 810c1ce:	bf00      	nop
      }
      break;
 810c1d0:	e004      	b.n	810c1dc <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 810c1d2:	6839      	ldr	r1, [r7, #0]
 810c1d4:	6878      	ldr	r0, [r7, #4]
 810c1d6:	f000 fd82 	bl	810ccde <USBD_CtlError>
      break;
 810c1da:	bf00      	nop
  }

  return ret;
 810c1dc:	7bfb      	ldrb	r3, [r7, #15]
}
 810c1de:	4618      	mov	r0, r3
 810c1e0:	3710      	adds	r7, #16
 810c1e2:	46bd      	mov	sp, r7
 810c1e4:	bd80      	pop	{r7, pc}
 810c1e6:	bf00      	nop

0810c1e8 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c1e8:	b580      	push	{r7, lr}
 810c1ea:	b084      	sub	sp, #16
 810c1ec:	af00      	add	r7, sp, #0
 810c1ee:	6078      	str	r0, [r7, #4]
 810c1f0:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810c1f2:	2300      	movs	r3, #0
 810c1f4:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810c1f6:	683b      	ldr	r3, [r7, #0]
 810c1f8:	781b      	ldrb	r3, [r3, #0]
 810c1fa:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 810c1fe:	2b40      	cmp	r3, #64	@ 0x40
 810c200:	d005      	beq.n	810c20e <USBD_StdItfReq+0x26>
 810c202:	2b40      	cmp	r3, #64	@ 0x40
 810c204:	d852      	bhi.n	810c2ac <USBD_StdItfReq+0xc4>
 810c206:	2b00      	cmp	r3, #0
 810c208:	d001      	beq.n	810c20e <USBD_StdItfReq+0x26>
 810c20a:	2b20      	cmp	r3, #32
 810c20c:	d14e      	bne.n	810c2ac <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 810c20e:	687b      	ldr	r3, [r7, #4]
 810c210:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c214:	b2db      	uxtb	r3, r3
 810c216:	3b01      	subs	r3, #1
 810c218:	2b02      	cmp	r3, #2
 810c21a:	d840      	bhi.n	810c29e <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 810c21c:	683b      	ldr	r3, [r7, #0]
 810c21e:	889b      	ldrh	r3, [r3, #4]
 810c220:	b2db      	uxtb	r3, r3
 810c222:	2b01      	cmp	r3, #1
 810c224:	d836      	bhi.n	810c294 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 810c226:	683b      	ldr	r3, [r7, #0]
 810c228:	889b      	ldrh	r3, [r3, #4]
 810c22a:	b2db      	uxtb	r3, r3
 810c22c:	4619      	mov	r1, r3
 810c22e:	6878      	ldr	r0, [r7, #4]
 810c230:	f7ff fedb 	bl	810bfea <USBD_CoreFindIF>
 810c234:	4603      	mov	r3, r0
 810c236:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810c238:	7bbb      	ldrb	r3, [r7, #14]
 810c23a:	2bff      	cmp	r3, #255	@ 0xff
 810c23c:	d01d      	beq.n	810c27a <USBD_StdItfReq+0x92>
 810c23e:	7bbb      	ldrb	r3, [r7, #14]
 810c240:	2b00      	cmp	r3, #0
 810c242:	d11a      	bne.n	810c27a <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 810c244:	7bba      	ldrb	r2, [r7, #14]
 810c246:	687b      	ldr	r3, [r7, #4]
 810c248:	32ae      	adds	r2, #174	@ 0xae
 810c24a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c24e:	689b      	ldr	r3, [r3, #8]
 810c250:	2b00      	cmp	r3, #0
 810c252:	d00f      	beq.n	810c274 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 810c254:	7bba      	ldrb	r2, [r7, #14]
 810c256:	687b      	ldr	r3, [r7, #4]
 810c258:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 810c25c:	7bba      	ldrb	r2, [r7, #14]
 810c25e:	687b      	ldr	r3, [r7, #4]
 810c260:	32ae      	adds	r2, #174	@ 0xae
 810c262:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c266:	689b      	ldr	r3, [r3, #8]
 810c268:	6839      	ldr	r1, [r7, #0]
 810c26a:	6878      	ldr	r0, [r7, #4]
 810c26c:	4798      	blx	r3
 810c26e:	4603      	mov	r3, r0
 810c270:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 810c272:	e004      	b.n	810c27e <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 810c274:	2303      	movs	r3, #3
 810c276:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 810c278:	e001      	b.n	810c27e <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 810c27a:	2303      	movs	r3, #3
 810c27c:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 810c27e:	683b      	ldr	r3, [r7, #0]
 810c280:	88db      	ldrh	r3, [r3, #6]
 810c282:	2b00      	cmp	r3, #0
 810c284:	d110      	bne.n	810c2a8 <USBD_StdItfReq+0xc0>
 810c286:	7bfb      	ldrb	r3, [r7, #15]
 810c288:	2b00      	cmp	r3, #0
 810c28a:	d10d      	bne.n	810c2a8 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 810c28c:	6878      	ldr	r0, [r7, #4]
 810c28e:	f000 fdfd 	bl	810ce8c <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 810c292:	e009      	b.n	810c2a8 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 810c294:	6839      	ldr	r1, [r7, #0]
 810c296:	6878      	ldr	r0, [r7, #4]
 810c298:	f000 fd21 	bl	810ccde <USBD_CtlError>
          break;
 810c29c:	e004      	b.n	810c2a8 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 810c29e:	6839      	ldr	r1, [r7, #0]
 810c2a0:	6878      	ldr	r0, [r7, #4]
 810c2a2:	f000 fd1c 	bl	810ccde <USBD_CtlError>
          break;
 810c2a6:	e000      	b.n	810c2aa <USBD_StdItfReq+0xc2>
          break;
 810c2a8:	bf00      	nop
      }
      break;
 810c2aa:	e004      	b.n	810c2b6 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 810c2ac:	6839      	ldr	r1, [r7, #0]
 810c2ae:	6878      	ldr	r0, [r7, #4]
 810c2b0:	f000 fd15 	bl	810ccde <USBD_CtlError>
      break;
 810c2b4:	bf00      	nop
  }

  return ret;
 810c2b6:	7bfb      	ldrb	r3, [r7, #15]
}
 810c2b8:	4618      	mov	r0, r3
 810c2ba:	3710      	adds	r7, #16
 810c2bc:	46bd      	mov	sp, r7
 810c2be:	bd80      	pop	{r7, pc}

0810c2c0 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c2c0:	b580      	push	{r7, lr}
 810c2c2:	b084      	sub	sp, #16
 810c2c4:	af00      	add	r7, sp, #0
 810c2c6:	6078      	str	r0, [r7, #4]
 810c2c8:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 810c2ca:	2300      	movs	r3, #0
 810c2cc:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 810c2ce:	683b      	ldr	r3, [r7, #0]
 810c2d0:	889b      	ldrh	r3, [r3, #4]
 810c2d2:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810c2d4:	683b      	ldr	r3, [r7, #0]
 810c2d6:	781b      	ldrb	r3, [r3, #0]
 810c2d8:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 810c2dc:	2b40      	cmp	r3, #64	@ 0x40
 810c2de:	d007      	beq.n	810c2f0 <USBD_StdEPReq+0x30>
 810c2e0:	2b40      	cmp	r3, #64	@ 0x40
 810c2e2:	f200 817f 	bhi.w	810c5e4 <USBD_StdEPReq+0x324>
 810c2e6:	2b00      	cmp	r3, #0
 810c2e8:	d02a      	beq.n	810c340 <USBD_StdEPReq+0x80>
 810c2ea:	2b20      	cmp	r3, #32
 810c2ec:	f040 817a 	bne.w	810c5e4 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 810c2f0:	7bbb      	ldrb	r3, [r7, #14]
 810c2f2:	4619      	mov	r1, r3
 810c2f4:	6878      	ldr	r0, [r7, #4]
 810c2f6:	f7ff fe85 	bl	810c004 <USBD_CoreFindEP>
 810c2fa:	4603      	mov	r3, r0
 810c2fc:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810c2fe:	7b7b      	ldrb	r3, [r7, #13]
 810c300:	2bff      	cmp	r3, #255	@ 0xff
 810c302:	f000 8174 	beq.w	810c5ee <USBD_StdEPReq+0x32e>
 810c306:	7b7b      	ldrb	r3, [r7, #13]
 810c308:	2b00      	cmp	r3, #0
 810c30a:	f040 8170 	bne.w	810c5ee <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 810c30e:	7b7a      	ldrb	r2, [r7, #13]
 810c310:	687b      	ldr	r3, [r7, #4]
 810c312:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 810c316:	7b7a      	ldrb	r2, [r7, #13]
 810c318:	687b      	ldr	r3, [r7, #4]
 810c31a:	32ae      	adds	r2, #174	@ 0xae
 810c31c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c320:	689b      	ldr	r3, [r3, #8]
 810c322:	2b00      	cmp	r3, #0
 810c324:	f000 8163 	beq.w	810c5ee <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 810c328:	7b7a      	ldrb	r2, [r7, #13]
 810c32a:	687b      	ldr	r3, [r7, #4]
 810c32c:	32ae      	adds	r2, #174	@ 0xae
 810c32e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c332:	689b      	ldr	r3, [r3, #8]
 810c334:	6839      	ldr	r1, [r7, #0]
 810c336:	6878      	ldr	r0, [r7, #4]
 810c338:	4798      	blx	r3
 810c33a:	4603      	mov	r3, r0
 810c33c:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 810c33e:	e156      	b.n	810c5ee <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810c340:	683b      	ldr	r3, [r7, #0]
 810c342:	785b      	ldrb	r3, [r3, #1]
 810c344:	2b03      	cmp	r3, #3
 810c346:	d008      	beq.n	810c35a <USBD_StdEPReq+0x9a>
 810c348:	2b03      	cmp	r3, #3
 810c34a:	f300 8145 	bgt.w	810c5d8 <USBD_StdEPReq+0x318>
 810c34e:	2b00      	cmp	r3, #0
 810c350:	f000 809b 	beq.w	810c48a <USBD_StdEPReq+0x1ca>
 810c354:	2b01      	cmp	r3, #1
 810c356:	d03c      	beq.n	810c3d2 <USBD_StdEPReq+0x112>
 810c358:	e13e      	b.n	810c5d8 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 810c35a:	687b      	ldr	r3, [r7, #4]
 810c35c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c360:	b2db      	uxtb	r3, r3
 810c362:	2b02      	cmp	r3, #2
 810c364:	d002      	beq.n	810c36c <USBD_StdEPReq+0xac>
 810c366:	2b03      	cmp	r3, #3
 810c368:	d016      	beq.n	810c398 <USBD_StdEPReq+0xd8>
 810c36a:	e02c      	b.n	810c3c6 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810c36c:	7bbb      	ldrb	r3, [r7, #14]
 810c36e:	2b00      	cmp	r3, #0
 810c370:	d00d      	beq.n	810c38e <USBD_StdEPReq+0xce>
 810c372:	7bbb      	ldrb	r3, [r7, #14]
 810c374:	2b80      	cmp	r3, #128	@ 0x80
 810c376:	d00a      	beq.n	810c38e <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 810c378:	7bbb      	ldrb	r3, [r7, #14]
 810c37a:	4619      	mov	r1, r3
 810c37c:	6878      	ldr	r0, [r7, #4]
 810c37e:	f001 f9b3 	bl	810d6e8 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 810c382:	2180      	movs	r1, #128	@ 0x80
 810c384:	6878      	ldr	r0, [r7, #4]
 810c386:	f001 f9af 	bl	810d6e8 <USBD_LL_StallEP>
 810c38a:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 810c38c:	e020      	b.n	810c3d0 <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 810c38e:	6839      	ldr	r1, [r7, #0]
 810c390:	6878      	ldr	r0, [r7, #4]
 810c392:	f000 fca4 	bl	810ccde <USBD_CtlError>
              break;
 810c396:	e01b      	b.n	810c3d0 <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 810c398:	683b      	ldr	r3, [r7, #0]
 810c39a:	885b      	ldrh	r3, [r3, #2]
 810c39c:	2b00      	cmp	r3, #0
 810c39e:	d10e      	bne.n	810c3be <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 810c3a0:	7bbb      	ldrb	r3, [r7, #14]
 810c3a2:	2b00      	cmp	r3, #0
 810c3a4:	d00b      	beq.n	810c3be <USBD_StdEPReq+0xfe>
 810c3a6:	7bbb      	ldrb	r3, [r7, #14]
 810c3a8:	2b80      	cmp	r3, #128	@ 0x80
 810c3aa:	d008      	beq.n	810c3be <USBD_StdEPReq+0xfe>
 810c3ac:	683b      	ldr	r3, [r7, #0]
 810c3ae:	88db      	ldrh	r3, [r3, #6]
 810c3b0:	2b00      	cmp	r3, #0
 810c3b2:	d104      	bne.n	810c3be <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 810c3b4:	7bbb      	ldrb	r3, [r7, #14]
 810c3b6:	4619      	mov	r1, r3
 810c3b8:	6878      	ldr	r0, [r7, #4]
 810c3ba:	f001 f995 	bl	810d6e8 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 810c3be:	6878      	ldr	r0, [r7, #4]
 810c3c0:	f000 fd64 	bl	810ce8c <USBD_CtlSendStatus>

              break;
 810c3c4:	e004      	b.n	810c3d0 <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 810c3c6:	6839      	ldr	r1, [r7, #0]
 810c3c8:	6878      	ldr	r0, [r7, #4]
 810c3ca:	f000 fc88 	bl	810ccde <USBD_CtlError>
              break;
 810c3ce:	bf00      	nop
          }
          break;
 810c3d0:	e107      	b.n	810c5e2 <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 810c3d2:	687b      	ldr	r3, [r7, #4]
 810c3d4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c3d8:	b2db      	uxtb	r3, r3
 810c3da:	2b02      	cmp	r3, #2
 810c3dc:	d002      	beq.n	810c3e4 <USBD_StdEPReq+0x124>
 810c3de:	2b03      	cmp	r3, #3
 810c3e0:	d016      	beq.n	810c410 <USBD_StdEPReq+0x150>
 810c3e2:	e04b      	b.n	810c47c <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810c3e4:	7bbb      	ldrb	r3, [r7, #14]
 810c3e6:	2b00      	cmp	r3, #0
 810c3e8:	d00d      	beq.n	810c406 <USBD_StdEPReq+0x146>
 810c3ea:	7bbb      	ldrb	r3, [r7, #14]
 810c3ec:	2b80      	cmp	r3, #128	@ 0x80
 810c3ee:	d00a      	beq.n	810c406 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 810c3f0:	7bbb      	ldrb	r3, [r7, #14]
 810c3f2:	4619      	mov	r1, r3
 810c3f4:	6878      	ldr	r0, [r7, #4]
 810c3f6:	f001 f977 	bl	810d6e8 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 810c3fa:	2180      	movs	r1, #128	@ 0x80
 810c3fc:	6878      	ldr	r0, [r7, #4]
 810c3fe:	f001 f973 	bl	810d6e8 <USBD_LL_StallEP>
 810c402:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 810c404:	e040      	b.n	810c488 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 810c406:	6839      	ldr	r1, [r7, #0]
 810c408:	6878      	ldr	r0, [r7, #4]
 810c40a:	f000 fc68 	bl	810ccde <USBD_CtlError>
              break;
 810c40e:	e03b      	b.n	810c488 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 810c410:	683b      	ldr	r3, [r7, #0]
 810c412:	885b      	ldrh	r3, [r3, #2]
 810c414:	2b00      	cmp	r3, #0
 810c416:	d136      	bne.n	810c486 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 810c418:	7bbb      	ldrb	r3, [r7, #14]
 810c41a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810c41e:	2b00      	cmp	r3, #0
 810c420:	d004      	beq.n	810c42c <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 810c422:	7bbb      	ldrb	r3, [r7, #14]
 810c424:	4619      	mov	r1, r3
 810c426:	6878      	ldr	r0, [r7, #4]
 810c428:	f001 f97d 	bl	810d726 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 810c42c:	6878      	ldr	r0, [r7, #4]
 810c42e:	f000 fd2d 	bl	810ce8c <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 810c432:	7bbb      	ldrb	r3, [r7, #14]
 810c434:	4619      	mov	r1, r3
 810c436:	6878      	ldr	r0, [r7, #4]
 810c438:	f7ff fde4 	bl	810c004 <USBD_CoreFindEP>
 810c43c:	4603      	mov	r3, r0
 810c43e:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810c440:	7b7b      	ldrb	r3, [r7, #13]
 810c442:	2bff      	cmp	r3, #255	@ 0xff
 810c444:	d01f      	beq.n	810c486 <USBD_StdEPReq+0x1c6>
 810c446:	7b7b      	ldrb	r3, [r7, #13]
 810c448:	2b00      	cmp	r3, #0
 810c44a:	d11c      	bne.n	810c486 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 810c44c:	7b7a      	ldrb	r2, [r7, #13]
 810c44e:	687b      	ldr	r3, [r7, #4]
 810c450:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 810c454:	7b7a      	ldrb	r2, [r7, #13]
 810c456:	687b      	ldr	r3, [r7, #4]
 810c458:	32ae      	adds	r2, #174	@ 0xae
 810c45a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c45e:	689b      	ldr	r3, [r3, #8]
 810c460:	2b00      	cmp	r3, #0
 810c462:	d010      	beq.n	810c486 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 810c464:	7b7a      	ldrb	r2, [r7, #13]
 810c466:	687b      	ldr	r3, [r7, #4]
 810c468:	32ae      	adds	r2, #174	@ 0xae
 810c46a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810c46e:	689b      	ldr	r3, [r3, #8]
 810c470:	6839      	ldr	r1, [r7, #0]
 810c472:	6878      	ldr	r0, [r7, #4]
 810c474:	4798      	blx	r3
 810c476:	4603      	mov	r3, r0
 810c478:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 810c47a:	e004      	b.n	810c486 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 810c47c:	6839      	ldr	r1, [r7, #0]
 810c47e:	6878      	ldr	r0, [r7, #4]
 810c480:	f000 fc2d 	bl	810ccde <USBD_CtlError>
              break;
 810c484:	e000      	b.n	810c488 <USBD_StdEPReq+0x1c8>
              break;
 810c486:	bf00      	nop
          }
          break;
 810c488:	e0ab      	b.n	810c5e2 <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 810c48a:	687b      	ldr	r3, [r7, #4]
 810c48c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c490:	b2db      	uxtb	r3, r3
 810c492:	2b02      	cmp	r3, #2
 810c494:	d002      	beq.n	810c49c <USBD_StdEPReq+0x1dc>
 810c496:	2b03      	cmp	r3, #3
 810c498:	d032      	beq.n	810c500 <USBD_StdEPReq+0x240>
 810c49a:	e097      	b.n	810c5cc <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810c49c:	7bbb      	ldrb	r3, [r7, #14]
 810c49e:	2b00      	cmp	r3, #0
 810c4a0:	d007      	beq.n	810c4b2 <USBD_StdEPReq+0x1f2>
 810c4a2:	7bbb      	ldrb	r3, [r7, #14]
 810c4a4:	2b80      	cmp	r3, #128	@ 0x80
 810c4a6:	d004      	beq.n	810c4b2 <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 810c4a8:	6839      	ldr	r1, [r7, #0]
 810c4aa:	6878      	ldr	r0, [r7, #4]
 810c4ac:	f000 fc17 	bl	810ccde <USBD_CtlError>
                break;
 810c4b0:	e091      	b.n	810c5d6 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810c4b2:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810c4b6:	2b00      	cmp	r3, #0
 810c4b8:	da0b      	bge.n	810c4d2 <USBD_StdEPReq+0x212>
 810c4ba:	7bbb      	ldrb	r3, [r7, #14]
 810c4bc:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 810c4c0:	4613      	mov	r3, r2
 810c4c2:	009b      	lsls	r3, r3, #2
 810c4c4:	4413      	add	r3, r2
 810c4c6:	009b      	lsls	r3, r3, #2
 810c4c8:	3310      	adds	r3, #16
 810c4ca:	687a      	ldr	r2, [r7, #4]
 810c4cc:	4413      	add	r3, r2
 810c4ce:	3304      	adds	r3, #4
 810c4d0:	e00b      	b.n	810c4ea <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 810c4d2:	7bbb      	ldrb	r3, [r7, #14]
 810c4d4:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810c4d8:	4613      	mov	r3, r2
 810c4da:	009b      	lsls	r3, r3, #2
 810c4dc:	4413      	add	r3, r2
 810c4de:	009b      	lsls	r3, r3, #2
 810c4e0:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 810c4e4:	687a      	ldr	r2, [r7, #4]
 810c4e6:	4413      	add	r3, r2
 810c4e8:	3304      	adds	r3, #4
 810c4ea:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 810c4ec:	68bb      	ldr	r3, [r7, #8]
 810c4ee:	2200      	movs	r2, #0
 810c4f0:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 810c4f2:	68bb      	ldr	r3, [r7, #8]
 810c4f4:	2202      	movs	r2, #2
 810c4f6:	4619      	mov	r1, r3
 810c4f8:	6878      	ldr	r0, [r7, #4]
 810c4fa:	f000 fc6d 	bl	810cdd8 <USBD_CtlSendData>
              break;
 810c4fe:	e06a      	b.n	810c5d6 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 810c500:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810c504:	2b00      	cmp	r3, #0
 810c506:	da11      	bge.n	810c52c <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 810c508:	7bbb      	ldrb	r3, [r7, #14]
 810c50a:	f003 020f 	and.w	r2, r3, #15
 810c50e:	6879      	ldr	r1, [r7, #4]
 810c510:	4613      	mov	r3, r2
 810c512:	009b      	lsls	r3, r3, #2
 810c514:	4413      	add	r3, r2
 810c516:	009b      	lsls	r3, r3, #2
 810c518:	440b      	add	r3, r1
 810c51a:	3324      	adds	r3, #36	@ 0x24
 810c51c:	881b      	ldrh	r3, [r3, #0]
 810c51e:	2b00      	cmp	r3, #0
 810c520:	d117      	bne.n	810c552 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 810c522:	6839      	ldr	r1, [r7, #0]
 810c524:	6878      	ldr	r0, [r7, #4]
 810c526:	f000 fbda 	bl	810ccde <USBD_CtlError>
                  break;
 810c52a:	e054      	b.n	810c5d6 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 810c52c:	7bbb      	ldrb	r3, [r7, #14]
 810c52e:	f003 020f 	and.w	r2, r3, #15
 810c532:	6879      	ldr	r1, [r7, #4]
 810c534:	4613      	mov	r3, r2
 810c536:	009b      	lsls	r3, r3, #2
 810c538:	4413      	add	r3, r2
 810c53a:	009b      	lsls	r3, r3, #2
 810c53c:	440b      	add	r3, r1
 810c53e:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 810c542:	881b      	ldrh	r3, [r3, #0]
 810c544:	2b00      	cmp	r3, #0
 810c546:	d104      	bne.n	810c552 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 810c548:	6839      	ldr	r1, [r7, #0]
 810c54a:	6878      	ldr	r0, [r7, #4]
 810c54c:	f000 fbc7 	bl	810ccde <USBD_CtlError>
                  break;
 810c550:	e041      	b.n	810c5d6 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810c552:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810c556:	2b00      	cmp	r3, #0
 810c558:	da0b      	bge.n	810c572 <USBD_StdEPReq+0x2b2>
 810c55a:	7bbb      	ldrb	r3, [r7, #14]
 810c55c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 810c560:	4613      	mov	r3, r2
 810c562:	009b      	lsls	r3, r3, #2
 810c564:	4413      	add	r3, r2
 810c566:	009b      	lsls	r3, r3, #2
 810c568:	3310      	adds	r3, #16
 810c56a:	687a      	ldr	r2, [r7, #4]
 810c56c:	4413      	add	r3, r2
 810c56e:	3304      	adds	r3, #4
 810c570:	e00b      	b.n	810c58a <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 810c572:	7bbb      	ldrb	r3, [r7, #14]
 810c574:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810c578:	4613      	mov	r3, r2
 810c57a:	009b      	lsls	r3, r3, #2
 810c57c:	4413      	add	r3, r2
 810c57e:	009b      	lsls	r3, r3, #2
 810c580:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 810c584:	687a      	ldr	r2, [r7, #4]
 810c586:	4413      	add	r3, r2
 810c588:	3304      	adds	r3, #4
 810c58a:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 810c58c:	7bbb      	ldrb	r3, [r7, #14]
 810c58e:	2b00      	cmp	r3, #0
 810c590:	d002      	beq.n	810c598 <USBD_StdEPReq+0x2d8>
 810c592:	7bbb      	ldrb	r3, [r7, #14]
 810c594:	2b80      	cmp	r3, #128	@ 0x80
 810c596:	d103      	bne.n	810c5a0 <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 810c598:	68bb      	ldr	r3, [r7, #8]
 810c59a:	2200      	movs	r2, #0
 810c59c:	601a      	str	r2, [r3, #0]
 810c59e:	e00e      	b.n	810c5be <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 810c5a0:	7bbb      	ldrb	r3, [r7, #14]
 810c5a2:	4619      	mov	r1, r3
 810c5a4:	6878      	ldr	r0, [r7, #4]
 810c5a6:	f001 f8dd 	bl	810d764 <USBD_LL_IsStallEP>
 810c5aa:	4603      	mov	r3, r0
 810c5ac:	2b00      	cmp	r3, #0
 810c5ae:	d003      	beq.n	810c5b8 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 810c5b0:	68bb      	ldr	r3, [r7, #8]
 810c5b2:	2201      	movs	r2, #1
 810c5b4:	601a      	str	r2, [r3, #0]
 810c5b6:	e002      	b.n	810c5be <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 810c5b8:	68bb      	ldr	r3, [r7, #8]
 810c5ba:	2200      	movs	r2, #0
 810c5bc:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 810c5be:	68bb      	ldr	r3, [r7, #8]
 810c5c0:	2202      	movs	r2, #2
 810c5c2:	4619      	mov	r1, r3
 810c5c4:	6878      	ldr	r0, [r7, #4]
 810c5c6:	f000 fc07 	bl	810cdd8 <USBD_CtlSendData>
              break;
 810c5ca:	e004      	b.n	810c5d6 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 810c5cc:	6839      	ldr	r1, [r7, #0]
 810c5ce:	6878      	ldr	r0, [r7, #4]
 810c5d0:	f000 fb85 	bl	810ccde <USBD_CtlError>
              break;
 810c5d4:	bf00      	nop
          }
          break;
 810c5d6:	e004      	b.n	810c5e2 <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 810c5d8:	6839      	ldr	r1, [r7, #0]
 810c5da:	6878      	ldr	r0, [r7, #4]
 810c5dc:	f000 fb7f 	bl	810ccde <USBD_CtlError>
          break;
 810c5e0:	bf00      	nop
      }
      break;
 810c5e2:	e005      	b.n	810c5f0 <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 810c5e4:	6839      	ldr	r1, [r7, #0]
 810c5e6:	6878      	ldr	r0, [r7, #4]
 810c5e8:	f000 fb79 	bl	810ccde <USBD_CtlError>
      break;
 810c5ec:	e000      	b.n	810c5f0 <USBD_StdEPReq+0x330>
      break;
 810c5ee:	bf00      	nop
  }

  return ret;
 810c5f0:	7bfb      	ldrb	r3, [r7, #15]
}
 810c5f2:	4618      	mov	r0, r3
 810c5f4:	3710      	adds	r7, #16
 810c5f6:	46bd      	mov	sp, r7
 810c5f8:	bd80      	pop	{r7, pc}
	...

0810c5fc <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c5fc:	b580      	push	{r7, lr}
 810c5fe:	b084      	sub	sp, #16
 810c600:	af00      	add	r7, sp, #0
 810c602:	6078      	str	r0, [r7, #4]
 810c604:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 810c606:	2300      	movs	r3, #0
 810c608:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 810c60a:	2300      	movs	r3, #0
 810c60c:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 810c60e:	2300      	movs	r3, #0
 810c610:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 810c612:	683b      	ldr	r3, [r7, #0]
 810c614:	885b      	ldrh	r3, [r3, #2]
 810c616:	0a1b      	lsrs	r3, r3, #8
 810c618:	b29b      	uxth	r3, r3
 810c61a:	3b01      	subs	r3, #1
 810c61c:	2b0e      	cmp	r3, #14
 810c61e:	f200 8152 	bhi.w	810c8c6 <USBD_GetDescriptor+0x2ca>
 810c622:	a201      	add	r2, pc, #4	@ (adr r2, 810c628 <USBD_GetDescriptor+0x2c>)
 810c624:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810c628:	0810c699 	.word	0x0810c699
 810c62c:	0810c6b1 	.word	0x0810c6b1
 810c630:	0810c6f1 	.word	0x0810c6f1
 810c634:	0810c8c7 	.word	0x0810c8c7
 810c638:	0810c8c7 	.word	0x0810c8c7
 810c63c:	0810c867 	.word	0x0810c867
 810c640:	0810c893 	.word	0x0810c893
 810c644:	0810c8c7 	.word	0x0810c8c7
 810c648:	0810c8c7 	.word	0x0810c8c7
 810c64c:	0810c8c7 	.word	0x0810c8c7
 810c650:	0810c8c7 	.word	0x0810c8c7
 810c654:	0810c8c7 	.word	0x0810c8c7
 810c658:	0810c8c7 	.word	0x0810c8c7
 810c65c:	0810c8c7 	.word	0x0810c8c7
 810c660:	0810c665 	.word	0x0810c665
  {
#if ((USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U))
    case USB_DESC_TYPE_BOS:
      if (pdev->pDesc->GetBOSDescriptor != NULL)
 810c664:	687b      	ldr	r3, [r7, #4]
 810c666:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c66a:	69db      	ldr	r3, [r3, #28]
 810c66c:	2b00      	cmp	r3, #0
 810c66e:	d00b      	beq.n	810c688 <USBD_GetDescriptor+0x8c>
      {
        pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 810c670:	687b      	ldr	r3, [r7, #4]
 810c672:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c676:	69db      	ldr	r3, [r3, #28]
 810c678:	687a      	ldr	r2, [r7, #4]
 810c67a:	7c12      	ldrb	r2, [r2, #16]
 810c67c:	f107 0108 	add.w	r1, r7, #8
 810c680:	4610      	mov	r0, r2
 810c682:	4798      	blx	r3
 810c684:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810c686:	e126      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810c688:	6839      	ldr	r1, [r7, #0]
 810c68a:	6878      	ldr	r0, [r7, #4]
 810c68c:	f000 fb27 	bl	810ccde <USBD_CtlError>
        err++;
 810c690:	7afb      	ldrb	r3, [r7, #11]
 810c692:	3301      	adds	r3, #1
 810c694:	72fb      	strb	r3, [r7, #11]
      break;
 810c696:	e11e      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 810c698:	687b      	ldr	r3, [r7, #4]
 810c69a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c69e:	681b      	ldr	r3, [r3, #0]
 810c6a0:	687a      	ldr	r2, [r7, #4]
 810c6a2:	7c12      	ldrb	r2, [r2, #16]
 810c6a4:	f107 0108 	add.w	r1, r7, #8
 810c6a8:	4610      	mov	r0, r2
 810c6aa:	4798      	blx	r3
 810c6ac:	60f8      	str	r0, [r7, #12]
      break;
 810c6ae:	e112      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810c6b0:	687b      	ldr	r3, [r7, #4]
 810c6b2:	7c1b      	ldrb	r3, [r3, #16]
 810c6b4:	2b00      	cmp	r3, #0
 810c6b6:	d10d      	bne.n	810c6d4 <USBD_GetDescriptor+0xd8>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 810c6b8:	687b      	ldr	r3, [r7, #4]
 810c6ba:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810c6be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810c6c0:	f107 0208 	add.w	r2, r7, #8
 810c6c4:	4610      	mov	r0, r2
 810c6c6:	4798      	blx	r3
 810c6c8:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 810c6ca:	68fb      	ldr	r3, [r7, #12]
 810c6cc:	3301      	adds	r3, #1
 810c6ce:	2202      	movs	r2, #2
 810c6d0:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 810c6d2:	e100      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 810c6d4:	687b      	ldr	r3, [r7, #4]
 810c6d6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810c6da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c6dc:	f107 0208 	add.w	r2, r7, #8
 810c6e0:	4610      	mov	r0, r2
 810c6e2:	4798      	blx	r3
 810c6e4:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 810c6e6:	68fb      	ldr	r3, [r7, #12]
 810c6e8:	3301      	adds	r3, #1
 810c6ea:	2202      	movs	r2, #2
 810c6ec:	701a      	strb	r2, [r3, #0]
      break;
 810c6ee:	e0f2      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 810c6f0:	683b      	ldr	r3, [r7, #0]
 810c6f2:	885b      	ldrh	r3, [r3, #2]
 810c6f4:	b2db      	uxtb	r3, r3
 810c6f6:	2b05      	cmp	r3, #5
 810c6f8:	f200 80ac 	bhi.w	810c854 <USBD_GetDescriptor+0x258>
 810c6fc:	a201      	add	r2, pc, #4	@ (adr r2, 810c704 <USBD_GetDescriptor+0x108>)
 810c6fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810c702:	bf00      	nop
 810c704:	0810c71d 	.word	0x0810c71d
 810c708:	0810c751 	.word	0x0810c751
 810c70c:	0810c785 	.word	0x0810c785
 810c710:	0810c7b9 	.word	0x0810c7b9
 810c714:	0810c7ed 	.word	0x0810c7ed
 810c718:	0810c821 	.word	0x0810c821
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 810c71c:	687b      	ldr	r3, [r7, #4]
 810c71e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c722:	685b      	ldr	r3, [r3, #4]
 810c724:	2b00      	cmp	r3, #0
 810c726:	d00b      	beq.n	810c740 <USBD_GetDescriptor+0x144>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 810c728:	687b      	ldr	r3, [r7, #4]
 810c72a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c72e:	685b      	ldr	r3, [r3, #4]
 810c730:	687a      	ldr	r2, [r7, #4]
 810c732:	7c12      	ldrb	r2, [r2, #16]
 810c734:	f107 0108 	add.w	r1, r7, #8
 810c738:	4610      	mov	r0, r2
 810c73a:	4798      	blx	r3
 810c73c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c73e:	e091      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c740:	6839      	ldr	r1, [r7, #0]
 810c742:	6878      	ldr	r0, [r7, #4]
 810c744:	f000 facb 	bl	810ccde <USBD_CtlError>
            err++;
 810c748:	7afb      	ldrb	r3, [r7, #11]
 810c74a:	3301      	adds	r3, #1
 810c74c:	72fb      	strb	r3, [r7, #11]
          break;
 810c74e:	e089      	b.n	810c864 <USBD_GetDescriptor+0x268>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 810c750:	687b      	ldr	r3, [r7, #4]
 810c752:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c756:	689b      	ldr	r3, [r3, #8]
 810c758:	2b00      	cmp	r3, #0
 810c75a:	d00b      	beq.n	810c774 <USBD_GetDescriptor+0x178>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 810c75c:	687b      	ldr	r3, [r7, #4]
 810c75e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c762:	689b      	ldr	r3, [r3, #8]
 810c764:	687a      	ldr	r2, [r7, #4]
 810c766:	7c12      	ldrb	r2, [r2, #16]
 810c768:	f107 0108 	add.w	r1, r7, #8
 810c76c:	4610      	mov	r0, r2
 810c76e:	4798      	blx	r3
 810c770:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c772:	e077      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c774:	6839      	ldr	r1, [r7, #0]
 810c776:	6878      	ldr	r0, [r7, #4]
 810c778:	f000 fab1 	bl	810ccde <USBD_CtlError>
            err++;
 810c77c:	7afb      	ldrb	r3, [r7, #11]
 810c77e:	3301      	adds	r3, #1
 810c780:	72fb      	strb	r3, [r7, #11]
          break;
 810c782:	e06f      	b.n	810c864 <USBD_GetDescriptor+0x268>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 810c784:	687b      	ldr	r3, [r7, #4]
 810c786:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c78a:	68db      	ldr	r3, [r3, #12]
 810c78c:	2b00      	cmp	r3, #0
 810c78e:	d00b      	beq.n	810c7a8 <USBD_GetDescriptor+0x1ac>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 810c790:	687b      	ldr	r3, [r7, #4]
 810c792:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c796:	68db      	ldr	r3, [r3, #12]
 810c798:	687a      	ldr	r2, [r7, #4]
 810c79a:	7c12      	ldrb	r2, [r2, #16]
 810c79c:	f107 0108 	add.w	r1, r7, #8
 810c7a0:	4610      	mov	r0, r2
 810c7a2:	4798      	blx	r3
 810c7a4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c7a6:	e05d      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c7a8:	6839      	ldr	r1, [r7, #0]
 810c7aa:	6878      	ldr	r0, [r7, #4]
 810c7ac:	f000 fa97 	bl	810ccde <USBD_CtlError>
            err++;
 810c7b0:	7afb      	ldrb	r3, [r7, #11]
 810c7b2:	3301      	adds	r3, #1
 810c7b4:	72fb      	strb	r3, [r7, #11]
          break;
 810c7b6:	e055      	b.n	810c864 <USBD_GetDescriptor+0x268>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 810c7b8:	687b      	ldr	r3, [r7, #4]
 810c7ba:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c7be:	691b      	ldr	r3, [r3, #16]
 810c7c0:	2b00      	cmp	r3, #0
 810c7c2:	d00b      	beq.n	810c7dc <USBD_GetDescriptor+0x1e0>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 810c7c4:	687b      	ldr	r3, [r7, #4]
 810c7c6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c7ca:	691b      	ldr	r3, [r3, #16]
 810c7cc:	687a      	ldr	r2, [r7, #4]
 810c7ce:	7c12      	ldrb	r2, [r2, #16]
 810c7d0:	f107 0108 	add.w	r1, r7, #8
 810c7d4:	4610      	mov	r0, r2
 810c7d6:	4798      	blx	r3
 810c7d8:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c7da:	e043      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c7dc:	6839      	ldr	r1, [r7, #0]
 810c7de:	6878      	ldr	r0, [r7, #4]
 810c7e0:	f000 fa7d 	bl	810ccde <USBD_CtlError>
            err++;
 810c7e4:	7afb      	ldrb	r3, [r7, #11]
 810c7e6:	3301      	adds	r3, #1
 810c7e8:	72fb      	strb	r3, [r7, #11]
          break;
 810c7ea:	e03b      	b.n	810c864 <USBD_GetDescriptor+0x268>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 810c7ec:	687b      	ldr	r3, [r7, #4]
 810c7ee:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c7f2:	695b      	ldr	r3, [r3, #20]
 810c7f4:	2b00      	cmp	r3, #0
 810c7f6:	d00b      	beq.n	810c810 <USBD_GetDescriptor+0x214>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 810c7f8:	687b      	ldr	r3, [r7, #4]
 810c7fa:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c7fe:	695b      	ldr	r3, [r3, #20]
 810c800:	687a      	ldr	r2, [r7, #4]
 810c802:	7c12      	ldrb	r2, [r2, #16]
 810c804:	f107 0108 	add.w	r1, r7, #8
 810c808:	4610      	mov	r0, r2
 810c80a:	4798      	blx	r3
 810c80c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c80e:	e029      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c810:	6839      	ldr	r1, [r7, #0]
 810c812:	6878      	ldr	r0, [r7, #4]
 810c814:	f000 fa63 	bl	810ccde <USBD_CtlError>
            err++;
 810c818:	7afb      	ldrb	r3, [r7, #11]
 810c81a:	3301      	adds	r3, #1
 810c81c:	72fb      	strb	r3, [r7, #11]
          break;
 810c81e:	e021      	b.n	810c864 <USBD_GetDescriptor+0x268>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 810c820:	687b      	ldr	r3, [r7, #4]
 810c822:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c826:	699b      	ldr	r3, [r3, #24]
 810c828:	2b00      	cmp	r3, #0
 810c82a:	d00b      	beq.n	810c844 <USBD_GetDescriptor+0x248>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 810c82c:	687b      	ldr	r3, [r7, #4]
 810c82e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 810c832:	699b      	ldr	r3, [r3, #24]
 810c834:	687a      	ldr	r2, [r7, #4]
 810c836:	7c12      	ldrb	r2, [r2, #16]
 810c838:	f107 0108 	add.w	r1, r7, #8
 810c83c:	4610      	mov	r0, r2
 810c83e:	4798      	blx	r3
 810c840:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810c842:	e00f      	b.n	810c864 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810c844:	6839      	ldr	r1, [r7, #0]
 810c846:	6878      	ldr	r0, [r7, #4]
 810c848:	f000 fa49 	bl	810ccde <USBD_CtlError>
            err++;
 810c84c:	7afb      	ldrb	r3, [r7, #11]
 810c84e:	3301      	adds	r3, #1
 810c850:	72fb      	strb	r3, [r7, #11]
          break;
 810c852:	e007      	b.n	810c864 <USBD_GetDescriptor+0x268>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 810c854:	6839      	ldr	r1, [r7, #0]
 810c856:	6878      	ldr	r0, [r7, #4]
 810c858:	f000 fa41 	bl	810ccde <USBD_CtlError>
          err++;
 810c85c:	7afb      	ldrb	r3, [r7, #11]
 810c85e:	3301      	adds	r3, #1
 810c860:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 810c862:	bf00      	nop
      }
      break;
 810c864:	e037      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810c866:	687b      	ldr	r3, [r7, #4]
 810c868:	7c1b      	ldrb	r3, [r3, #16]
 810c86a:	2b00      	cmp	r3, #0
 810c86c:	d109      	bne.n	810c882 <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 810c86e:	687b      	ldr	r3, [r7, #4]
 810c870:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810c874:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 810c876:	f107 0208 	add.w	r2, r7, #8
 810c87a:	4610      	mov	r0, r2
 810c87c:	4798      	blx	r3
 810c87e:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810c880:	e029      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810c882:	6839      	ldr	r1, [r7, #0]
 810c884:	6878      	ldr	r0, [r7, #4]
 810c886:	f000 fa2a 	bl	810ccde <USBD_CtlError>
        err++;
 810c88a:	7afb      	ldrb	r3, [r7, #11]
 810c88c:	3301      	adds	r3, #1
 810c88e:	72fb      	strb	r3, [r7, #11]
      break;
 810c890:	e021      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810c892:	687b      	ldr	r3, [r7, #4]
 810c894:	7c1b      	ldrb	r3, [r3, #16]
 810c896:	2b00      	cmp	r3, #0
 810c898:	d10d      	bne.n	810c8b6 <USBD_GetDescriptor+0x2ba>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 810c89a:	687b      	ldr	r3, [r7, #4]
 810c89c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 810c8a0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810c8a2:	f107 0208 	add.w	r2, r7, #8
 810c8a6:	4610      	mov	r0, r2
 810c8a8:	4798      	blx	r3
 810c8aa:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 810c8ac:	68fb      	ldr	r3, [r7, #12]
 810c8ae:	3301      	adds	r3, #1
 810c8b0:	2207      	movs	r2, #7
 810c8b2:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810c8b4:	e00f      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810c8b6:	6839      	ldr	r1, [r7, #0]
 810c8b8:	6878      	ldr	r0, [r7, #4]
 810c8ba:	f000 fa10 	bl	810ccde <USBD_CtlError>
        err++;
 810c8be:	7afb      	ldrb	r3, [r7, #11]
 810c8c0:	3301      	adds	r3, #1
 810c8c2:	72fb      	strb	r3, [r7, #11]
      break;
 810c8c4:	e007      	b.n	810c8d6 <USBD_GetDescriptor+0x2da>

    default:
      USBD_CtlError(pdev, req);
 810c8c6:	6839      	ldr	r1, [r7, #0]
 810c8c8:	6878      	ldr	r0, [r7, #4]
 810c8ca:	f000 fa08 	bl	810ccde <USBD_CtlError>
      err++;
 810c8ce:	7afb      	ldrb	r3, [r7, #11]
 810c8d0:	3301      	adds	r3, #1
 810c8d2:	72fb      	strb	r3, [r7, #11]
      break;
 810c8d4:	bf00      	nop
  }

  if (err != 0U)
 810c8d6:	7afb      	ldrb	r3, [r7, #11]
 810c8d8:	2b00      	cmp	r3, #0
 810c8da:	d11e      	bne.n	810c91a <USBD_GetDescriptor+0x31e>
  {
    return;
  }

  if (req->wLength != 0U)
 810c8dc:	683b      	ldr	r3, [r7, #0]
 810c8de:	88db      	ldrh	r3, [r3, #6]
 810c8e0:	2b00      	cmp	r3, #0
 810c8e2:	d016      	beq.n	810c912 <USBD_GetDescriptor+0x316>
  {
    if (len != 0U)
 810c8e4:	893b      	ldrh	r3, [r7, #8]
 810c8e6:	2b00      	cmp	r3, #0
 810c8e8:	d00e      	beq.n	810c908 <USBD_GetDescriptor+0x30c>
    {
      len = MIN(len, req->wLength);
 810c8ea:	683b      	ldr	r3, [r7, #0]
 810c8ec:	88da      	ldrh	r2, [r3, #6]
 810c8ee:	893b      	ldrh	r3, [r7, #8]
 810c8f0:	4293      	cmp	r3, r2
 810c8f2:	bf28      	it	cs
 810c8f4:	4613      	movcs	r3, r2
 810c8f6:	b29b      	uxth	r3, r3
 810c8f8:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 810c8fa:	893b      	ldrh	r3, [r7, #8]
 810c8fc:	461a      	mov	r2, r3
 810c8fe:	68f9      	ldr	r1, [r7, #12]
 810c900:	6878      	ldr	r0, [r7, #4]
 810c902:	f000 fa69 	bl	810cdd8 <USBD_CtlSendData>
 810c906:	e009      	b.n	810c91c <USBD_GetDescriptor+0x320>
    }
    else
    {
      USBD_CtlError(pdev, req);
 810c908:	6839      	ldr	r1, [r7, #0]
 810c90a:	6878      	ldr	r0, [r7, #4]
 810c90c:	f000 f9e7 	bl	810ccde <USBD_CtlError>
 810c910:	e004      	b.n	810c91c <USBD_GetDescriptor+0x320>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 810c912:	6878      	ldr	r0, [r7, #4]
 810c914:	f000 faba 	bl	810ce8c <USBD_CtlSendStatus>
 810c918:	e000      	b.n	810c91c <USBD_GetDescriptor+0x320>
    return;
 810c91a:	bf00      	nop
  }
}
 810c91c:	3710      	adds	r7, #16
 810c91e:	46bd      	mov	sp, r7
 810c920:	bd80      	pop	{r7, pc}
 810c922:	bf00      	nop

0810c924 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c924:	b580      	push	{r7, lr}
 810c926:	b084      	sub	sp, #16
 810c928:	af00      	add	r7, sp, #0
 810c92a:	6078      	str	r0, [r7, #4]
 810c92c:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 810c92e:	683b      	ldr	r3, [r7, #0]
 810c930:	889b      	ldrh	r3, [r3, #4]
 810c932:	2b00      	cmp	r3, #0
 810c934:	d131      	bne.n	810c99a <USBD_SetAddress+0x76>
 810c936:	683b      	ldr	r3, [r7, #0]
 810c938:	88db      	ldrh	r3, [r3, #6]
 810c93a:	2b00      	cmp	r3, #0
 810c93c:	d12d      	bne.n	810c99a <USBD_SetAddress+0x76>
 810c93e:	683b      	ldr	r3, [r7, #0]
 810c940:	885b      	ldrh	r3, [r3, #2]
 810c942:	2b7f      	cmp	r3, #127	@ 0x7f
 810c944:	d829      	bhi.n	810c99a <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 810c946:	683b      	ldr	r3, [r7, #0]
 810c948:	885b      	ldrh	r3, [r3, #2]
 810c94a:	b2db      	uxtb	r3, r3
 810c94c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810c950:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810c952:	687b      	ldr	r3, [r7, #4]
 810c954:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c958:	b2db      	uxtb	r3, r3
 810c95a:	2b03      	cmp	r3, #3
 810c95c:	d104      	bne.n	810c968 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 810c95e:	6839      	ldr	r1, [r7, #0]
 810c960:	6878      	ldr	r0, [r7, #4]
 810c962:	f000 f9bc 	bl	810ccde <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810c966:	e01d      	b.n	810c9a4 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 810c968:	687b      	ldr	r3, [r7, #4]
 810c96a:	7bfa      	ldrb	r2, [r7, #15]
 810c96c:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 810c970:	7bfb      	ldrb	r3, [r7, #15]
 810c972:	4619      	mov	r1, r3
 810c974:	6878      	ldr	r0, [r7, #4]
 810c976:	f000 ff21 	bl	810d7bc <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 810c97a:	6878      	ldr	r0, [r7, #4]
 810c97c:	f000 fa86 	bl	810ce8c <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 810c980:	7bfb      	ldrb	r3, [r7, #15]
 810c982:	2b00      	cmp	r3, #0
 810c984:	d004      	beq.n	810c990 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 810c986:	687b      	ldr	r3, [r7, #4]
 810c988:	2202      	movs	r2, #2
 810c98a:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810c98e:	e009      	b.n	810c9a4 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 810c990:	687b      	ldr	r3, [r7, #4]
 810c992:	2201      	movs	r2, #1
 810c994:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810c998:	e004      	b.n	810c9a4 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 810c99a:	6839      	ldr	r1, [r7, #0]
 810c99c:	6878      	ldr	r0, [r7, #4]
 810c99e:	f000 f99e 	bl	810ccde <USBD_CtlError>
  }
}
 810c9a2:	bf00      	nop
 810c9a4:	bf00      	nop
 810c9a6:	3710      	adds	r7, #16
 810c9a8:	46bd      	mov	sp, r7
 810c9aa:	bd80      	pop	{r7, pc}

0810c9ac <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810c9ac:	b580      	push	{r7, lr}
 810c9ae:	b084      	sub	sp, #16
 810c9b0:	af00      	add	r7, sp, #0
 810c9b2:	6078      	str	r0, [r7, #4]
 810c9b4:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810c9b6:	2300      	movs	r3, #0
 810c9b8:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 810c9ba:	683b      	ldr	r3, [r7, #0]
 810c9bc:	885b      	ldrh	r3, [r3, #2]
 810c9be:	b2da      	uxtb	r2, r3
 810c9c0:	4b4e      	ldr	r3, [pc, #312]	@ (810cafc <USBD_SetConfig+0x150>)
 810c9c2:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 810c9c4:	4b4d      	ldr	r3, [pc, #308]	@ (810cafc <USBD_SetConfig+0x150>)
 810c9c6:	781b      	ldrb	r3, [r3, #0]
 810c9c8:	2b01      	cmp	r3, #1
 810c9ca:	d905      	bls.n	810c9d8 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 810c9cc:	6839      	ldr	r1, [r7, #0]
 810c9ce:	6878      	ldr	r0, [r7, #4]
 810c9d0:	f000 f985 	bl	810ccde <USBD_CtlError>
    return USBD_FAIL;
 810c9d4:	2303      	movs	r3, #3
 810c9d6:	e08c      	b.n	810caf2 <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 810c9d8:	687b      	ldr	r3, [r7, #4]
 810c9da:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810c9de:	b2db      	uxtb	r3, r3
 810c9e0:	2b02      	cmp	r3, #2
 810c9e2:	d002      	beq.n	810c9ea <USBD_SetConfig+0x3e>
 810c9e4:	2b03      	cmp	r3, #3
 810c9e6:	d029      	beq.n	810ca3c <USBD_SetConfig+0x90>
 810c9e8:	e075      	b.n	810cad6 <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 810c9ea:	4b44      	ldr	r3, [pc, #272]	@ (810cafc <USBD_SetConfig+0x150>)
 810c9ec:	781b      	ldrb	r3, [r3, #0]
 810c9ee:	2b00      	cmp	r3, #0
 810c9f0:	d020      	beq.n	810ca34 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 810c9f2:	4b42      	ldr	r3, [pc, #264]	@ (810cafc <USBD_SetConfig+0x150>)
 810c9f4:	781b      	ldrb	r3, [r3, #0]
 810c9f6:	461a      	mov	r2, r3
 810c9f8:	687b      	ldr	r3, [r7, #4]
 810c9fa:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 810c9fc:	4b3f      	ldr	r3, [pc, #252]	@ (810cafc <USBD_SetConfig+0x150>)
 810c9fe:	781b      	ldrb	r3, [r3, #0]
 810ca00:	4619      	mov	r1, r3
 810ca02:	6878      	ldr	r0, [r7, #4]
 810ca04:	f7fe ffb9 	bl	810b97a <USBD_SetClassConfig>
 810ca08:	4603      	mov	r3, r0
 810ca0a:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 810ca0c:	7bfb      	ldrb	r3, [r7, #15]
 810ca0e:	2b00      	cmp	r3, #0
 810ca10:	d008      	beq.n	810ca24 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 810ca12:	6839      	ldr	r1, [r7, #0]
 810ca14:	6878      	ldr	r0, [r7, #4]
 810ca16:	f000 f962 	bl	810ccde <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 810ca1a:	687b      	ldr	r3, [r7, #4]
 810ca1c:	2202      	movs	r2, #2
 810ca1e:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 810ca22:	e065      	b.n	810caf0 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 810ca24:	6878      	ldr	r0, [r7, #4]
 810ca26:	f000 fa31 	bl	810ce8c <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 810ca2a:	687b      	ldr	r3, [r7, #4]
 810ca2c:	2203      	movs	r2, #3
 810ca2e:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 810ca32:	e05d      	b.n	810caf0 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 810ca34:	6878      	ldr	r0, [r7, #4]
 810ca36:	f000 fa29 	bl	810ce8c <USBD_CtlSendStatus>
      break;
 810ca3a:	e059      	b.n	810caf0 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 810ca3c:	4b2f      	ldr	r3, [pc, #188]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca3e:	781b      	ldrb	r3, [r3, #0]
 810ca40:	2b00      	cmp	r3, #0
 810ca42:	d112      	bne.n	810ca6a <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 810ca44:	687b      	ldr	r3, [r7, #4]
 810ca46:	2202      	movs	r2, #2
 810ca48:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 810ca4c:	4b2b      	ldr	r3, [pc, #172]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca4e:	781b      	ldrb	r3, [r3, #0]
 810ca50:	461a      	mov	r2, r3
 810ca52:	687b      	ldr	r3, [r7, #4]
 810ca54:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 810ca56:	4b29      	ldr	r3, [pc, #164]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca58:	781b      	ldrb	r3, [r3, #0]
 810ca5a:	4619      	mov	r1, r3
 810ca5c:	6878      	ldr	r0, [r7, #4]
 810ca5e:	f7fe ffa8 	bl	810b9b2 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 810ca62:	6878      	ldr	r0, [r7, #4]
 810ca64:	f000 fa12 	bl	810ce8c <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 810ca68:	e042      	b.n	810caf0 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 810ca6a:	4b24      	ldr	r3, [pc, #144]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca6c:	781b      	ldrb	r3, [r3, #0]
 810ca6e:	461a      	mov	r2, r3
 810ca70:	687b      	ldr	r3, [r7, #4]
 810ca72:	685b      	ldr	r3, [r3, #4]
 810ca74:	429a      	cmp	r2, r3
 810ca76:	d02a      	beq.n	810cace <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 810ca78:	687b      	ldr	r3, [r7, #4]
 810ca7a:	685b      	ldr	r3, [r3, #4]
 810ca7c:	b2db      	uxtb	r3, r3
 810ca7e:	4619      	mov	r1, r3
 810ca80:	6878      	ldr	r0, [r7, #4]
 810ca82:	f7fe ff96 	bl	810b9b2 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 810ca86:	4b1d      	ldr	r3, [pc, #116]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca88:	781b      	ldrb	r3, [r3, #0]
 810ca8a:	461a      	mov	r2, r3
 810ca8c:	687b      	ldr	r3, [r7, #4]
 810ca8e:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 810ca90:	4b1a      	ldr	r3, [pc, #104]	@ (810cafc <USBD_SetConfig+0x150>)
 810ca92:	781b      	ldrb	r3, [r3, #0]
 810ca94:	4619      	mov	r1, r3
 810ca96:	6878      	ldr	r0, [r7, #4]
 810ca98:	f7fe ff6f 	bl	810b97a <USBD_SetClassConfig>
 810ca9c:	4603      	mov	r3, r0
 810ca9e:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 810caa0:	7bfb      	ldrb	r3, [r7, #15]
 810caa2:	2b00      	cmp	r3, #0
 810caa4:	d00f      	beq.n	810cac6 <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 810caa6:	6839      	ldr	r1, [r7, #0]
 810caa8:	6878      	ldr	r0, [r7, #4]
 810caaa:	f000 f918 	bl	810ccde <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 810caae:	687b      	ldr	r3, [r7, #4]
 810cab0:	685b      	ldr	r3, [r3, #4]
 810cab2:	b2db      	uxtb	r3, r3
 810cab4:	4619      	mov	r1, r3
 810cab6:	6878      	ldr	r0, [r7, #4]
 810cab8:	f7fe ff7b 	bl	810b9b2 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 810cabc:	687b      	ldr	r3, [r7, #4]
 810cabe:	2202      	movs	r2, #2
 810cac0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 810cac4:	e014      	b.n	810caf0 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 810cac6:	6878      	ldr	r0, [r7, #4]
 810cac8:	f000 f9e0 	bl	810ce8c <USBD_CtlSendStatus>
      break;
 810cacc:	e010      	b.n	810caf0 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 810cace:	6878      	ldr	r0, [r7, #4]
 810cad0:	f000 f9dc 	bl	810ce8c <USBD_CtlSendStatus>
      break;
 810cad4:	e00c      	b.n	810caf0 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 810cad6:	6839      	ldr	r1, [r7, #0]
 810cad8:	6878      	ldr	r0, [r7, #4]
 810cada:	f000 f900 	bl	810ccde <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 810cade:	4b07      	ldr	r3, [pc, #28]	@ (810cafc <USBD_SetConfig+0x150>)
 810cae0:	781b      	ldrb	r3, [r3, #0]
 810cae2:	4619      	mov	r1, r3
 810cae4:	6878      	ldr	r0, [r7, #4]
 810cae6:	f7fe ff64 	bl	810b9b2 <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 810caea:	2303      	movs	r3, #3
 810caec:	73fb      	strb	r3, [r7, #15]
      break;
 810caee:	bf00      	nop
  }

  return ret;
 810caf0:	7bfb      	ldrb	r3, [r7, #15]
}
 810caf2:	4618      	mov	r0, r3
 810caf4:	3710      	adds	r7, #16
 810caf6:	46bd      	mov	sp, r7
 810caf8:	bd80      	pop	{r7, pc}
 810cafa:	bf00      	nop
 810cafc:	10032660 	.word	0x10032660

0810cb00 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810cb00:	b580      	push	{r7, lr}
 810cb02:	b082      	sub	sp, #8
 810cb04:	af00      	add	r7, sp, #0
 810cb06:	6078      	str	r0, [r7, #4]
 810cb08:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 810cb0a:	683b      	ldr	r3, [r7, #0]
 810cb0c:	88db      	ldrh	r3, [r3, #6]
 810cb0e:	2b01      	cmp	r3, #1
 810cb10:	d004      	beq.n	810cb1c <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 810cb12:	6839      	ldr	r1, [r7, #0]
 810cb14:	6878      	ldr	r0, [r7, #4]
 810cb16:	f000 f8e2 	bl	810ccde <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 810cb1a:	e023      	b.n	810cb64 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 810cb1c:	687b      	ldr	r3, [r7, #4]
 810cb1e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810cb22:	b2db      	uxtb	r3, r3
 810cb24:	2b02      	cmp	r3, #2
 810cb26:	dc02      	bgt.n	810cb2e <USBD_GetConfig+0x2e>
 810cb28:	2b00      	cmp	r3, #0
 810cb2a:	dc03      	bgt.n	810cb34 <USBD_GetConfig+0x34>
 810cb2c:	e015      	b.n	810cb5a <USBD_GetConfig+0x5a>
 810cb2e:	2b03      	cmp	r3, #3
 810cb30:	d00b      	beq.n	810cb4a <USBD_GetConfig+0x4a>
 810cb32:	e012      	b.n	810cb5a <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 810cb34:	687b      	ldr	r3, [r7, #4]
 810cb36:	2200      	movs	r2, #0
 810cb38:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 810cb3a:	687b      	ldr	r3, [r7, #4]
 810cb3c:	3308      	adds	r3, #8
 810cb3e:	2201      	movs	r2, #1
 810cb40:	4619      	mov	r1, r3
 810cb42:	6878      	ldr	r0, [r7, #4]
 810cb44:	f000 f948 	bl	810cdd8 <USBD_CtlSendData>
        break;
 810cb48:	e00c      	b.n	810cb64 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 810cb4a:	687b      	ldr	r3, [r7, #4]
 810cb4c:	3304      	adds	r3, #4
 810cb4e:	2201      	movs	r2, #1
 810cb50:	4619      	mov	r1, r3
 810cb52:	6878      	ldr	r0, [r7, #4]
 810cb54:	f000 f940 	bl	810cdd8 <USBD_CtlSendData>
        break;
 810cb58:	e004      	b.n	810cb64 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 810cb5a:	6839      	ldr	r1, [r7, #0]
 810cb5c:	6878      	ldr	r0, [r7, #4]
 810cb5e:	f000 f8be 	bl	810ccde <USBD_CtlError>
        break;
 810cb62:	bf00      	nop
}
 810cb64:	bf00      	nop
 810cb66:	3708      	adds	r7, #8
 810cb68:	46bd      	mov	sp, r7
 810cb6a:	bd80      	pop	{r7, pc}

0810cb6c <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810cb6c:	b580      	push	{r7, lr}
 810cb6e:	b082      	sub	sp, #8
 810cb70:	af00      	add	r7, sp, #0
 810cb72:	6078      	str	r0, [r7, #4]
 810cb74:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 810cb76:	687b      	ldr	r3, [r7, #4]
 810cb78:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810cb7c:	b2db      	uxtb	r3, r3
 810cb7e:	3b01      	subs	r3, #1
 810cb80:	2b02      	cmp	r3, #2
 810cb82:	d81e      	bhi.n	810cbc2 <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 810cb84:	683b      	ldr	r3, [r7, #0]
 810cb86:	88db      	ldrh	r3, [r3, #6]
 810cb88:	2b02      	cmp	r3, #2
 810cb8a:	d004      	beq.n	810cb96 <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 810cb8c:	6839      	ldr	r1, [r7, #0]
 810cb8e:	6878      	ldr	r0, [r7, #4]
 810cb90:	f000 f8a5 	bl	810ccde <USBD_CtlError>
        break;
 810cb94:	e01a      	b.n	810cbcc <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 810cb96:	687b      	ldr	r3, [r7, #4]
 810cb98:	2201      	movs	r2, #1
 810cb9a:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 810cb9c:	687b      	ldr	r3, [r7, #4]
 810cb9e:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 810cba2:	2b00      	cmp	r3, #0
 810cba4:	d005      	beq.n	810cbb2 <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 810cba6:	687b      	ldr	r3, [r7, #4]
 810cba8:	68db      	ldr	r3, [r3, #12]
 810cbaa:	f043 0202 	orr.w	r2, r3, #2
 810cbae:	687b      	ldr	r3, [r7, #4]
 810cbb0:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 810cbb2:	687b      	ldr	r3, [r7, #4]
 810cbb4:	330c      	adds	r3, #12
 810cbb6:	2202      	movs	r2, #2
 810cbb8:	4619      	mov	r1, r3
 810cbba:	6878      	ldr	r0, [r7, #4]
 810cbbc:	f000 f90c 	bl	810cdd8 <USBD_CtlSendData>
      break;
 810cbc0:	e004      	b.n	810cbcc <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 810cbc2:	6839      	ldr	r1, [r7, #0]
 810cbc4:	6878      	ldr	r0, [r7, #4]
 810cbc6:	f000 f88a 	bl	810ccde <USBD_CtlError>
      break;
 810cbca:	bf00      	nop
  }
}
 810cbcc:	bf00      	nop
 810cbce:	3708      	adds	r7, #8
 810cbd0:	46bd      	mov	sp, r7
 810cbd2:	bd80      	pop	{r7, pc}

0810cbd4 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810cbd4:	b580      	push	{r7, lr}
 810cbd6:	b082      	sub	sp, #8
 810cbd8:	af00      	add	r7, sp, #0
 810cbda:	6078      	str	r0, [r7, #4]
 810cbdc:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 810cbde:	683b      	ldr	r3, [r7, #0]
 810cbe0:	885b      	ldrh	r3, [r3, #2]
 810cbe2:	2b01      	cmp	r3, #1
 810cbe4:	d107      	bne.n	810cbf6 <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 810cbe6:	687b      	ldr	r3, [r7, #4]
 810cbe8:	2201      	movs	r2, #1
 810cbea:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 810cbee:	6878      	ldr	r0, [r7, #4]
 810cbf0:	f000 f94c 	bl	810ce8c <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 810cbf4:	e013      	b.n	810cc1e <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 810cbf6:	683b      	ldr	r3, [r7, #0]
 810cbf8:	885b      	ldrh	r3, [r3, #2]
 810cbfa:	2b02      	cmp	r3, #2
 810cbfc:	d10b      	bne.n	810cc16 <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 810cbfe:	683b      	ldr	r3, [r7, #0]
 810cc00:	889b      	ldrh	r3, [r3, #4]
 810cc02:	0a1b      	lsrs	r3, r3, #8
 810cc04:	b29b      	uxth	r3, r3
 810cc06:	b2da      	uxtb	r2, r3
 810cc08:	687b      	ldr	r3, [r7, #4]
 810cc0a:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 810cc0e:	6878      	ldr	r0, [r7, #4]
 810cc10:	f000 f93c 	bl	810ce8c <USBD_CtlSendStatus>
}
 810cc14:	e003      	b.n	810cc1e <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 810cc16:	6839      	ldr	r1, [r7, #0]
 810cc18:	6878      	ldr	r0, [r7, #4]
 810cc1a:	f000 f860 	bl	810ccde <USBD_CtlError>
}
 810cc1e:	bf00      	nop
 810cc20:	3708      	adds	r7, #8
 810cc22:	46bd      	mov	sp, r7
 810cc24:	bd80      	pop	{r7, pc}

0810cc26 <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810cc26:	b580      	push	{r7, lr}
 810cc28:	b082      	sub	sp, #8
 810cc2a:	af00      	add	r7, sp, #0
 810cc2c:	6078      	str	r0, [r7, #4]
 810cc2e:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 810cc30:	687b      	ldr	r3, [r7, #4]
 810cc32:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 810cc36:	b2db      	uxtb	r3, r3
 810cc38:	3b01      	subs	r3, #1
 810cc3a:	2b02      	cmp	r3, #2
 810cc3c:	d80b      	bhi.n	810cc56 <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 810cc3e:	683b      	ldr	r3, [r7, #0]
 810cc40:	885b      	ldrh	r3, [r3, #2]
 810cc42:	2b01      	cmp	r3, #1
 810cc44:	d10c      	bne.n	810cc60 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 810cc46:	687b      	ldr	r3, [r7, #4]
 810cc48:	2200      	movs	r2, #0
 810cc4a:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 810cc4e:	6878      	ldr	r0, [r7, #4]
 810cc50:	f000 f91c 	bl	810ce8c <USBD_CtlSendStatus>
      }
      break;
 810cc54:	e004      	b.n	810cc60 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 810cc56:	6839      	ldr	r1, [r7, #0]
 810cc58:	6878      	ldr	r0, [r7, #4]
 810cc5a:	f000 f840 	bl	810ccde <USBD_CtlError>
      break;
 810cc5e:	e000      	b.n	810cc62 <USBD_ClrFeature+0x3c>
      break;
 810cc60:	bf00      	nop
  }
}
 810cc62:	bf00      	nop
 810cc64:	3708      	adds	r7, #8
 810cc66:	46bd      	mov	sp, r7
 810cc68:	bd80      	pop	{r7, pc}

0810cc6a <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 810cc6a:	b580      	push	{r7, lr}
 810cc6c:	b084      	sub	sp, #16
 810cc6e:	af00      	add	r7, sp, #0
 810cc70:	6078      	str	r0, [r7, #4]
 810cc72:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 810cc74:	683b      	ldr	r3, [r7, #0]
 810cc76:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 810cc78:	68fb      	ldr	r3, [r7, #12]
 810cc7a:	781a      	ldrb	r2, [r3, #0]
 810cc7c:	687b      	ldr	r3, [r7, #4]
 810cc7e:	701a      	strb	r2, [r3, #0]

  pbuff++;
 810cc80:	68fb      	ldr	r3, [r7, #12]
 810cc82:	3301      	adds	r3, #1
 810cc84:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 810cc86:	68fb      	ldr	r3, [r7, #12]
 810cc88:	781a      	ldrb	r2, [r3, #0]
 810cc8a:	687b      	ldr	r3, [r7, #4]
 810cc8c:	705a      	strb	r2, [r3, #1]

  pbuff++;
 810cc8e:	68fb      	ldr	r3, [r7, #12]
 810cc90:	3301      	adds	r3, #1
 810cc92:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 810cc94:	68f8      	ldr	r0, [r7, #12]
 810cc96:	f7ff fa16 	bl	810c0c6 <SWAPBYTE>
 810cc9a:	4603      	mov	r3, r0
 810cc9c:	461a      	mov	r2, r3
 810cc9e:	687b      	ldr	r3, [r7, #4]
 810cca0:	805a      	strh	r2, [r3, #2]

  pbuff++;
 810cca2:	68fb      	ldr	r3, [r7, #12]
 810cca4:	3301      	adds	r3, #1
 810cca6:	60fb      	str	r3, [r7, #12]
  pbuff++;
 810cca8:	68fb      	ldr	r3, [r7, #12]
 810ccaa:	3301      	adds	r3, #1
 810ccac:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 810ccae:	68f8      	ldr	r0, [r7, #12]
 810ccb0:	f7ff fa09 	bl	810c0c6 <SWAPBYTE>
 810ccb4:	4603      	mov	r3, r0
 810ccb6:	461a      	mov	r2, r3
 810ccb8:	687b      	ldr	r3, [r7, #4]
 810ccba:	809a      	strh	r2, [r3, #4]

  pbuff++;
 810ccbc:	68fb      	ldr	r3, [r7, #12]
 810ccbe:	3301      	adds	r3, #1
 810ccc0:	60fb      	str	r3, [r7, #12]
  pbuff++;
 810ccc2:	68fb      	ldr	r3, [r7, #12]
 810ccc4:	3301      	adds	r3, #1
 810ccc6:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 810ccc8:	68f8      	ldr	r0, [r7, #12]
 810ccca:	f7ff f9fc 	bl	810c0c6 <SWAPBYTE>
 810ccce:	4603      	mov	r3, r0
 810ccd0:	461a      	mov	r2, r3
 810ccd2:	687b      	ldr	r3, [r7, #4]
 810ccd4:	80da      	strh	r2, [r3, #6]
}
 810ccd6:	bf00      	nop
 810ccd8:	3710      	adds	r7, #16
 810ccda:	46bd      	mov	sp, r7
 810ccdc:	bd80      	pop	{r7, pc}

0810ccde <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810ccde:	b580      	push	{r7, lr}
 810cce0:	b082      	sub	sp, #8
 810cce2:	af00      	add	r7, sp, #0
 810cce4:	6078      	str	r0, [r7, #4]
 810cce6:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 810cce8:	2180      	movs	r1, #128	@ 0x80
 810ccea:	6878      	ldr	r0, [r7, #4]
 810ccec:	f000 fcfc 	bl	810d6e8 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 810ccf0:	2100      	movs	r1, #0
 810ccf2:	6878      	ldr	r0, [r7, #4]
 810ccf4:	f000 fcf8 	bl	810d6e8 <USBD_LL_StallEP>
}
 810ccf8:	bf00      	nop
 810ccfa:	3708      	adds	r7, #8
 810ccfc:	46bd      	mov	sp, r7
 810ccfe:	bd80      	pop	{r7, pc}

0810cd00 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 810cd00:	b580      	push	{r7, lr}
 810cd02:	b086      	sub	sp, #24
 810cd04:	af00      	add	r7, sp, #0
 810cd06:	60f8      	str	r0, [r7, #12]
 810cd08:	60b9      	str	r1, [r7, #8]
 810cd0a:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 810cd0c:	2300      	movs	r3, #0
 810cd0e:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 810cd10:	68fb      	ldr	r3, [r7, #12]
 810cd12:	2b00      	cmp	r3, #0
 810cd14:	d042      	beq.n	810cd9c <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 810cd16:	68fb      	ldr	r3, [r7, #12]
 810cd18:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 810cd1a:	6938      	ldr	r0, [r7, #16]
 810cd1c:	f000 f842 	bl	810cda4 <USBD_GetLen>
 810cd20:	4603      	mov	r3, r0
 810cd22:	3301      	adds	r3, #1
 810cd24:	005b      	lsls	r3, r3, #1
 810cd26:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 810cd2a:	d808      	bhi.n	810cd3e <USBD_GetString+0x3e>
 810cd2c:	6938      	ldr	r0, [r7, #16]
 810cd2e:	f000 f839 	bl	810cda4 <USBD_GetLen>
 810cd32:	4603      	mov	r3, r0
 810cd34:	3301      	adds	r3, #1
 810cd36:	b29b      	uxth	r3, r3
 810cd38:	005b      	lsls	r3, r3, #1
 810cd3a:	b29a      	uxth	r2, r3
 810cd3c:	e001      	b.n	810cd42 <USBD_GetString+0x42>
 810cd3e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 810cd42:	687b      	ldr	r3, [r7, #4]
 810cd44:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 810cd46:	7dfb      	ldrb	r3, [r7, #23]
 810cd48:	68ba      	ldr	r2, [r7, #8]
 810cd4a:	4413      	add	r3, r2
 810cd4c:	687a      	ldr	r2, [r7, #4]
 810cd4e:	7812      	ldrb	r2, [r2, #0]
 810cd50:	701a      	strb	r2, [r3, #0]
  idx++;
 810cd52:	7dfb      	ldrb	r3, [r7, #23]
 810cd54:	3301      	adds	r3, #1
 810cd56:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 810cd58:	7dfb      	ldrb	r3, [r7, #23]
 810cd5a:	68ba      	ldr	r2, [r7, #8]
 810cd5c:	4413      	add	r3, r2
 810cd5e:	2203      	movs	r2, #3
 810cd60:	701a      	strb	r2, [r3, #0]
  idx++;
 810cd62:	7dfb      	ldrb	r3, [r7, #23]
 810cd64:	3301      	adds	r3, #1
 810cd66:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 810cd68:	e013      	b.n	810cd92 <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 810cd6a:	7dfb      	ldrb	r3, [r7, #23]
 810cd6c:	68ba      	ldr	r2, [r7, #8]
 810cd6e:	4413      	add	r3, r2
 810cd70:	693a      	ldr	r2, [r7, #16]
 810cd72:	7812      	ldrb	r2, [r2, #0]
 810cd74:	701a      	strb	r2, [r3, #0]
    pdesc++;
 810cd76:	693b      	ldr	r3, [r7, #16]
 810cd78:	3301      	adds	r3, #1
 810cd7a:	613b      	str	r3, [r7, #16]
    idx++;
 810cd7c:	7dfb      	ldrb	r3, [r7, #23]
 810cd7e:	3301      	adds	r3, #1
 810cd80:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 810cd82:	7dfb      	ldrb	r3, [r7, #23]
 810cd84:	68ba      	ldr	r2, [r7, #8]
 810cd86:	4413      	add	r3, r2
 810cd88:	2200      	movs	r2, #0
 810cd8a:	701a      	strb	r2, [r3, #0]
    idx++;
 810cd8c:	7dfb      	ldrb	r3, [r7, #23]
 810cd8e:	3301      	adds	r3, #1
 810cd90:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 810cd92:	693b      	ldr	r3, [r7, #16]
 810cd94:	781b      	ldrb	r3, [r3, #0]
 810cd96:	2b00      	cmp	r3, #0
 810cd98:	d1e7      	bne.n	810cd6a <USBD_GetString+0x6a>
 810cd9a:	e000      	b.n	810cd9e <USBD_GetString+0x9e>
    return;
 810cd9c:	bf00      	nop
  }
}
 810cd9e:	3718      	adds	r7, #24
 810cda0:	46bd      	mov	sp, r7
 810cda2:	bd80      	pop	{r7, pc}

0810cda4 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 810cda4:	b480      	push	{r7}
 810cda6:	b085      	sub	sp, #20
 810cda8:	af00      	add	r7, sp, #0
 810cdaa:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 810cdac:	2300      	movs	r3, #0
 810cdae:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 810cdb0:	687b      	ldr	r3, [r7, #4]
 810cdb2:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 810cdb4:	e005      	b.n	810cdc2 <USBD_GetLen+0x1e>
  {
    len++;
 810cdb6:	7bfb      	ldrb	r3, [r7, #15]
 810cdb8:	3301      	adds	r3, #1
 810cdba:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 810cdbc:	68bb      	ldr	r3, [r7, #8]
 810cdbe:	3301      	adds	r3, #1
 810cdc0:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 810cdc2:	68bb      	ldr	r3, [r7, #8]
 810cdc4:	781b      	ldrb	r3, [r3, #0]
 810cdc6:	2b00      	cmp	r3, #0
 810cdc8:	d1f5      	bne.n	810cdb6 <USBD_GetLen+0x12>
  }

  return len;
 810cdca:	7bfb      	ldrb	r3, [r7, #15]
}
 810cdcc:	4618      	mov	r0, r3
 810cdce:	3714      	adds	r7, #20
 810cdd0:	46bd      	mov	sp, r7
 810cdd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cdd6:	4770      	bx	lr

0810cdd8 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 810cdd8:	b580      	push	{r7, lr}
 810cdda:	b084      	sub	sp, #16
 810cddc:	af00      	add	r7, sp, #0
 810cdde:	60f8      	str	r0, [r7, #12]
 810cde0:	60b9      	str	r1, [r7, #8]
 810cde2:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 810cde4:	68fb      	ldr	r3, [r7, #12]
 810cde6:	2202      	movs	r2, #2
 810cde8:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 810cdec:	68fb      	ldr	r3, [r7, #12]
 810cdee:	687a      	ldr	r2, [r7, #4]
 810cdf0:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 810cdf2:	68fb      	ldr	r3, [r7, #12]
 810cdf4:	687a      	ldr	r2, [r7, #4]
 810cdf6:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 810cdf8:	687b      	ldr	r3, [r7, #4]
 810cdfa:	68ba      	ldr	r2, [r7, #8]
 810cdfc:	2100      	movs	r1, #0
 810cdfe:	68f8      	ldr	r0, [r7, #12]
 810ce00:	f000 fcfb 	bl	810d7fa <USBD_LL_Transmit>

  return USBD_OK;
 810ce04:	2300      	movs	r3, #0
}
 810ce06:	4618      	mov	r0, r3
 810ce08:	3710      	adds	r7, #16
 810ce0a:	46bd      	mov	sp, r7
 810ce0c:	bd80      	pop	{r7, pc}

0810ce0e <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 810ce0e:	b580      	push	{r7, lr}
 810ce10:	b084      	sub	sp, #16
 810ce12:	af00      	add	r7, sp, #0
 810ce14:	60f8      	str	r0, [r7, #12]
 810ce16:	60b9      	str	r1, [r7, #8]
 810ce18:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 810ce1a:	687b      	ldr	r3, [r7, #4]
 810ce1c:	68ba      	ldr	r2, [r7, #8]
 810ce1e:	2100      	movs	r1, #0
 810ce20:	68f8      	ldr	r0, [r7, #12]
 810ce22:	f000 fcea 	bl	810d7fa <USBD_LL_Transmit>

  return USBD_OK;
 810ce26:	2300      	movs	r3, #0
}
 810ce28:	4618      	mov	r0, r3
 810ce2a:	3710      	adds	r7, #16
 810ce2c:	46bd      	mov	sp, r7
 810ce2e:	bd80      	pop	{r7, pc}

0810ce30 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 810ce30:	b580      	push	{r7, lr}
 810ce32:	b084      	sub	sp, #16
 810ce34:	af00      	add	r7, sp, #0
 810ce36:	60f8      	str	r0, [r7, #12]
 810ce38:	60b9      	str	r1, [r7, #8]
 810ce3a:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 810ce3c:	68fb      	ldr	r3, [r7, #12]
 810ce3e:	2203      	movs	r2, #3
 810ce40:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 810ce44:	68fb      	ldr	r3, [r7, #12]
 810ce46:	687a      	ldr	r2, [r7, #4]
 810ce48:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 810ce4c:	68fb      	ldr	r3, [r7, #12]
 810ce4e:	687a      	ldr	r2, [r7, #4]
 810ce50:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 810ce54:	687b      	ldr	r3, [r7, #4]
 810ce56:	68ba      	ldr	r2, [r7, #8]
 810ce58:	2100      	movs	r1, #0
 810ce5a:	68f8      	ldr	r0, [r7, #12]
 810ce5c:	f000 fcee 	bl	810d83c <USBD_LL_PrepareReceive>

  return USBD_OK;
 810ce60:	2300      	movs	r3, #0
}
 810ce62:	4618      	mov	r0, r3
 810ce64:	3710      	adds	r7, #16
 810ce66:	46bd      	mov	sp, r7
 810ce68:	bd80      	pop	{r7, pc}

0810ce6a <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 810ce6a:	b580      	push	{r7, lr}
 810ce6c:	b084      	sub	sp, #16
 810ce6e:	af00      	add	r7, sp, #0
 810ce70:	60f8      	str	r0, [r7, #12]
 810ce72:	60b9      	str	r1, [r7, #8]
 810ce74:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 810ce76:	687b      	ldr	r3, [r7, #4]
 810ce78:	68ba      	ldr	r2, [r7, #8]
 810ce7a:	2100      	movs	r1, #0
 810ce7c:	68f8      	ldr	r0, [r7, #12]
 810ce7e:	f000 fcdd 	bl	810d83c <USBD_LL_PrepareReceive>

  return USBD_OK;
 810ce82:	2300      	movs	r3, #0
}
 810ce84:	4618      	mov	r0, r3
 810ce86:	3710      	adds	r7, #16
 810ce88:	46bd      	mov	sp, r7
 810ce8a:	bd80      	pop	{r7, pc}

0810ce8c <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 810ce8c:	b580      	push	{r7, lr}
 810ce8e:	b082      	sub	sp, #8
 810ce90:	af00      	add	r7, sp, #0
 810ce92:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 810ce94:	687b      	ldr	r3, [r7, #4]
 810ce96:	2204      	movs	r2, #4
 810ce98:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 810ce9c:	2300      	movs	r3, #0
 810ce9e:	2200      	movs	r2, #0
 810cea0:	2100      	movs	r1, #0
 810cea2:	6878      	ldr	r0, [r7, #4]
 810cea4:	f000 fca9 	bl	810d7fa <USBD_LL_Transmit>

  return USBD_OK;
 810cea8:	2300      	movs	r3, #0
}
 810ceaa:	4618      	mov	r0, r3
 810ceac:	3708      	adds	r7, #8
 810ceae:	46bd      	mov	sp, r7
 810ceb0:	bd80      	pop	{r7, pc}

0810ceb2 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 810ceb2:	b580      	push	{r7, lr}
 810ceb4:	b082      	sub	sp, #8
 810ceb6:	af00      	add	r7, sp, #0
 810ceb8:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 810ceba:	687b      	ldr	r3, [r7, #4]
 810cebc:	2205      	movs	r2, #5
 810cebe:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810cec2:	2300      	movs	r3, #0
 810cec4:	2200      	movs	r2, #0
 810cec6:	2100      	movs	r1, #0
 810cec8:	6878      	ldr	r0, [r7, #4]
 810ceca:	f000 fcb7 	bl	810d83c <USBD_LL_PrepareReceive>

  return USBD_OK;
 810cece:	2300      	movs	r3, #0
}
 810ced0:	4618      	mov	r0, r3
 810ced2:	3708      	adds	r7, #8
 810ced4:	46bd      	mov	sp, r7
 810ced6:	bd80      	pop	{r7, pc}

0810ced8 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 810ced8:	b580      	push	{r7, lr}
 810ceda:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 810cedc:	2200      	movs	r2, #0
 810cede:	4913      	ldr	r1, [pc, #76]	@ (810cf2c <MX_USB_DEVICE_Init+0x54>)
 810cee0:	4813      	ldr	r0, [pc, #76]	@ (810cf30 <MX_USB_DEVICE_Init+0x58>)
 810cee2:	f7fe fccd 	bl	810b880 <USBD_Init>
 810cee6:	4603      	mov	r3, r0
 810cee8:	2b00      	cmp	r3, #0
 810ceea:	d001      	beq.n	810cef0 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 810ceec:	f7f4 faca 	bl	8101484 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 810cef0:	4910      	ldr	r1, [pc, #64]	@ (810cf34 <MX_USB_DEVICE_Init+0x5c>)
 810cef2:	480f      	ldr	r0, [pc, #60]	@ (810cf30 <MX_USB_DEVICE_Init+0x58>)
 810cef4:	f7fe fcf4 	bl	810b8e0 <USBD_RegisterClass>
 810cef8:	4603      	mov	r3, r0
 810cefa:	2b00      	cmp	r3, #0
 810cefc:	d001      	beq.n	810cf02 <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 810cefe:	f7f4 fac1 	bl	8101484 <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 810cf02:	490d      	ldr	r1, [pc, #52]	@ (810cf38 <MX_USB_DEVICE_Init+0x60>)
 810cf04:	480a      	ldr	r0, [pc, #40]	@ (810cf30 <MX_USB_DEVICE_Init+0x58>)
 810cf06:	f7fe fc2b 	bl	810b760 <USBD_CDC_RegisterInterface>
 810cf0a:	4603      	mov	r3, r0
 810cf0c:	2b00      	cmp	r3, #0
 810cf0e:	d001      	beq.n	810cf14 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 810cf10:	f7f4 fab8 	bl	8101484 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 810cf14:	4806      	ldr	r0, [pc, #24]	@ (810cf30 <MX_USB_DEVICE_Init+0x58>)
 810cf16:	f7fe fd19 	bl	810b94c <USBD_Start>
 810cf1a:	4603      	mov	r3, r0
 810cf1c:	2b00      	cmp	r3, #0
 810cf1e:	d001      	beq.n	810cf24 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 810cf20:	f7f4 fab0 	bl	8101484 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  HAL_PWREx_EnableUSBVoltageDetector();
 810cf24:	f7f7 fcdc 	bl	81048e0 <HAL_PWREx_EnableUSBVoltageDetector>

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 810cf28:	bf00      	nop
 810cf2a:	bd80      	pop	{r7, pc}
 810cf2c:	100320d8 	.word	0x100320d8
 810cf30:	10032664 	.word	0x10032664
 810cf34:	10032044 	.word	0x10032044
 810cf38:	100320c4 	.word	0x100320c4

0810cf3c <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 810cf3c:	b580      	push	{r7, lr}
 810cf3e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 810cf40:	2200      	movs	r2, #0
 810cf42:	4905      	ldr	r1, [pc, #20]	@ (810cf58 <CDC_Init_FS+0x1c>)
 810cf44:	4805      	ldr	r0, [pc, #20]	@ (810cf5c <CDC_Init_FS+0x20>)
 810cf46:	f7fe fc25 	bl	810b794 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 810cf4a:	4905      	ldr	r1, [pc, #20]	@ (810cf60 <CDC_Init_FS+0x24>)
 810cf4c:	4803      	ldr	r0, [pc, #12]	@ (810cf5c <CDC_Init_FS+0x20>)
 810cf4e:	f7fe fc43 	bl	810b7d8 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 810cf52:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 810cf54:	4618      	mov	r0, r3
 810cf56:	bd80      	pop	{r7, pc}
 810cf58:	10033140 	.word	0x10033140
 810cf5c:	10032664 	.word	0x10032664
 810cf60:	10032940 	.word	0x10032940

0810cf64 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 810cf64:	b480      	push	{r7}
 810cf66:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 810cf68:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 810cf6a:	4618      	mov	r0, r3
 810cf6c:	46bd      	mov	sp, r7
 810cf6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cf72:	4770      	bx	lr

0810cf74 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 810cf74:	b480      	push	{r7}
 810cf76:	b083      	sub	sp, #12
 810cf78:	af00      	add	r7, sp, #0
 810cf7a:	4603      	mov	r3, r0
 810cf7c:	6039      	str	r1, [r7, #0]
 810cf7e:	71fb      	strb	r3, [r7, #7]
 810cf80:	4613      	mov	r3, r2
 810cf82:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 810cf84:	79fb      	ldrb	r3, [r7, #7]
 810cf86:	2b23      	cmp	r3, #35	@ 0x23
 810cf88:	d84a      	bhi.n	810d020 <CDC_Control_FS+0xac>
 810cf8a:	a201      	add	r2, pc, #4	@ (adr r2, 810cf90 <CDC_Control_FS+0x1c>)
 810cf8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810cf90:	0810d021 	.word	0x0810d021
 810cf94:	0810d021 	.word	0x0810d021
 810cf98:	0810d021 	.word	0x0810d021
 810cf9c:	0810d021 	.word	0x0810d021
 810cfa0:	0810d021 	.word	0x0810d021
 810cfa4:	0810d021 	.word	0x0810d021
 810cfa8:	0810d021 	.word	0x0810d021
 810cfac:	0810d021 	.word	0x0810d021
 810cfb0:	0810d021 	.word	0x0810d021
 810cfb4:	0810d021 	.word	0x0810d021
 810cfb8:	0810d021 	.word	0x0810d021
 810cfbc:	0810d021 	.word	0x0810d021
 810cfc0:	0810d021 	.word	0x0810d021
 810cfc4:	0810d021 	.word	0x0810d021
 810cfc8:	0810d021 	.word	0x0810d021
 810cfcc:	0810d021 	.word	0x0810d021
 810cfd0:	0810d021 	.word	0x0810d021
 810cfd4:	0810d021 	.word	0x0810d021
 810cfd8:	0810d021 	.word	0x0810d021
 810cfdc:	0810d021 	.word	0x0810d021
 810cfe0:	0810d021 	.word	0x0810d021
 810cfe4:	0810d021 	.word	0x0810d021
 810cfe8:	0810d021 	.word	0x0810d021
 810cfec:	0810d021 	.word	0x0810d021
 810cff0:	0810d021 	.word	0x0810d021
 810cff4:	0810d021 	.word	0x0810d021
 810cff8:	0810d021 	.word	0x0810d021
 810cffc:	0810d021 	.word	0x0810d021
 810d000:	0810d021 	.word	0x0810d021
 810d004:	0810d021 	.word	0x0810d021
 810d008:	0810d021 	.word	0x0810d021
 810d00c:	0810d021 	.word	0x0810d021
 810d010:	0810d021 	.word	0x0810d021
 810d014:	0810d021 	.word	0x0810d021
 810d018:	0810d021 	.word	0x0810d021
 810d01c:	0810d021 	.word	0x0810d021
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 810d020:	bf00      	nop
  }

  return (USBD_OK);
 810d022:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 810d024:	4618      	mov	r0, r3
 810d026:	370c      	adds	r7, #12
 810d028:	46bd      	mov	sp, r7
 810d02a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d02e:	4770      	bx	lr

0810d030 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 810d030:	b580      	push	{r7, lr}
 810d032:	b082      	sub	sp, #8
 810d034:	af00      	add	r7, sp, #0
 810d036:	6078      	str	r0, [r7, #4]
 810d038:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 810d03a:	6879      	ldr	r1, [r7, #4]
 810d03c:	4805      	ldr	r0, [pc, #20]	@ (810d054 <CDC_Receive_FS+0x24>)
 810d03e:	f7fe fbcb 	bl	810b7d8 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 810d042:	4804      	ldr	r0, [pc, #16]	@ (810d054 <CDC_Receive_FS+0x24>)
 810d044:	f7fe fbe6 	bl	810b814 <USBD_CDC_ReceivePacket>
  return (USBD_OK);
 810d048:	2300      	movs	r3, #0
  /* USER CODE END 6 */
}
 810d04a:	4618      	mov	r0, r3
 810d04c:	3708      	adds	r7, #8
 810d04e:	46bd      	mov	sp, r7
 810d050:	bd80      	pop	{r7, pc}
 810d052:	bf00      	nop
 810d054:	10032664 	.word	0x10032664

0810d058 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 810d058:	b480      	push	{r7}
 810d05a:	b087      	sub	sp, #28
 810d05c:	af00      	add	r7, sp, #0
 810d05e:	60f8      	str	r0, [r7, #12]
 810d060:	60b9      	str	r1, [r7, #8]
 810d062:	4613      	mov	r3, r2
 810d064:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 810d066:	2300      	movs	r3, #0
 810d068:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 810d06a:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 810d06e:	4618      	mov	r0, r3
 810d070:	371c      	adds	r7, #28
 810d072:	46bd      	mov	sp, r7
 810d074:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d078:	4770      	bx	lr
	...

0810d07c <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d07c:	b480      	push	{r7}
 810d07e:	b083      	sub	sp, #12
 810d080:	af00      	add	r7, sp, #0
 810d082:	4603      	mov	r3, r0
 810d084:	6039      	str	r1, [r7, #0]
 810d086:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 810d088:	683b      	ldr	r3, [r7, #0]
 810d08a:	2212      	movs	r2, #18
 810d08c:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 810d08e:	4b03      	ldr	r3, [pc, #12]	@ (810d09c <USBD_FS_DeviceDescriptor+0x20>)
}
 810d090:	4618      	mov	r0, r3
 810d092:	370c      	adds	r7, #12
 810d094:	46bd      	mov	sp, r7
 810d096:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d09a:	4770      	bx	lr
 810d09c:	100320f8 	.word	0x100320f8

0810d0a0 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d0a0:	b480      	push	{r7}
 810d0a2:	b083      	sub	sp, #12
 810d0a4:	af00      	add	r7, sp, #0
 810d0a6:	4603      	mov	r3, r0
 810d0a8:	6039      	str	r1, [r7, #0]
 810d0aa:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 810d0ac:	683b      	ldr	r3, [r7, #0]
 810d0ae:	2204      	movs	r2, #4
 810d0b0:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 810d0b2:	4b03      	ldr	r3, [pc, #12]	@ (810d0c0 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 810d0b4:	4618      	mov	r0, r3
 810d0b6:	370c      	adds	r7, #12
 810d0b8:	46bd      	mov	sp, r7
 810d0ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d0be:	4770      	bx	lr
 810d0c0:	1003210c 	.word	0x1003210c

0810d0c4 <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d0c4:	b580      	push	{r7, lr}
 810d0c6:	b082      	sub	sp, #8
 810d0c8:	af00      	add	r7, sp, #0
 810d0ca:	4603      	mov	r3, r0
 810d0cc:	6039      	str	r1, [r7, #0]
 810d0ce:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 810d0d0:	79fb      	ldrb	r3, [r7, #7]
 810d0d2:	2b00      	cmp	r3, #0
 810d0d4:	d105      	bne.n	810d0e2 <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 810d0d6:	683a      	ldr	r2, [r7, #0]
 810d0d8:	4907      	ldr	r1, [pc, #28]	@ (810d0f8 <USBD_FS_ProductStrDescriptor+0x34>)
 810d0da:	4808      	ldr	r0, [pc, #32]	@ (810d0fc <USBD_FS_ProductStrDescriptor+0x38>)
 810d0dc:	f7ff fe10 	bl	810cd00 <USBD_GetString>
 810d0e0:	e004      	b.n	810d0ec <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 810d0e2:	683a      	ldr	r2, [r7, #0]
 810d0e4:	4904      	ldr	r1, [pc, #16]	@ (810d0f8 <USBD_FS_ProductStrDescriptor+0x34>)
 810d0e6:	4805      	ldr	r0, [pc, #20]	@ (810d0fc <USBD_FS_ProductStrDescriptor+0x38>)
 810d0e8:	f7ff fe0a 	bl	810cd00 <USBD_GetString>
  }
  return USBD_StrDesc;
 810d0ec:	4b02      	ldr	r3, [pc, #8]	@ (810d0f8 <USBD_FS_ProductStrDescriptor+0x34>)
}
 810d0ee:	4618      	mov	r0, r3
 810d0f0:	3708      	adds	r7, #8
 810d0f2:	46bd      	mov	sp, r7
 810d0f4:	bd80      	pop	{r7, pc}
 810d0f6:	bf00      	nop
 810d0f8:	10033940 	.word	0x10033940
 810d0fc:	0810d9b8 	.word	0x0810d9b8

0810d100 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d100:	b580      	push	{r7, lr}
 810d102:	b082      	sub	sp, #8
 810d104:	af00      	add	r7, sp, #0
 810d106:	4603      	mov	r3, r0
 810d108:	6039      	str	r1, [r7, #0]
 810d10a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 810d10c:	683a      	ldr	r2, [r7, #0]
 810d10e:	4904      	ldr	r1, [pc, #16]	@ (810d120 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 810d110:	4804      	ldr	r0, [pc, #16]	@ (810d124 <USBD_FS_ManufacturerStrDescriptor+0x24>)
 810d112:	f7ff fdf5 	bl	810cd00 <USBD_GetString>
  return USBD_StrDesc;
 810d116:	4b02      	ldr	r3, [pc, #8]	@ (810d120 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 810d118:	4618      	mov	r0, r3
 810d11a:	3708      	adds	r7, #8
 810d11c:	46bd      	mov	sp, r7
 810d11e:	bd80      	pop	{r7, pc}
 810d120:	10033940 	.word	0x10033940
 810d124:	0810d9d0 	.word	0x0810d9d0

0810d128 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d128:	b580      	push	{r7, lr}
 810d12a:	b082      	sub	sp, #8
 810d12c:	af00      	add	r7, sp, #0
 810d12e:	4603      	mov	r3, r0
 810d130:	6039      	str	r1, [r7, #0]
 810d132:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 810d134:	683b      	ldr	r3, [r7, #0]
 810d136:	221a      	movs	r2, #26
 810d138:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 810d13a:	f000 f843 	bl	810d1c4 <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 810d13e:	4b02      	ldr	r3, [pc, #8]	@ (810d148 <USBD_FS_SerialStrDescriptor+0x20>)
}
 810d140:	4618      	mov	r0, r3
 810d142:	3708      	adds	r7, #8
 810d144:	46bd      	mov	sp, r7
 810d146:	bd80      	pop	{r7, pc}
 810d148:	10032110 	.word	0x10032110

0810d14c <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d14c:	b580      	push	{r7, lr}
 810d14e:	b082      	sub	sp, #8
 810d150:	af00      	add	r7, sp, #0
 810d152:	4603      	mov	r3, r0
 810d154:	6039      	str	r1, [r7, #0]
 810d156:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 810d158:	79fb      	ldrb	r3, [r7, #7]
 810d15a:	2b00      	cmp	r3, #0
 810d15c:	d105      	bne.n	810d16a <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 810d15e:	683a      	ldr	r2, [r7, #0]
 810d160:	4907      	ldr	r1, [pc, #28]	@ (810d180 <USBD_FS_ConfigStrDescriptor+0x34>)
 810d162:	4808      	ldr	r0, [pc, #32]	@ (810d184 <USBD_FS_ConfigStrDescriptor+0x38>)
 810d164:	f7ff fdcc 	bl	810cd00 <USBD_GetString>
 810d168:	e004      	b.n	810d174 <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 810d16a:	683a      	ldr	r2, [r7, #0]
 810d16c:	4904      	ldr	r1, [pc, #16]	@ (810d180 <USBD_FS_ConfigStrDescriptor+0x34>)
 810d16e:	4805      	ldr	r0, [pc, #20]	@ (810d184 <USBD_FS_ConfigStrDescriptor+0x38>)
 810d170:	f7ff fdc6 	bl	810cd00 <USBD_GetString>
  }
  return USBD_StrDesc;
 810d174:	4b02      	ldr	r3, [pc, #8]	@ (810d180 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 810d176:	4618      	mov	r0, r3
 810d178:	3708      	adds	r7, #8
 810d17a:	46bd      	mov	sp, r7
 810d17c:	bd80      	pop	{r7, pc}
 810d17e:	bf00      	nop
 810d180:	10033940 	.word	0x10033940
 810d184:	0810d9e0 	.word	0x0810d9e0

0810d188 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 810d188:	b580      	push	{r7, lr}
 810d18a:	b082      	sub	sp, #8
 810d18c:	af00      	add	r7, sp, #0
 810d18e:	4603      	mov	r3, r0
 810d190:	6039      	str	r1, [r7, #0]
 810d192:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 810d194:	79fb      	ldrb	r3, [r7, #7]
 810d196:	2b00      	cmp	r3, #0
 810d198:	d105      	bne.n	810d1a6 <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 810d19a:	683a      	ldr	r2, [r7, #0]
 810d19c:	4907      	ldr	r1, [pc, #28]	@ (810d1bc <USBD_FS_InterfaceStrDescriptor+0x34>)
 810d19e:	4808      	ldr	r0, [pc, #32]	@ (810d1c0 <USBD_FS_InterfaceStrDescriptor+0x38>)
 810d1a0:	f7ff fdae 	bl	810cd00 <USBD_GetString>
 810d1a4:	e004      	b.n	810d1b0 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 810d1a6:	683a      	ldr	r2, [r7, #0]
 810d1a8:	4904      	ldr	r1, [pc, #16]	@ (810d1bc <USBD_FS_InterfaceStrDescriptor+0x34>)
 810d1aa:	4805      	ldr	r0, [pc, #20]	@ (810d1c0 <USBD_FS_InterfaceStrDescriptor+0x38>)
 810d1ac:	f7ff fda8 	bl	810cd00 <USBD_GetString>
  }
  return USBD_StrDesc;
 810d1b0:	4b02      	ldr	r3, [pc, #8]	@ (810d1bc <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 810d1b2:	4618      	mov	r0, r3
 810d1b4:	3708      	adds	r7, #8
 810d1b6:	46bd      	mov	sp, r7
 810d1b8:	bd80      	pop	{r7, pc}
 810d1ba:	bf00      	nop
 810d1bc:	10033940 	.word	0x10033940
 810d1c0:	0810d9ec 	.word	0x0810d9ec

0810d1c4 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 810d1c4:	b580      	push	{r7, lr}
 810d1c6:	b084      	sub	sp, #16
 810d1c8:	af00      	add	r7, sp, #0
  uint32_t deviceserial1;
  uint32_t deviceserial2;

/* USER CODE BEGIN SerialNum */

  deviceserial0 = DEVICE_SERIAL0;
 810d1ca:	4b0f      	ldr	r3, [pc, #60]	@ (810d208 <Get_SerialNum+0x44>)
 810d1cc:	681b      	ldr	r3, [r3, #0]
 810d1ce:	60fb      	str	r3, [r7, #12]
  deviceserial1 = DEVICE_SERIAL1;
 810d1d0:	4b0e      	ldr	r3, [pc, #56]	@ (810d20c <Get_SerialNum+0x48>)
 810d1d2:	681b      	ldr	r3, [r3, #0]
 810d1d4:	60bb      	str	r3, [r7, #8]
  deviceserial2 = DEVICE_SERIAL2;
 810d1d6:	4b0e      	ldr	r3, [pc, #56]	@ (810d210 <Get_SerialNum+0x4c>)
 810d1d8:	681b      	ldr	r3, [r3, #0]
 810d1da:	607b      	str	r3, [r7, #4]

/* USER CODE END SerialNum */

  deviceserial0 += deviceserial2;
 810d1dc:	68fa      	ldr	r2, [r7, #12]
 810d1de:	687b      	ldr	r3, [r7, #4]
 810d1e0:	4413      	add	r3, r2
 810d1e2:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 810d1e4:	68fb      	ldr	r3, [r7, #12]
 810d1e6:	2b00      	cmp	r3, #0
 810d1e8:	d009      	beq.n	810d1fe <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 810d1ea:	2208      	movs	r2, #8
 810d1ec:	4909      	ldr	r1, [pc, #36]	@ (810d214 <Get_SerialNum+0x50>)
 810d1ee:	68f8      	ldr	r0, [r7, #12]
 810d1f0:	f000 f814 	bl	810d21c <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 810d1f4:	2204      	movs	r2, #4
 810d1f6:	4908      	ldr	r1, [pc, #32]	@ (810d218 <Get_SerialNum+0x54>)
 810d1f8:	68b8      	ldr	r0, [r7, #8]
 810d1fa:	f000 f80f 	bl	810d21c <IntToUnicode>
  }
}
 810d1fe:	bf00      	nop
 810d200:	3710      	adds	r7, #16
 810d202:	46bd      	mov	sp, r7
 810d204:	bd80      	pop	{r7, pc}
 810d206:	bf00      	nop
 810d208:	11223344 	.word	0x11223344
 810d20c:	55667788 	.word	0x55667788
 810d210:	12345678 	.word	0x12345678
 810d214:	10032112 	.word	0x10032112
 810d218:	10032122 	.word	0x10032122

0810d21c <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 810d21c:	b480      	push	{r7}
 810d21e:	b087      	sub	sp, #28
 810d220:	af00      	add	r7, sp, #0
 810d222:	60f8      	str	r0, [r7, #12]
 810d224:	60b9      	str	r1, [r7, #8]
 810d226:	4613      	mov	r3, r2
 810d228:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 810d22a:	2300      	movs	r3, #0
 810d22c:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 810d22e:	2300      	movs	r3, #0
 810d230:	75fb      	strb	r3, [r7, #23]
 810d232:	e027      	b.n	810d284 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 810d234:	68fb      	ldr	r3, [r7, #12]
 810d236:	0f1b      	lsrs	r3, r3, #28
 810d238:	2b09      	cmp	r3, #9
 810d23a:	d80b      	bhi.n	810d254 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 810d23c:	68fb      	ldr	r3, [r7, #12]
 810d23e:	0f1b      	lsrs	r3, r3, #28
 810d240:	b2da      	uxtb	r2, r3
 810d242:	7dfb      	ldrb	r3, [r7, #23]
 810d244:	005b      	lsls	r3, r3, #1
 810d246:	4619      	mov	r1, r3
 810d248:	68bb      	ldr	r3, [r7, #8]
 810d24a:	440b      	add	r3, r1
 810d24c:	3230      	adds	r2, #48	@ 0x30
 810d24e:	b2d2      	uxtb	r2, r2
 810d250:	701a      	strb	r2, [r3, #0]
 810d252:	e00a      	b.n	810d26a <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 810d254:	68fb      	ldr	r3, [r7, #12]
 810d256:	0f1b      	lsrs	r3, r3, #28
 810d258:	b2da      	uxtb	r2, r3
 810d25a:	7dfb      	ldrb	r3, [r7, #23]
 810d25c:	005b      	lsls	r3, r3, #1
 810d25e:	4619      	mov	r1, r3
 810d260:	68bb      	ldr	r3, [r7, #8]
 810d262:	440b      	add	r3, r1
 810d264:	3237      	adds	r2, #55	@ 0x37
 810d266:	b2d2      	uxtb	r2, r2
 810d268:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 810d26a:	68fb      	ldr	r3, [r7, #12]
 810d26c:	011b      	lsls	r3, r3, #4
 810d26e:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 810d270:	7dfb      	ldrb	r3, [r7, #23]
 810d272:	005b      	lsls	r3, r3, #1
 810d274:	3301      	adds	r3, #1
 810d276:	68ba      	ldr	r2, [r7, #8]
 810d278:	4413      	add	r3, r2
 810d27a:	2200      	movs	r2, #0
 810d27c:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 810d27e:	7dfb      	ldrb	r3, [r7, #23]
 810d280:	3301      	adds	r3, #1
 810d282:	75fb      	strb	r3, [r7, #23]
 810d284:	7dfa      	ldrb	r2, [r7, #23]
 810d286:	79fb      	ldrb	r3, [r7, #7]
 810d288:	429a      	cmp	r2, r3
 810d28a:	d3d3      	bcc.n	810d234 <IntToUnicode+0x18>
  }
}
 810d28c:	bf00      	nop
 810d28e:	bf00      	nop
 810d290:	371c      	adds	r7, #28
 810d292:	46bd      	mov	sp, r7
 810d294:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d298:	4770      	bx	lr
	...

0810d29c <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 810d29c:	b580      	push	{r7, lr}
 810d29e:	b0ba      	sub	sp, #232	@ 0xe8
 810d2a0:	af00      	add	r7, sp, #0
 810d2a2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 810d2a4:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 810d2a8:	2200      	movs	r2, #0
 810d2aa:	601a      	str	r2, [r3, #0]
 810d2ac:	605a      	str	r2, [r3, #4]
 810d2ae:	609a      	str	r2, [r3, #8]
 810d2b0:	60da      	str	r2, [r3, #12]
 810d2b2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 810d2b4:	f107 0310 	add.w	r3, r7, #16
 810d2b8:	22c0      	movs	r2, #192	@ 0xc0
 810d2ba:	2100      	movs	r1, #0
 810d2bc:	4618      	mov	r0, r3
 810d2be:	f000 fb35 	bl	810d92c <memset>
  if(pcdHandle->Instance==USB_OTG_FS)
 810d2c2:	687b      	ldr	r3, [r7, #4]
 810d2c4:	681b      	ldr	r3, [r3, #0]
 810d2c6:	4a34      	ldr	r2, [pc, #208]	@ (810d398 <HAL_PCD_MspInit+0xfc>)
 810d2c8:	4293      	cmp	r3, r2
 810d2ca:	d160      	bne.n	810d38e <HAL_PCD_MspInit+0xf2>

  /* USER CODE END USB_OTG_FS_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 810d2cc:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 810d2d0:	f04f 0300 	mov.w	r3, #0
 810d2d4:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.PLL3.PLL3M = 5;
 810d2d8:	2305      	movs	r3, #5
 810d2da:	63bb      	str	r3, [r7, #56]	@ 0x38
    PeriphClkInitStruct.PLL3.PLL3N = 48;
 810d2dc:	2330      	movs	r3, #48	@ 0x30
 810d2de:	63fb      	str	r3, [r7, #60]	@ 0x3c
    PeriphClkInitStruct.PLL3.PLL3P = 2;
 810d2e0:	2302      	movs	r3, #2
 810d2e2:	643b      	str	r3, [r7, #64]	@ 0x40
    PeriphClkInitStruct.PLL3.PLL3Q = 5;
 810d2e4:	2305      	movs	r3, #5
 810d2e6:	647b      	str	r3, [r7, #68]	@ 0x44
    PeriphClkInitStruct.PLL3.PLL3R = 4;
 810d2e8:	2304      	movs	r3, #4
 810d2ea:	64bb      	str	r3, [r7, #72]	@ 0x48
    PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_2;
 810d2ec:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 810d2f0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
 810d2f2:	2300      	movs	r3, #0
 810d2f4:	657b      	str	r3, [r7, #84]	@ 0x54
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 810d2f6:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 810d2fa:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 810d2fe:	f107 0310 	add.w	r3, r7, #16
 810d302:	4618      	mov	r0, r3
 810d304:	f7f7 fd00 	bl	8104d08 <HAL_RCCEx_PeriphCLKConfig>
 810d308:	4603      	mov	r3, r0
 810d30a:	2b00      	cmp	r3, #0
 810d30c:	d001      	beq.n	810d312 <HAL_PCD_MspInit+0x76>
    {
      Error_Handler();
 810d30e:	f7f4 f8b9 	bl	8101484 <Error_Handler>
    }

  /** Enable USB Voltage detector
  */
    HAL_PWREx_EnableUSBVoltageDetector();
 810d312:	f7f7 fae5 	bl	81048e0 <HAL_PWREx_EnableUSBVoltageDetector>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 810d316:	4b21      	ldr	r3, [pc, #132]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d318:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810d31c:	4a1f      	ldr	r2, [pc, #124]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d31e:	f043 0301 	orr.w	r3, r3, #1
 810d322:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 810d326:	4b1d      	ldr	r3, [pc, #116]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d328:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810d32c:	f003 0301 	and.w	r3, r3, #1
 810d330:	60fb      	str	r3, [r7, #12]
 810d332:	68fb      	ldr	r3, [r7, #12]
    /**USB_OTG_FS GPIO Configuration
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 810d334:	f44f 53c0 	mov.w	r3, #6144	@ 0x1800
 810d338:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810d33c:	2302      	movs	r3, #2
 810d33e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810d342:	2300      	movs	r3, #0
 810d344:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 810d348:	2303      	movs	r3, #3
 810d34a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 810d34e:	230a      	movs	r3, #10
 810d350:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 810d354:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 810d358:	4619      	mov	r1, r3
 810d35a:	4811      	ldr	r0, [pc, #68]	@ (810d3a0 <HAL_PCD_MspInit+0x104>)
 810d35c:	f7f4 fc26 	bl	8101bac <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 810d360:	4b0e      	ldr	r3, [pc, #56]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d362:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810d366:	4a0d      	ldr	r2, [pc, #52]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d368:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 810d36c:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 810d370:	4b0a      	ldr	r3, [pc, #40]	@ (810d39c <HAL_PCD_MspInit+0x100>)
 810d372:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 810d376:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 810d37a:	60bb      	str	r3, [r7, #8]
 810d37c:	68bb      	ldr	r3, [r7, #8]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 810d37e:	2200      	movs	r2, #0
 810d380:	2100      	movs	r1, #0
 810d382:	2065      	movs	r0, #101	@ 0x65
 810d384:	f7f4 fbd8 	bl	8101b38 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 810d388:	2065      	movs	r0, #101	@ 0x65
 810d38a:	f7f4 fbef 	bl	8101b6c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 810d38e:	bf00      	nop
 810d390:	37e8      	adds	r7, #232	@ 0xe8
 810d392:	46bd      	mov	sp, r7
 810d394:	bd80      	pop	{r7, pc}
 810d396:	bf00      	nop
 810d398:	40080000 	.word	0x40080000
 810d39c:	58024400 	.word	0x58024400
 810d3a0:	58020000 	.word	0x58020000

0810d3a4 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d3a4:	b580      	push	{r7, lr}
 810d3a6:	b082      	sub	sp, #8
 810d3a8:	af00      	add	r7, sp, #0
 810d3aa:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 810d3ac:	687b      	ldr	r3, [r7, #4]
 810d3ae:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 810d3b2:	687b      	ldr	r3, [r7, #4]
 810d3b4:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 810d3b8:	4619      	mov	r1, r3
 810d3ba:	4610      	mov	r0, r2
 810d3bc:	f7fe fb13 	bl	810b9e6 <USBD_LL_SetupStage>
}
 810d3c0:	bf00      	nop
 810d3c2:	3708      	adds	r7, #8
 810d3c4:	46bd      	mov	sp, r7
 810d3c6:	bd80      	pop	{r7, pc}

0810d3c8 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d3c8:	b580      	push	{r7, lr}
 810d3ca:	b082      	sub	sp, #8
 810d3cc:	af00      	add	r7, sp, #0
 810d3ce:	6078      	str	r0, [r7, #4]
 810d3d0:	460b      	mov	r3, r1
 810d3d2:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 810d3d4:	687b      	ldr	r3, [r7, #4]
 810d3d6:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 810d3da:	78fa      	ldrb	r2, [r7, #3]
 810d3dc:	6879      	ldr	r1, [r7, #4]
 810d3de:	4613      	mov	r3, r2
 810d3e0:	00db      	lsls	r3, r3, #3
 810d3e2:	4413      	add	r3, r2
 810d3e4:	009b      	lsls	r3, r3, #2
 810d3e6:	440b      	add	r3, r1
 810d3e8:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 810d3ec:	681a      	ldr	r2, [r3, #0]
 810d3ee:	78fb      	ldrb	r3, [r7, #3]
 810d3f0:	4619      	mov	r1, r3
 810d3f2:	f7fe fb4d 	bl	810ba90 <USBD_LL_DataOutStage>
}
 810d3f6:	bf00      	nop
 810d3f8:	3708      	adds	r7, #8
 810d3fa:	46bd      	mov	sp, r7
 810d3fc:	bd80      	pop	{r7, pc}

0810d3fe <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d3fe:	b580      	push	{r7, lr}
 810d400:	b082      	sub	sp, #8
 810d402:	af00      	add	r7, sp, #0
 810d404:	6078      	str	r0, [r7, #4]
 810d406:	460b      	mov	r3, r1
 810d408:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 810d40a:	687b      	ldr	r3, [r7, #4]
 810d40c:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 810d410:	78fa      	ldrb	r2, [r7, #3]
 810d412:	6879      	ldr	r1, [r7, #4]
 810d414:	4613      	mov	r3, r2
 810d416:	00db      	lsls	r3, r3, #3
 810d418:	4413      	add	r3, r2
 810d41a:	009b      	lsls	r3, r3, #2
 810d41c:	440b      	add	r3, r1
 810d41e:	3320      	adds	r3, #32
 810d420:	681a      	ldr	r2, [r3, #0]
 810d422:	78fb      	ldrb	r3, [r7, #3]
 810d424:	4619      	mov	r1, r3
 810d426:	f7fe fbe6 	bl	810bbf6 <USBD_LL_DataInStage>
}
 810d42a:	bf00      	nop
 810d42c:	3708      	adds	r7, #8
 810d42e:	46bd      	mov	sp, r7
 810d430:	bd80      	pop	{r7, pc}

0810d432 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d432:	b580      	push	{r7, lr}
 810d434:	b082      	sub	sp, #8
 810d436:	af00      	add	r7, sp, #0
 810d438:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 810d43a:	687b      	ldr	r3, [r7, #4]
 810d43c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d440:	4618      	mov	r0, r3
 810d442:	f7fe fd20 	bl	810be86 <USBD_LL_SOF>
}
 810d446:	bf00      	nop
 810d448:	3708      	adds	r7, #8
 810d44a:	46bd      	mov	sp, r7
 810d44c:	bd80      	pop	{r7, pc}

0810d44e <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d44e:	b580      	push	{r7, lr}
 810d450:	b084      	sub	sp, #16
 810d452:	af00      	add	r7, sp, #0
 810d454:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 810d456:	2301      	movs	r3, #1
 810d458:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 810d45a:	687b      	ldr	r3, [r7, #4]
 810d45c:	79db      	ldrb	r3, [r3, #7]
 810d45e:	2b00      	cmp	r3, #0
 810d460:	d102      	bne.n	810d468 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 810d462:	2300      	movs	r3, #0
 810d464:	73fb      	strb	r3, [r7, #15]
 810d466:	e008      	b.n	810d47a <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 810d468:	687b      	ldr	r3, [r7, #4]
 810d46a:	79db      	ldrb	r3, [r3, #7]
 810d46c:	2b02      	cmp	r3, #2
 810d46e:	d102      	bne.n	810d476 <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 810d470:	2301      	movs	r3, #1
 810d472:	73fb      	strb	r3, [r7, #15]
 810d474:	e001      	b.n	810d47a <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 810d476:	f7f4 f805 	bl	8101484 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 810d47a:	687b      	ldr	r3, [r7, #4]
 810d47c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d480:	7bfa      	ldrb	r2, [r7, #15]
 810d482:	4611      	mov	r1, r2
 810d484:	4618      	mov	r0, r3
 810d486:	f7fe fcba 	bl	810bdfe <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 810d48a:	687b      	ldr	r3, [r7, #4]
 810d48c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d490:	4618      	mov	r0, r3
 810d492:	f7fe fc62 	bl	810bd5a <USBD_LL_Reset>
}
 810d496:	bf00      	nop
 810d498:	3710      	adds	r7, #16
 810d49a:	46bd      	mov	sp, r7
 810d49c:	bd80      	pop	{r7, pc}
	...

0810d4a0 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d4a0:	b580      	push	{r7, lr}
 810d4a2:	b082      	sub	sp, #8
 810d4a4:	af00      	add	r7, sp, #0
 810d4a6:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 810d4a8:	687b      	ldr	r3, [r7, #4]
 810d4aa:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d4ae:	4618      	mov	r0, r3
 810d4b0:	f7fe fcb5 	bl	810be1e <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 810d4b4:	687b      	ldr	r3, [r7, #4]
 810d4b6:	681b      	ldr	r3, [r3, #0]
 810d4b8:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 810d4bc:	681b      	ldr	r3, [r3, #0]
 810d4be:	687a      	ldr	r2, [r7, #4]
 810d4c0:	6812      	ldr	r2, [r2, #0]
 810d4c2:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 810d4c6:	f043 0301 	orr.w	r3, r3, #1
 810d4ca:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 810d4cc:	687b      	ldr	r3, [r7, #4]
 810d4ce:	7adb      	ldrb	r3, [r3, #11]
 810d4d0:	2b00      	cmp	r3, #0
 810d4d2:	d005      	beq.n	810d4e0 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 810d4d4:	4b04      	ldr	r3, [pc, #16]	@ (810d4e8 <HAL_PCD_SuspendCallback+0x48>)
 810d4d6:	691b      	ldr	r3, [r3, #16]
 810d4d8:	4a03      	ldr	r2, [pc, #12]	@ (810d4e8 <HAL_PCD_SuspendCallback+0x48>)
 810d4da:	f043 0306 	orr.w	r3, r3, #6
 810d4de:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 810d4e0:	bf00      	nop
 810d4e2:	3708      	adds	r7, #8
 810d4e4:	46bd      	mov	sp, r7
 810d4e6:	bd80      	pop	{r7, pc}
 810d4e8:	e000ed00 	.word	0xe000ed00

0810d4ec <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d4ec:	b580      	push	{r7, lr}
 810d4ee:	b082      	sub	sp, #8
 810d4f0:	af00      	add	r7, sp, #0
 810d4f2:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 810d4f4:	687b      	ldr	r3, [r7, #4]
 810d4f6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d4fa:	4618      	mov	r0, r3
 810d4fc:	f7fe fcab 	bl	810be56 <USBD_LL_Resume>
}
 810d500:	bf00      	nop
 810d502:	3708      	adds	r7, #8
 810d504:	46bd      	mov	sp, r7
 810d506:	bd80      	pop	{r7, pc}

0810d508 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d508:	b580      	push	{r7, lr}
 810d50a:	b082      	sub	sp, #8
 810d50c:	af00      	add	r7, sp, #0
 810d50e:	6078      	str	r0, [r7, #4]
 810d510:	460b      	mov	r3, r1
 810d512:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 810d514:	687b      	ldr	r3, [r7, #4]
 810d516:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d51a:	78fa      	ldrb	r2, [r7, #3]
 810d51c:	4611      	mov	r1, r2
 810d51e:	4618      	mov	r0, r3
 810d520:	f7fe fd03 	bl	810bf2a <USBD_LL_IsoOUTIncomplete>
}
 810d524:	bf00      	nop
 810d526:	3708      	adds	r7, #8
 810d528:	46bd      	mov	sp, r7
 810d52a:	bd80      	pop	{r7, pc}

0810d52c <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d52c:	b580      	push	{r7, lr}
 810d52e:	b082      	sub	sp, #8
 810d530:	af00      	add	r7, sp, #0
 810d532:	6078      	str	r0, [r7, #4]
 810d534:	460b      	mov	r3, r1
 810d536:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 810d538:	687b      	ldr	r3, [r7, #4]
 810d53a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d53e:	78fa      	ldrb	r2, [r7, #3]
 810d540:	4611      	mov	r1, r2
 810d542:	4618      	mov	r0, r3
 810d544:	f7fe fcbf 	bl	810bec6 <USBD_LL_IsoINIncomplete>
}
 810d548:	bf00      	nop
 810d54a:	3708      	adds	r7, #8
 810d54c:	46bd      	mov	sp, r7
 810d54e:	bd80      	pop	{r7, pc}

0810d550 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d550:	b580      	push	{r7, lr}
 810d552:	b082      	sub	sp, #8
 810d554:	af00      	add	r7, sp, #0
 810d556:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 810d558:	687b      	ldr	r3, [r7, #4]
 810d55a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d55e:	4618      	mov	r0, r3
 810d560:	f7fe fd15 	bl	810bf8e <USBD_LL_DevConnected>
}
 810d564:	bf00      	nop
 810d566:	3708      	adds	r7, #8
 810d568:	46bd      	mov	sp, r7
 810d56a:	bd80      	pop	{r7, pc}

0810d56c <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 810d56c:	b580      	push	{r7, lr}
 810d56e:	b082      	sub	sp, #8
 810d570:	af00      	add	r7, sp, #0
 810d572:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 810d574:	687b      	ldr	r3, [r7, #4]
 810d576:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 810d57a:	4618      	mov	r0, r3
 810d57c:	f7fe fd12 	bl	810bfa4 <USBD_LL_DevDisconnected>
}
 810d580:	bf00      	nop
 810d582:	3708      	adds	r7, #8
 810d584:	46bd      	mov	sp, r7
 810d586:	bd80      	pop	{r7, pc}

0810d588 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 810d588:	b580      	push	{r7, lr}
 810d58a:	b082      	sub	sp, #8
 810d58c:	af00      	add	r7, sp, #0
 810d58e:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 810d590:	687b      	ldr	r3, [r7, #4]
 810d592:	781b      	ldrb	r3, [r3, #0]
 810d594:	2b00      	cmp	r3, #0
 810d596:	d13e      	bne.n	810d616 <USBD_LL_Init+0x8e>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 810d598:	4a21      	ldr	r2, [pc, #132]	@ (810d620 <USBD_LL_Init+0x98>)
 810d59a:	687b      	ldr	r3, [r7, #4]
 810d59c:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 810d5a0:	687b      	ldr	r3, [r7, #4]
 810d5a2:	4a1f      	ldr	r2, [pc, #124]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5a4:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 810d5a8:	4b1d      	ldr	r3, [pc, #116]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5aa:	4a1e      	ldr	r2, [pc, #120]	@ (810d624 <USBD_LL_Init+0x9c>)
 810d5ac:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 9;
 810d5ae:	4b1c      	ldr	r3, [pc, #112]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5b0:	2209      	movs	r2, #9
 810d5b2:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 810d5b4:	4b1a      	ldr	r3, [pc, #104]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5b6:	2202      	movs	r2, #2
 810d5b8:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = ENABLE;
 810d5ba:	4b19      	ldr	r3, [pc, #100]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5bc:	2201      	movs	r2, #1
 810d5be:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 810d5c0:	4b17      	ldr	r3, [pc, #92]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5c2:	2202      	movs	r2, #2
 810d5c4:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 810d5c6:	4b16      	ldr	r3, [pc, #88]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5c8:	2200      	movs	r2, #0
 810d5ca:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 810d5cc:	4b14      	ldr	r3, [pc, #80]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5ce:	2200      	movs	r2, #0
 810d5d0:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 810d5d2:	4b13      	ldr	r3, [pc, #76]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5d4:	2200      	movs	r2, #0
 810d5d6:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.battery_charging_enable = DISABLE;
 810d5d8:	4b11      	ldr	r3, [pc, #68]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5da:	2200      	movs	r2, #0
 810d5dc:	735a      	strb	r2, [r3, #13]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 810d5de:	4b10      	ldr	r3, [pc, #64]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5e0:	2200      	movs	r2, #0
 810d5e2:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 810d5e4:	4b0e      	ldr	r3, [pc, #56]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5e6:	2200      	movs	r2, #0
 810d5e8:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 810d5ea:	480d      	ldr	r0, [pc, #52]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5ec:	f7f5 fe50 	bl	8103290 <HAL_PCD_Init>
 810d5f0:	4603      	mov	r3, r0
 810d5f2:	2b00      	cmp	r3, #0
 810d5f4:	d001      	beq.n	810d5fa <USBD_LL_Init+0x72>
  {
    Error_Handler( );
 810d5f6:	f7f3 ff45 	bl	8101484 <Error_Handler>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN TxRx_Configuration */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 810d5fa:	2180      	movs	r1, #128	@ 0x80
 810d5fc:	4808      	ldr	r0, [pc, #32]	@ (810d620 <USBD_LL_Init+0x98>)
 810d5fe:	f7f7 f8a6 	bl	810474e <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 810d602:	2240      	movs	r2, #64	@ 0x40
 810d604:	2100      	movs	r1, #0
 810d606:	4806      	ldr	r0, [pc, #24]	@ (810d620 <USBD_LL_Init+0x98>)
 810d608:	f7f7 f85a 	bl	81046c0 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 810d60c:	2280      	movs	r2, #128	@ 0x80
 810d60e:	2101      	movs	r1, #1
 810d610:	4803      	ldr	r0, [pc, #12]	@ (810d620 <USBD_LL_Init+0x98>)
 810d612:	f7f7 f855 	bl	81046c0 <HAL_PCDEx_SetTxFiFo>
  /* USER CODE END TxRx_Configuration */
  }
  return USBD_OK;
 810d616:	2300      	movs	r3, #0
}
 810d618:	4618      	mov	r0, r3
 810d61a:	3708      	adds	r7, #8
 810d61c:	46bd      	mov	sp, r7
 810d61e:	bd80      	pop	{r7, pc}
 810d620:	10033b40 	.word	0x10033b40
 810d624:	40080000 	.word	0x40080000

0810d628 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 810d628:	b580      	push	{r7, lr}
 810d62a:	b084      	sub	sp, #16
 810d62c:	af00      	add	r7, sp, #0
 810d62e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d630:	2300      	movs	r3, #0
 810d632:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d634:	2300      	movs	r3, #0
 810d636:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 810d638:	687b      	ldr	r3, [r7, #4]
 810d63a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d63e:	4618      	mov	r0, r3
 810d640:	f7f5 ff32 	bl	81034a8 <HAL_PCD_Start>
 810d644:	4603      	mov	r3, r0
 810d646:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d648:	7bfb      	ldrb	r3, [r7, #15]
 810d64a:	4618      	mov	r0, r3
 810d64c:	f000 f942 	bl	810d8d4 <USBD_Get_USB_Status>
 810d650:	4603      	mov	r3, r0
 810d652:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d654:	7bbb      	ldrb	r3, [r7, #14]
}
 810d656:	4618      	mov	r0, r3
 810d658:	3710      	adds	r7, #16
 810d65a:	46bd      	mov	sp, r7
 810d65c:	bd80      	pop	{r7, pc}

0810d65e <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 810d65e:	b580      	push	{r7, lr}
 810d660:	b084      	sub	sp, #16
 810d662:	af00      	add	r7, sp, #0
 810d664:	6078      	str	r0, [r7, #4]
 810d666:	4608      	mov	r0, r1
 810d668:	4611      	mov	r1, r2
 810d66a:	461a      	mov	r2, r3
 810d66c:	4603      	mov	r3, r0
 810d66e:	70fb      	strb	r3, [r7, #3]
 810d670:	460b      	mov	r3, r1
 810d672:	70bb      	strb	r3, [r7, #2]
 810d674:	4613      	mov	r3, r2
 810d676:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d678:	2300      	movs	r3, #0
 810d67a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d67c:	2300      	movs	r3, #0
 810d67e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 810d680:	687b      	ldr	r3, [r7, #4]
 810d682:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 810d686:	78bb      	ldrb	r3, [r7, #2]
 810d688:	883a      	ldrh	r2, [r7, #0]
 810d68a:	78f9      	ldrb	r1, [r7, #3]
 810d68c:	f7f6 fc33 	bl	8103ef6 <HAL_PCD_EP_Open>
 810d690:	4603      	mov	r3, r0
 810d692:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d694:	7bfb      	ldrb	r3, [r7, #15]
 810d696:	4618      	mov	r0, r3
 810d698:	f000 f91c 	bl	810d8d4 <USBD_Get_USB_Status>
 810d69c:	4603      	mov	r3, r0
 810d69e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d6a0:	7bbb      	ldrb	r3, [r7, #14]
}
 810d6a2:	4618      	mov	r0, r3
 810d6a4:	3710      	adds	r7, #16
 810d6a6:	46bd      	mov	sp, r7
 810d6a8:	bd80      	pop	{r7, pc}

0810d6aa <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 810d6aa:	b580      	push	{r7, lr}
 810d6ac:	b084      	sub	sp, #16
 810d6ae:	af00      	add	r7, sp, #0
 810d6b0:	6078      	str	r0, [r7, #4]
 810d6b2:	460b      	mov	r3, r1
 810d6b4:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d6b6:	2300      	movs	r3, #0
 810d6b8:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d6ba:	2300      	movs	r3, #0
 810d6bc:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 810d6be:	687b      	ldr	r3, [r7, #4]
 810d6c0:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d6c4:	78fa      	ldrb	r2, [r7, #3]
 810d6c6:	4611      	mov	r1, r2
 810d6c8:	4618      	mov	r0, r3
 810d6ca:	f7f6 fc7e 	bl	8103fca <HAL_PCD_EP_Close>
 810d6ce:	4603      	mov	r3, r0
 810d6d0:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d6d2:	7bfb      	ldrb	r3, [r7, #15]
 810d6d4:	4618      	mov	r0, r3
 810d6d6:	f000 f8fd 	bl	810d8d4 <USBD_Get_USB_Status>
 810d6da:	4603      	mov	r3, r0
 810d6dc:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d6de:	7bbb      	ldrb	r3, [r7, #14]
}
 810d6e0:	4618      	mov	r0, r3
 810d6e2:	3710      	adds	r7, #16
 810d6e4:	46bd      	mov	sp, r7
 810d6e6:	bd80      	pop	{r7, pc}

0810d6e8 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 810d6e8:	b580      	push	{r7, lr}
 810d6ea:	b084      	sub	sp, #16
 810d6ec:	af00      	add	r7, sp, #0
 810d6ee:	6078      	str	r0, [r7, #4]
 810d6f0:	460b      	mov	r3, r1
 810d6f2:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d6f4:	2300      	movs	r3, #0
 810d6f6:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d6f8:	2300      	movs	r3, #0
 810d6fa:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 810d6fc:	687b      	ldr	r3, [r7, #4]
 810d6fe:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d702:	78fa      	ldrb	r2, [r7, #3]
 810d704:	4611      	mov	r1, r2
 810d706:	4618      	mov	r0, r3
 810d708:	f7f6 fd36 	bl	8104178 <HAL_PCD_EP_SetStall>
 810d70c:	4603      	mov	r3, r0
 810d70e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d710:	7bfb      	ldrb	r3, [r7, #15]
 810d712:	4618      	mov	r0, r3
 810d714:	f000 f8de 	bl	810d8d4 <USBD_Get_USB_Status>
 810d718:	4603      	mov	r3, r0
 810d71a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d71c:	7bbb      	ldrb	r3, [r7, #14]
}
 810d71e:	4618      	mov	r0, r3
 810d720:	3710      	adds	r7, #16
 810d722:	46bd      	mov	sp, r7
 810d724:	bd80      	pop	{r7, pc}

0810d726 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 810d726:	b580      	push	{r7, lr}
 810d728:	b084      	sub	sp, #16
 810d72a:	af00      	add	r7, sp, #0
 810d72c:	6078      	str	r0, [r7, #4]
 810d72e:	460b      	mov	r3, r1
 810d730:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d732:	2300      	movs	r3, #0
 810d734:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d736:	2300      	movs	r3, #0
 810d738:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 810d73a:	687b      	ldr	r3, [r7, #4]
 810d73c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d740:	78fa      	ldrb	r2, [r7, #3]
 810d742:	4611      	mov	r1, r2
 810d744:	4618      	mov	r0, r3
 810d746:	f7f6 fd7a 	bl	810423e <HAL_PCD_EP_ClrStall>
 810d74a:	4603      	mov	r3, r0
 810d74c:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d74e:	7bfb      	ldrb	r3, [r7, #15]
 810d750:	4618      	mov	r0, r3
 810d752:	f000 f8bf 	bl	810d8d4 <USBD_Get_USB_Status>
 810d756:	4603      	mov	r3, r0
 810d758:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d75a:	7bbb      	ldrb	r3, [r7, #14]
}
 810d75c:	4618      	mov	r0, r3
 810d75e:	3710      	adds	r7, #16
 810d760:	46bd      	mov	sp, r7
 810d762:	bd80      	pop	{r7, pc}

0810d764 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 810d764:	b480      	push	{r7}
 810d766:	b085      	sub	sp, #20
 810d768:	af00      	add	r7, sp, #0
 810d76a:	6078      	str	r0, [r7, #4]
 810d76c:	460b      	mov	r3, r1
 810d76e:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 810d770:	687b      	ldr	r3, [r7, #4]
 810d772:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d776:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 810d778:	f997 3003 	ldrsb.w	r3, [r7, #3]
 810d77c:	2b00      	cmp	r3, #0
 810d77e:	da0b      	bge.n	810d798 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 810d780:	78fb      	ldrb	r3, [r7, #3]
 810d782:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 810d786:	68f9      	ldr	r1, [r7, #12]
 810d788:	4613      	mov	r3, r2
 810d78a:	00db      	lsls	r3, r3, #3
 810d78c:	4413      	add	r3, r2
 810d78e:	009b      	lsls	r3, r3, #2
 810d790:	440b      	add	r3, r1
 810d792:	3316      	adds	r3, #22
 810d794:	781b      	ldrb	r3, [r3, #0]
 810d796:	e00b      	b.n	810d7b0 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 810d798:	78fb      	ldrb	r3, [r7, #3]
 810d79a:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 810d79e:	68f9      	ldr	r1, [r7, #12]
 810d7a0:	4613      	mov	r3, r2
 810d7a2:	00db      	lsls	r3, r3, #3
 810d7a4:	4413      	add	r3, r2
 810d7a6:	009b      	lsls	r3, r3, #2
 810d7a8:	440b      	add	r3, r1
 810d7aa:	f203 2356 	addw	r3, r3, #598	@ 0x256
 810d7ae:	781b      	ldrb	r3, [r3, #0]
  }
}
 810d7b0:	4618      	mov	r0, r3
 810d7b2:	3714      	adds	r7, #20
 810d7b4:	46bd      	mov	sp, r7
 810d7b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d7ba:	4770      	bx	lr

0810d7bc <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 810d7bc:	b580      	push	{r7, lr}
 810d7be:	b084      	sub	sp, #16
 810d7c0:	af00      	add	r7, sp, #0
 810d7c2:	6078      	str	r0, [r7, #4]
 810d7c4:	460b      	mov	r3, r1
 810d7c6:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d7c8:	2300      	movs	r3, #0
 810d7ca:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d7cc:	2300      	movs	r3, #0
 810d7ce:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 810d7d0:	687b      	ldr	r3, [r7, #4]
 810d7d2:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d7d6:	78fa      	ldrb	r2, [r7, #3]
 810d7d8:	4611      	mov	r1, r2
 810d7da:	4618      	mov	r0, r3
 810d7dc:	f7f6 fb67 	bl	8103eae <HAL_PCD_SetAddress>
 810d7e0:	4603      	mov	r3, r0
 810d7e2:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d7e4:	7bfb      	ldrb	r3, [r7, #15]
 810d7e6:	4618      	mov	r0, r3
 810d7e8:	f000 f874 	bl	810d8d4 <USBD_Get_USB_Status>
 810d7ec:	4603      	mov	r3, r0
 810d7ee:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 810d7f0:	7bbb      	ldrb	r3, [r7, #14]
}
 810d7f2:	4618      	mov	r0, r3
 810d7f4:	3710      	adds	r7, #16
 810d7f6:	46bd      	mov	sp, r7
 810d7f8:	bd80      	pop	{r7, pc}

0810d7fa <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 810d7fa:	b580      	push	{r7, lr}
 810d7fc:	b086      	sub	sp, #24
 810d7fe:	af00      	add	r7, sp, #0
 810d800:	60f8      	str	r0, [r7, #12]
 810d802:	607a      	str	r2, [r7, #4]
 810d804:	603b      	str	r3, [r7, #0]
 810d806:	460b      	mov	r3, r1
 810d808:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d80a:	2300      	movs	r3, #0
 810d80c:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d80e:	2300      	movs	r3, #0
 810d810:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 810d812:	68fb      	ldr	r3, [r7, #12]
 810d814:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 810d818:	7af9      	ldrb	r1, [r7, #11]
 810d81a:	683b      	ldr	r3, [r7, #0]
 810d81c:	687a      	ldr	r2, [r7, #4]
 810d81e:	f7f6 fc71 	bl	8104104 <HAL_PCD_EP_Transmit>
 810d822:	4603      	mov	r3, r0
 810d824:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d826:	7dfb      	ldrb	r3, [r7, #23]
 810d828:	4618      	mov	r0, r3
 810d82a:	f000 f853 	bl	810d8d4 <USBD_Get_USB_Status>
 810d82e:	4603      	mov	r3, r0
 810d830:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 810d832:	7dbb      	ldrb	r3, [r7, #22]
}
 810d834:	4618      	mov	r0, r3
 810d836:	3718      	adds	r7, #24
 810d838:	46bd      	mov	sp, r7
 810d83a:	bd80      	pop	{r7, pc}

0810d83c <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 810d83c:	b580      	push	{r7, lr}
 810d83e:	b086      	sub	sp, #24
 810d840:	af00      	add	r7, sp, #0
 810d842:	60f8      	str	r0, [r7, #12]
 810d844:	607a      	str	r2, [r7, #4]
 810d846:	603b      	str	r3, [r7, #0]
 810d848:	460b      	mov	r3, r1
 810d84a:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 810d84c:	2300      	movs	r3, #0
 810d84e:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d850:	2300      	movs	r3, #0
 810d852:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 810d854:	68fb      	ldr	r3, [r7, #12]
 810d856:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 810d85a:	7af9      	ldrb	r1, [r7, #11]
 810d85c:	683b      	ldr	r3, [r7, #0]
 810d85e:	687a      	ldr	r2, [r7, #4]
 810d860:	f7f6 fbfd 	bl	810405e <HAL_PCD_EP_Receive>
 810d864:	4603      	mov	r3, r0
 810d866:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 810d868:	7dfb      	ldrb	r3, [r7, #23]
 810d86a:	4618      	mov	r0, r3
 810d86c:	f000 f832 	bl	810d8d4 <USBD_Get_USB_Status>
 810d870:	4603      	mov	r3, r0
 810d872:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 810d874:	7dbb      	ldrb	r3, [r7, #22]
}
 810d876:	4618      	mov	r0, r3
 810d878:	3718      	adds	r7, #24
 810d87a:	46bd      	mov	sp, r7
 810d87c:	bd80      	pop	{r7, pc}

0810d87e <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 810d87e:	b580      	push	{r7, lr}
 810d880:	b082      	sub	sp, #8
 810d882:	af00      	add	r7, sp, #0
 810d884:	6078      	str	r0, [r7, #4]
 810d886:	460b      	mov	r3, r1
 810d888:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 810d88a:	687b      	ldr	r3, [r7, #4]
 810d88c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 810d890:	78fa      	ldrb	r2, [r7, #3]
 810d892:	4611      	mov	r1, r2
 810d894:	4618      	mov	r0, r3
 810d896:	f7f6 fc1d 	bl	81040d4 <HAL_PCD_EP_GetRxCount>
 810d89a:	4603      	mov	r3, r0
}
 810d89c:	4618      	mov	r0, r3
 810d89e:	3708      	adds	r7, #8
 810d8a0:	46bd      	mov	sp, r7
 810d8a2:	bd80      	pop	{r7, pc}

0810d8a4 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 810d8a4:	b480      	push	{r7}
 810d8a6:	b083      	sub	sp, #12
 810d8a8:	af00      	add	r7, sp, #0
 810d8aa:	6078      	str	r0, [r7, #4]
  UNUSED(size);
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 810d8ac:	4b03      	ldr	r3, [pc, #12]	@ (810d8bc <USBD_static_malloc+0x18>)
}
 810d8ae:	4618      	mov	r0, r3
 810d8b0:	370c      	adds	r7, #12
 810d8b2:	46bd      	mov	sp, r7
 810d8b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d8b8:	4770      	bx	lr
 810d8ba:	bf00      	nop
 810d8bc:	10034024 	.word	0x10034024

0810d8c0 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 810d8c0:	b480      	push	{r7}
 810d8c2:	b083      	sub	sp, #12
 810d8c4:	af00      	add	r7, sp, #0
 810d8c6:	6078      	str	r0, [r7, #4]
  UNUSED(p);
}
 810d8c8:	bf00      	nop
 810d8ca:	370c      	adds	r7, #12
 810d8cc:	46bd      	mov	sp, r7
 810d8ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d8d2:	4770      	bx	lr

0810d8d4 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 810d8d4:	b480      	push	{r7}
 810d8d6:	b085      	sub	sp, #20
 810d8d8:	af00      	add	r7, sp, #0
 810d8da:	4603      	mov	r3, r0
 810d8dc:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 810d8de:	2300      	movs	r3, #0
 810d8e0:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 810d8e2:	79fb      	ldrb	r3, [r7, #7]
 810d8e4:	2b03      	cmp	r3, #3
 810d8e6:	d817      	bhi.n	810d918 <USBD_Get_USB_Status+0x44>
 810d8e8:	a201      	add	r2, pc, #4	@ (adr r2, 810d8f0 <USBD_Get_USB_Status+0x1c>)
 810d8ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810d8ee:	bf00      	nop
 810d8f0:	0810d901 	.word	0x0810d901
 810d8f4:	0810d907 	.word	0x0810d907
 810d8f8:	0810d90d 	.word	0x0810d90d
 810d8fc:	0810d913 	.word	0x0810d913
  {
    case HAL_OK :
      usb_status = USBD_OK;
 810d900:	2300      	movs	r3, #0
 810d902:	73fb      	strb	r3, [r7, #15]
    break;
 810d904:	e00b      	b.n	810d91e <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 810d906:	2303      	movs	r3, #3
 810d908:	73fb      	strb	r3, [r7, #15]
    break;
 810d90a:	e008      	b.n	810d91e <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 810d90c:	2301      	movs	r3, #1
 810d90e:	73fb      	strb	r3, [r7, #15]
    break;
 810d910:	e005      	b.n	810d91e <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 810d912:	2303      	movs	r3, #3
 810d914:	73fb      	strb	r3, [r7, #15]
    break;
 810d916:	e002      	b.n	810d91e <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 810d918:	2303      	movs	r3, #3
 810d91a:	73fb      	strb	r3, [r7, #15]
    break;
 810d91c:	bf00      	nop
  }
  return usb_status;
 810d91e:	7bfb      	ldrb	r3, [r7, #15]
}
 810d920:	4618      	mov	r0, r3
 810d922:	3714      	adds	r7, #20
 810d924:	46bd      	mov	sp, r7
 810d926:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d92a:	4770      	bx	lr

0810d92c <memset>:
 810d92c:	4402      	add	r2, r0
 810d92e:	4603      	mov	r3, r0
 810d930:	4293      	cmp	r3, r2
 810d932:	d100      	bne.n	810d936 <memset+0xa>
 810d934:	4770      	bx	lr
 810d936:	f803 1b01 	strb.w	r1, [r3], #1
 810d93a:	e7f9      	b.n	810d930 <memset+0x4>

0810d93c <__libc_init_array>:
 810d93c:	b570      	push	{r4, r5, r6, lr}
 810d93e:	4d0d      	ldr	r5, [pc, #52]	@ (810d974 <__libc_init_array+0x38>)
 810d940:	4c0d      	ldr	r4, [pc, #52]	@ (810d978 <__libc_init_array+0x3c>)
 810d942:	1b64      	subs	r4, r4, r5
 810d944:	10a4      	asrs	r4, r4, #2
 810d946:	2600      	movs	r6, #0
 810d948:	42a6      	cmp	r6, r4
 810d94a:	d109      	bne.n	810d960 <__libc_init_array+0x24>
 810d94c:	4d0b      	ldr	r5, [pc, #44]	@ (810d97c <__libc_init_array+0x40>)
 810d94e:	4c0c      	ldr	r4, [pc, #48]	@ (810d980 <__libc_init_array+0x44>)
 810d950:	f000 f826 	bl	810d9a0 <_init>
 810d954:	1b64      	subs	r4, r4, r5
 810d956:	10a4      	asrs	r4, r4, #2
 810d958:	2600      	movs	r6, #0
 810d95a:	42a6      	cmp	r6, r4
 810d95c:	d105      	bne.n	810d96a <__libc_init_array+0x2e>
 810d95e:	bd70      	pop	{r4, r5, r6, pc}
 810d960:	f855 3b04 	ldr.w	r3, [r5], #4
 810d964:	4798      	blx	r3
 810d966:	3601      	adds	r6, #1
 810d968:	e7ee      	b.n	810d948 <__libc_init_array+0xc>
 810d96a:	f855 3b04 	ldr.w	r3, [r5], #4
 810d96e:	4798      	blx	r3
 810d970:	3601      	adds	r6, #1
 810d972:	e7f2      	b.n	810d95a <__libc_init_array+0x1e>
 810d974:	0810da54 	.word	0x0810da54
 810d978:	0810da54 	.word	0x0810da54
 810d97c:	0810da54 	.word	0x0810da54
 810d980:	0810da58 	.word	0x0810da58

0810d984 <memcpy>:
 810d984:	440a      	add	r2, r1
 810d986:	4291      	cmp	r1, r2
 810d988:	f100 33ff 	add.w	r3, r0, #4294967295
 810d98c:	d100      	bne.n	810d990 <memcpy+0xc>
 810d98e:	4770      	bx	lr
 810d990:	b510      	push	{r4, lr}
 810d992:	f811 4b01 	ldrb.w	r4, [r1], #1
 810d996:	f803 4f01 	strb.w	r4, [r3, #1]!
 810d99a:	4291      	cmp	r1, r2
 810d99c:	d1f9      	bne.n	810d992 <memcpy+0xe>
 810d99e:	bd10      	pop	{r4, pc}

0810d9a0 <_init>:
 810d9a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 810d9a2:	bf00      	nop
 810d9a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 810d9a6:	bc08      	pop	{r3}
 810d9a8:	469e      	mov	lr, r3
 810d9aa:	4770      	bx	lr

0810d9ac <_fini>:
 810d9ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 810d9ae:	bf00      	nop
 810d9b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 810d9b2:	bc08      	pop	{r3}
 810d9b4:	469e      	mov	lr, r3
 810d9b6:	4770      	bx	lr
